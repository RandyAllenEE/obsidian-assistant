/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => AssistantPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian27 = require("obsidian");

// src/settings.ts
var DEFAULT_SETTINGS = {
  myPlugins: null,
  // Initialized below
  myFolders: null,
  mySideBar: null,
  myStatusBar: null,
  mySnippets: null,
  myHeadings: null,
  myFormulas: null,
  refreshInterval: 1e3
};
var DEFAULT_MY_FOLDERS_SETTINGS = {
  enabled: true,
  areFoldersHidden: true,
  matchCaseInsensitive: true,
  addHiddenFoldersToObsidianIgnoreList: false,
  hideBottomStatusBarIndicatorText: false,
  enableCompatQuickExplorer: false,
  attachmentFolderNames: ["attachments"]
};
var LoadingMethod = /* @__PURE__ */ ((LoadingMethod2) => {
  LoadingMethod2["disabled"] = "disabled";
  LoadingMethod2["instant"] = "instant";
  LoadingMethod2["short"] = "short";
  LoadingMethod2["long"] = "long";
  return LoadingMethod2;
})(LoadingMethod || {});
var DEFAULT_DEVICE_SETTINGS = {
  shortDelaySeconds: 5,
  longDelaySeconds: 15,
  delayBetweenPlugins: 40,
  defaultStartupType: null,
  showDescriptions: true,
  enableDependencies: false,
  plugins: {}
};
var DEFAULT_MY_PLUGINS_SETTINGS = {
  enabled: true,
  dualConfigs: false,
  showConsoleLog: false,
  desktop: DEFAULT_DEVICE_SETTINGS
};
var DEFAULT_STATUS_BAR_SETTINGS = {
  enabled: true,
  status: {},
  version: "0.0.1"
};
var DEFAULT_MY_SNIPPETS_SETTINGS = {
  aestheticStyle: false,
  snippetViewPosition: "left",
  openSnippetFile: true,
  stylingTemplate: "",
  snippetEnabledStatus: false,
  showStatusBarIcon: true,
  enabled: true
};
var DEFAULT_MY_HEADINGS_SETTINGS = {
  // Auto Numbering
  enabled: true,
  auto: false,
  firstLevel: 1,
  maxLevel: 6,
  headingStyles: ["1", "a", "A", "\u4E00", "\u2460", "1"],
  headingSeparators: ["", "-", ":", ".", "\u2014", "-"],
  headingStartValues: ["0", "1", "1", "1", "1", "1"],
  skipHeadings: "",
  // Heading Shifter
  limitHeadingFrom: 1,
  overrideTab: false,
  styleToRemove: {
    beginning: {
      ul: true,
      ol: true,
      userDefined: []
    },
    surrounding: {
      bold: true,
      italic: true,
      userDefined: []
    }
  },
  list: {
    childrenBehavior: "outdent to zero"
  },
  editor: {
    tabSize: 4
  }
};
var DEFAULT_MY_FORMULAS_SETTINGS = {
  enabled: true,
  auto: false,
  mode: "continuous",
  maxDepth: 4
};
var DEFAULT_MY_SIDEBAR_SETTINGS = {
  enabled: true,
  autoHide: {
    enabled: true,
    leftSidebar: true,
    rightSidebar: true,
    syncLeftRight: true,
    enforceSameDelay: true,
    sidebarDelay: 500,
    sidebarExpandDelay: 200,
    leftSideBarPixelTrigger: 40,
    rightSideBarPixelTrigger: 40,
    overlayMode: false,
    expandCollapseSpeed: 300,
    leftSidebarMaxWidth: 350,
    rightSidebarMaxWidth: 350
  },
  ribbon: {
    enabled: true,
    ribbonDisplayDelay: 1e3,
    elements: {}
  },
  tabs: {
    enabled: true,
    elements: {},
    bindings: []
  }
};
DEFAULT_SETTINGS.myPlugins = DEFAULT_MY_PLUGINS_SETTINGS;
DEFAULT_SETTINGS.myFolders = DEFAULT_MY_FOLDERS_SETTINGS;
DEFAULT_SETTINGS.mySideBar = DEFAULT_MY_SIDEBAR_SETTINGS;
DEFAULT_SETTINGS.myStatusBar = DEFAULT_STATUS_BAR_SETTINGS;
DEFAULT_SETTINGS.mySnippets = DEFAULT_MY_SNIPPETS_SETTINGS;
DEFAULT_SETTINGS.myHeadings = DEFAULT_MY_HEADINGS_SETTINGS;
DEFAULT_SETTINGS.myFormulas = DEFAULT_MY_FORMULAS_SETTINGS;

// src/folders/manager.ts
var import_obsidian2 = require("obsidian");

// src/folders/compat.ts
function getFolderNameWithoutPrefix(folderName) {
  if (folderName.toLowerCase().startsWith("endswith::")) {
    return folderName.substring("endsWith::".length).trim();
  } else if (folderName.toLowerCase().startsWith("startswith::")) {
    return folderName.substring("startsWith::".length).trim();
  } else {
    return folderName;
  }
}
var CompatQuickExplorer = {
  getAdditionalDocumentSelectorStringForFolder: function(folderName, pluginSettings) {
    if (folderName.toLowerCase().startsWith("endswith::")) {
      return `.is-qe-folder[data-file-path$="${getFolderNameWithoutPrefix(folderName)}"${pluginSettings.matchCaseInsensitive ? " i" : ""}]`;
    } else if (folderName.toLowerCase().startsWith("startswith::")) {
      return `.is-qe-folder[data-file-path^="${getFolderNameWithoutPrefix(folderName)}"${pluginSettings.matchCaseInsensitive ? " i" : ""}], .is-qe-folder[data-file-path*="/${getFolderNameWithoutPrefix(folderName)}"${pluginSettings.matchCaseInsensitive ? " i" : ""}]`;
    } else {
      return `.is-qe-folder[data-file-path$="/${folderName.trim()}"${pluginSettings.matchCaseInsensitive ? " i" : ""}], .is-qe-folder[data-file-path="${folderName.trim()}"${pluginSettings.matchCaseInsensitive ? " i" : ""}]`;
    }
  },
  shouldMutationRecordTriggerFolderReProcessing: (record) => {
    var _a, _b;
    for (const addedNode of record.addedNodes) {
      if (!addedNode.tagName)
        continue;
      if (addedNode.classList.contains("qe-popup-menu")) {
        const firstQePopUpMenu = document.getElementsByClassName("qe-popup-menu")[0];
        if (!firstQePopUpMenu)
          return true;
        firstQePopUpMenu.style.top = "";
        firstQePopUpMenu.style.bottom = "1.7rem";
        return true;
      }
    }
    if ((_b = (_a = record.target) == null ? void 0 : _a.parentElement) == null ? void 0 : _b.classList.contains("is-qe-folder")) {
      return true;
    }
    return false;
  }
};

// src/i18n/helpers.ts
var import_obsidian = require("obsidian");

// src/i18n/locales/en.ts
var en_default = {
  // General
  "Module is disabled.": "Module is disabled.",
  "Obsidian Assistant Settings": "Obsidian Assistant Settings",
  "Global Settings": "Global Settings",
  "Auto-Numbering Refresh Interval": "Auto-Numbering Refresh Interval",
  "Time in milliseconds to wait before auto-numbering triggers (after losing focus)": "Time in milliseconds to wait before auto-numbering triggers (after losing focus)",
  "Modules": "Modules",
  // My Folders
  "My Folders": "My Folders",
  "Loading MyFolders module": "Loading MyFolders module",
  "Toggle visibility of hidden folders": "Toggle visibility of hidden folders",
  "Show hidden folders": "Show hidden folders",
  "Hide hidden folders again": "Hide hidden folders again",
  "Configured folders are hidden": "Configured folders are hidden",
  "Attachment Folder Names": "Attachment Folder Names",
  "Enter folder names to hide, one per line. Use 'endswith::' or 'startswith::' for prefix/suffix matching.": "Enter folder names to hide, one per line. Use 'endswith::' or 'startswith::' for prefix/suffix matching.",
  "Match path case-insensitive": "Match path case-insensitive",
  "Hide configured folders": "Hide configured folders",
  "Add hidden folders to Obsidian ignore list": "Add hidden folders to Obsidian ignore list",
  "Hide bottom status bar indicator text": "Hide bottom status bar indicator text",
  "Experimental & Unstable Settings": "Experimental & Unstable Settings",
  "Enable compatibility with Quick Explorer": "Enable compatibility with Quick Explorer",
  "Folders to hide": "Folders to hide",
  "The names of the folders to hide, one per line. Either exact folder-names, startsWith::FOLDERPREFIX, or endsWith::FOLDERSUFFIX": "The names of the folders to hide, one per line. Either exact folder-names, startsWith::FOLDERPREFIX, or endsWith::FOLDERSUFFIX",
  "attachments\\nendsWith::_attachments": "attachments\\nendsWith::_attachments",
  "Ignore Upper/lowercase": "Ignore Upper/lowercase",
  "If enabled, 'SOMEFOLDER', 'someFolder', or 'sOmeFoldEr' will all be treated the same and matched.": "If enabled, 'SOMEFOLDER', 'someFolder', or 'sOmeFoldEr' will all be treated the same and matched.",
  "Hide folders": "Hide folders",
  "If the configured folders should be hidden or not": "If the configured folders should be hidden or not",
  "Add Hidden Folders to Obsidian Exclusion-List": "Add Hidden Folders to Obsidian Exclusion-List",
  "Excluded files will be hidden in Search, Graph View, and Unlinked Mentions, less noticeable in Quick Switcher and link suggestions.": "Excluded files will be hidden in Search, Graph View, and Unlinked Mentions, less noticeable in Quick Switcher and link suggestions.",
  'Hide bottom status-bar "Folders are Hidden" indicator': 'Hide bottom status-bar "Folders are Hidden" indicator',
  "If enable there will be no bottom-bar indicator-text telling you if this plugin is active.": "If enable there will be no bottom-bar indicator-text telling you if this plugin is active.",
  "[EXPERIMENTAL] Compatibility: quick-explorer by pjeby": "[EXPERIMENTAL] Compatibility: quick-explorer by pjeby",
  "[WARNING: UNSTABLE] Also hide hidden folders in the https://github.com/pjeby/quick-explorer plugin. Not affiliated with quick-explorer's author.": "[WARNING: UNSTABLE] Also hide hidden folders in the https://github.com/pjeby/quick-explorer plugin. Not affiliated with quick-explorer's author.",
  // My Plugins
  "My Plugins": "My Plugins",
  "Loading Obsidian Assistant...": "Loading Obsidian Assistant...",
  "Loading Settings...": "Loading Settings...",
  "Unloading Obsidian Assistant...": "Unloading Obsidian Assistant...",
  "Starting {id} after a {type} delay": "Starting {id} after a {type} delay",
  "Failed to load plugin {id} after delay:": "Failed to load plugin {id} after delay:",
  "Dual Configurations": "Dual Configurations",
  "Separated configuration for desktop and mobile.": "Separated configuration for desktop and mobile.",
  "Show Console Log": "Show Console Log",
  "Show log in console when a plugin is loaded.": "Show log in console when a plugin is loaded.",
  "Short Delay Duration (s)": "Short Delay Duration (s)",
  "Long Delay Duration (s)": "Long Delay Duration (s)",
  "Default Startup Type": "Default Startup Type",
  "Startup type used when a plugin is not configured.": "Startup type used when a plugin is not configured.",
  "Show Descriptions": "Show Descriptions",
  "Show plugin descriptions in the list.": "Show plugin descriptions in the list.",
  "Set the delay for all plugins at once": "Set the delay for all plugins at once",
  "Select a startup type to apply to all plugins.": "Select a startup type to apply to all plugins.",
  "Search plugins...": "Search plugins...",
  "All": "All",
  "Instant": "Instant",
  "Short": "Short",
  "Long": "Long",
  "Disabled": "Disabled",
  "Separate desktop/mobile configuration": "Separate desktop/mobile configuration",
  "Enable this if you want to have different settings depending whether you're using a desktop or mobile device. All of the settings below can be configured differently on desktop and mobile. You're currently using the {device} settings.": "Enable this if you want to have different settings depending whether you're using a desktop or mobile device. All of the settings below can be configured differently on desktop and mobile. You're currently using the {device} settings.",
  "Short delay (seconds)": "Short delay (seconds)",
  "Long delay (seconds)": "Long delay (seconds)",
  "Default startup type for new plugins": "Default startup type for new plugins",
  "Nothing configured": "Nothing configured",
  "Show plugin descriptions": "Show plugin descriptions",
  "Set all plugins to be:": "Set all plugins to be:",
  "Plugins": "Plugins",
  "Filter by: ": "Filter by: ",
  "Type to filter list": "Type to filter list",
  "\u26D4 Disable plugin": "\u26D4 Disable plugin",
  "\u26A1 Instant": "\u26A1 Instant",
  "\u231A Short delay": "\u231A Short delay",
  "\u{1F4A4} Long delay": "\u{1F4A4} Long delay",
  "{id} after a {type} delay": "{id} after a {type} delay",
  "My Status Bar": "My Status Bar",
  "Drag to reorder": "Drag to reorder",
  "Visibility": "Visibility",
  "Remove orphan": "Remove orphan",
  "This element is currently not present in the status bar.": "This element is currently not present in the status bar.",
  "Drag to reorder ribbon icons. Click eye icon to toggle visibility.": "Drag to reorder ribbon icons. Click eye icon to toggle visibility.",
  "No ribbon elements found yet.": "No ribbon elements found yet.",
  // My Snippets
  "My Snippets": "My Snippets",
  "Loading MySnippets module...": "Loading MySnippets module...",
  "Unloading MySnippets module...": "Unloading MySnippets module...",
  "Open snippets in status bar": "Open snippets in status bar",
  "Create new CSS snippet": "Create new CSS snippet",
  "Configure Snippets": "Configure Snippets",
  "Glass Style": "Glass Style",
  "Turn on frosted glass for the status bar menu.": "Turn on frosted glass for the status bar menu.",
  "Open Script after Creation": "Open Script after Creation",
  "Open the CSS file automatically after creating a new snippet.": "Open the CSS file automatically after creating a new snippet.",
  "Enable/Disable after Creation": "Enable/Disable after Creation",
  "Set the snippet to enabled or disabled by default after creation.": "Set the snippet to enabled or disabled by default after creation.",
  "Script Template": "Script Template",
  "Template for new CSS snippets.": "Template for new CSS snippets.",
  "Show Status Bar Icon": "Show Status Bar Icon",
  "Toggle the visibility of the snippets icon in the status bar.": "Toggle the visibility of the snippets icon in the status bar.",
  "Manage Snippets": "Manage Snippets",
  "Reload Snippets": "Reload Snippets",
  "Click to refresh the list of snippets.": "Click to refresh the list of snippets.",
  "Glass menu effect": "Glass menu effect",
  "Choose to change the background from the secondary background color of your theme to a glass background.": "Choose to change the background from the secondary background color of your theme to a glass background.",
  "Auto open new snippet": "Auto open new snippet",
  "Choose whether or not to open CSS snippet files immeditaley after creating them. It will open in your default app.": "Choose whether or not to open CSS snippet files immeditaley after creating them. It will open in your default app.",
  "Set new snippet status": "Set new snippet status",
  "Choose whether or not to have newly created CSS snippet files toggled on automatically upon creation.": "Choose whether or not to have newly created CSS snippet files toggled on automatically upon creation.",
  "CSS snippet template": "CSS snippet template",
  "Set default CSS styling as a template for new CSS files you choose to create.": "Set default CSS styling as a template for new CSS files you choose to create.",
  "If you like this Plugin and are considering donating to support continued development, use the buttons below!": "If you like this Plugin and are considering donating to support continued development, use the buttons below!",
  "No CSS snippets found.": "No CSS snippets found.",
  "Buy me a coffee": "Buy me a coffee",
  "Created by ": "Created by ",
  "Open snippet": "Open snippet",
  "Actions": "Actions",
  "Reload snippets": "Reload snippets",
  "Snippets reloaded": "Snippets reloaded",
  "Open snippets folder": "Open snippets folder",
  "Create a CSS Snippet": "Create a CSS Snippet",
  "CSS Snippet Title": "CSS Snippet Title",
  "Write the title for this CSS snippet file.": "Write the title for this CSS snippet file.",
  "CSS Snippet Styles": "CSS Snippet Styles",
  "Add in styling for this CSS snippet file.": "Add in styling for this CSS snippet file.",
  '"{fileName}.css" has been created!': '"{fileName}.css" has been created!',
  '"{fileName}.css" already exists.': '"{fileName}.css" already exists.',
  "Missing name for file": "Missing name for file",
  "Create Snippet": "Create Snippet",
  // MyHeadings
  "My Headings": "My Headings",
  "Number Headings": "Number Headings",
  "Remove Heading Numbering": "Remove Heading Numbering",
  "Auto Number Headings": "Auto Number Headings",
  "Automatically number headings on blur": "Automatically number headings on blur",
  "Create numbers automatically on blur": "Create numbers automatically on blur (triggers when you click away)",
  "First Level": "First Level",
  "Starting heading level for numbering": "Starting heading level for numbering",
  "Max Level": "Max Level",
  "Maximum heading level for numbering": "Maximum heading level for numbering",
  "Heading Styles": "Heading Styles",
  "Numbering style for each level (1-6)": "Numbering style for each level (1-6)",
  "Heading Separators": "Heading Separators",
  "Separator after each level (empty for H1, then 2-6)": "Separator after each level (empty for H1, then 2-6)",
  "Start Values": "Start Values",
  "Starting number for each level": "Starting number for each level",
  "Level": "Level",
  "Style": "Style",
  "Separator": "Separator",
  "Start At": "Start At",
  // MyFormulas
  "My Formulas": "My Formulas",
  "Number Formulas": "Number Formulas",
  "Remove Formula Numbering": "Remove Formula Numbering",
  "Auto Number Formulas": "Auto Number Formulas",
  "Automatically number formulas on blur": "Automatically number formulas on blur",
  "Automatically number formulas (triggers on blur if enabled)": "Automatically number formulas (triggers on blur if enabled)",
  "Numbering Mode": "Numbering Mode",
  "Continuous: 1,2,3... | Heading-based: 1.1-1, 1.1-2...": "Continuous: 1,2,3... | Heading-based: 1.1-1, 1.1-2...",
  "Continuous (1, 2, 3) or Heading-based (1.1-1, 1.1-2)": "Continuous (1, 2, 3) or Heading-based (1.1-1, 1.1-2)",
  "Continuous": "Continuous",
  "Heading-based": "Heading-based",
  "Configure Formulas": "Configure Formulas",
  "Heading-Based": "Heading-Based",
  "Max Heading Depth": "Max Heading Depth",
  "Depth of headings to include in equation number": "Depth of headings to include in equation number",
  // Heading Shifter
  "Auto Numbering": "Auto Numbering",
  "Heading Shifter": "Heading Shifter",
  "Lower limit of Heading": "Lower limit of Heading",
  "The lower Heading Size that will be decreased by the Heading Shift": "The lower Heading Size that will be decreased by the Heading Shift",
  "Enable override tab behavior": "Enable override tab behavior",
  'Tab execute "Increase Headings" and Shift-Tab execute "Decrease Headings"': 'Tab execute "Increase Headings" and Shift-Tab execute "Decrease Headings"',
  "Style to remove": "Style to remove",
  "If this style is at the position of a line, remove it": "If this style is at the position of a line, remove it",
  "Beginning": "Beginning",
  "Unordered list": "Unordered list",
  "Ordered list": "Ordered list",
  "User defined": "User defined",
  "Arbitrary string (regular expression)": "Arbitrary string (regular expression)",
  "Surrounding": "Surrounding",
  "Bold": "Bold",
  "Italic": "Italic",
  "Children behavior": "Children behavior",
  "Outdent to 0": "Outdent to 0",
  "Sync with headings": "Sync with headings",
  "Noting": "Noting",
  "Tab size": "Tab size",
  "Maximum heading level to use for formula numbering": "Maximum heading level to use for formula numbering",
  "For Heading-based mode: max depth of heading to use as prefix (e.g. 4 means use H4 at most)": "For Heading-based mode: max depth of heading to use as prefix (e.g. 4 means use H4 at most)",
  // Shifter Commands
  "Increase Headings": "Increase Headings",
  "Increase Headings (forced)": "Increase Headings (forced)",
  "Decrease Headings": "Decrease Headings",
  "Apply Heading": "Apply Heading",
  "Insert Heading at current level": "Insert Heading at current level",
  "Insert Heading at one level deeper": "Insert Heading at one level deeper",
  "Insert Heading at one level higher": "Insert Heading at one level higher",
  // Commands & Modals
  "Configure Headings": "Configure Headings",
  "Apply Now": "Apply Now",
  "Apply numbering once without saving to frontmatter": "Apply numbering once without saving to frontmatter",
  "Save to Frontmatter": "Save to Frontmatter",
  "Save settings to frontmatter and apply": "Save settings to frontmatter and apply",
  "Remove Numbering": "Remove Numbering",
  "Numbering applied (one-time)": "Numbering applied (one-time)",
  "Formula numbering applied (one-time)": "Formula numbering applied (one-time)",
  "Settings saved to frontmatter and applied": "Settings saved to frontmatter and applied",
  "Heading numbering removed": "Heading numbering removed",
  "Formula numbering removed": "Formula numbering removed",
  // MySideBar
  "My SideBar": "My SideBar",
  "Left Sidebar": "Left Sidebar",
  "Right Sidebar": "Right Sidebar",
  "Auto Hide": "Auto Hide",
  "Coming Soon": "Coming Soon",
  "Settings for Left Sidebar control will be here.": "Settings for Left Sidebar control will be here.",
  "Settings for Right Sidebar control will be here.": "Settings for Right Sidebar control will be here.",
  "Left sidebar hover": "Left sidebar hover",
  "Enables the expansion and collapsing of the left sidebar on hover.": "Enables the expansion and collapsing of the left sidebar on hover.",
  "Right sidebar hover": "Right sidebar hover",
  "Enables the expansion and collapsing of the right sidebar on hover. Only collapses the right panel unless you have a right ribbon.": "Enables the expansion and collapsing of the right sidebar on hover. Only collapses the right panel unless you have a right ribbon.",
  "Sync left and right": "Sync left and right",
  "If enabled, hovering over the right sidebar will also expand the left sidebar at the same time, and vice versa. (Left and Right sidebar must both be enabled above)": "If enabled, hovering over the right sidebar will also expand the left sidebar at the same time, and vice versa. (Left and Right sidebar must both be enabled above)",
  "Overlay mode": "Overlay mode",
  "When enabled, sidebars will slide over the main content without affecting the layout. When disabled, sidebars will expand by pushing content.": "When enabled, sidebars will slide over the main content without affecting the layout. When disabled, sidebars will expand by pushing content.",
  "Behavior": "Behavior",
  "Left sidebar pixel trigger": "Left sidebar pixel trigger",
  "Specify the number of pixels from the left edge of the editor that will trigger the left sidebar to open on hover (must be greater than 0)": "Specify the number of pixels from the left edge of the editor that will trigger the left sidebar to open on hover (must be greater than 0)",
  "Right sidebar pixel trigger": "Right sidebar pixel trigger",
  "Specify the number of pixels from the right edge of the editor that will trigger the right sidebar to open on hover (must be greater than 0)": "Specify the number of pixels from the right edge of the editor that will trigger the right sidebar to open on hover (must be greater than 0)",
  "Timing": "Timing",
  "Sidebar collapse delay": "Sidebar collapse delay",
  "The delay in milliseconds before the sidebar collapses after the mouse has left. Enter '0' to disable delay.": "The delay in milliseconds before the sidebar collapses after the mouse has left. Enter '0' to disable delay.",
  "Sidebar expand delay": "Sidebar expand delay",
  "The delay in milliseconds before the sidebar expands after hovering. Default is 200ms.": "The delay in milliseconds before the sidebar expands after hovering. Default is 200ms.",
  "Expand/collapse animation speed": "Expand/collapse animation speed",
  "The speed of the sidebar expand/collapse animation in milliseconds.": "The speed of the sidebar expand/collapse animation in milliseconds.",
  "Appearance": "Appearance",
  "Left sidebar maximum width": "Left sidebar maximum width",
  "Specify the maximum width in pixels for the left sidebar when expanded": "Specify the maximum width in pixels for the left sidebar when expanded",
  "Right sidebar maximum width": "Right sidebar maximum width",
  "Specify the maximum width in pixels for the right sidebar when expanded": "Specify the maximum width in pixels for the right sidebar when expanded",
  "Ribbon Buttons": "Ribbon Buttons",
  "Startup Display Delay": "Startup Display Delay",
  "Delay in milliseconds before showing ribbon icons on startup. If 'My Plugins' is enabled, this acts as a buffer time added to the max plugin load delay.": "Delay in milliseconds before showing ribbon icons on startup. If 'My Plugins' is enabled, this acts as a buffer time added to the max plugin load delay.",
  "Sidebar Tabs": "Sidebar Tabs",
  "Manage placement of sidebar tabs (like File Explorer, Search).": "Manage placement of sidebar tabs (like File Explorer, Search).",
  "Scan Current Layout": "Scan Current Layout",
  "Scan and apply": "Scan and save current sidebar layout",
  "Hidden": "Hidden",
  "Default": "Default",
  "Move to Left Sidebar": "Move to Left Sidebar",
  "Move to Right Sidebar": "Move to Right Sidebar",
  "Hide Tab": "Hide Tab",
  "Show Tab": "Show Tab",
  "Unknown Tab": "Unknown Tab",
  // Contextual Groups
  "Contextual Groups": "Contextual Groups",
  "Contextual Groups Description": "Bind a secondary view (Slave) to a primary view (Master). When you active Master, Slave appears split at bottom. The Master tab will show a composite identity.",
  "Add New Group": "Add New Group",
  "Master View ID": "Master View ID (e.g. file-explorer)",
  "Slave View ID": "Slave View ID (e.g. outline)",
  "Group Name": "Group Name (Optional)",
  "Group Icon": "Group Icon (Lucide name)",
  "Add Binding": "Add Binding",
  "Delete": "Delete",
  "Error: Same Side": "Error: Master and Slave must be on the same sidebar.",
  "Error: Invalid ID": "Error: Invalid View ID or View not found in settings.",
  "Binding Removed": "Binding removed because one of the views changed sides.",
  // Group Modal & New UI
  "Create a new contextual group binding": "Create a new contextual group binding",
  "The view ID of the main tab (will be replaced by the group tab)": "The view ID of the main tab (will be replaced by the group tab)",
  "The view ID of the split tab (hidden until group is active)": "The view ID of the split tab (hidden until group is active)",
  "Name to display on the tab": "Name to display on the tab",
  "SVG Code or Lucide Icon Name": "SVG Code or Lucide Icon Name",
  "Add Group": "Add Group",
  "Unbind": "Unbind",
  "Error: Master ID already bound": "Error: This Master View ID is already bound in another group."
};

// src/i18n/locales/zh.ts
var zh_default = {
  // General
  "Module is disabled.": "\u6A21\u5757\u5DF2\u7981\u7528\u3002",
  "Obsidian Assistant Settings": "Obsidian Assistant \u8BBE\u7F6E",
  "Global Settings": "\u5168\u5C40\u8BBE\u7F6E",
  "Auto-Numbering Refresh Interval": "\u81EA\u52A8\u7F16\u53F7\u5237\u65B0\u95F4\u9694",
  "Time in milliseconds to wait before auto-numbering triggers (after losing focus)": "\u5931\u7126\u540E\u89E6\u53D1\u81EA\u52A8\u7F16\u53F7\u524D\u7684\u7B49\u5F85\u65F6\u95F4\uFF08\u6BEB\u79D2\uFF09",
  "Modules": "\u6A21\u5757",
  // My Folders
  "My Folders": "\u6211\u7684\u6587\u4EF6\u5939",
  "Toggle visibility of hidden folders": "\u5207\u6362\u9690\u85CF\u6587\u4EF6\u5939\u7684\u53EF\u89C1\u6027",
  "Show hidden folders": "\u663E\u793A\u9690\u85CF\u6587\u4EF6\u5939",
  "Hide hidden folders again": "\u518D\u6B21\u9690\u85CF\u6587\u4EF6\u5939",
  "Configured folders are hidden": "\u5DF2\u914D\u7F6E\u7684\u6587\u4EF6\u5939\u5DF2\u9690\u85CF",
  "Attachment Folder Names": "\u9644\u4EF6\u6587\u4EF6\u5939\u540D\u79F0",
  "Enter folder names to hide, one per line. Use 'endswith::' or 'startswith::' for prefix/suffix matching.": "\u8F93\u5165\u8981\u9690\u85CF\u7684\u6587\u4EF6\u5939\u540D\u79F0\uFF0C\u6BCF\u884C\u4E00\u4E2A\u3002\u4F7F\u7528 'endswith::' \u6216 'startswith::' \u8FDB\u884C\u524D\u540E\u7F00\u5339\u914D\u3002",
  "Match path case-insensitive": "\u8DEF\u5F84\u5339\u914D\u4E0D\u533A\u5206\u5927\u5C0F\u5199",
  "Hide configured folders": "\u9690\u85CF\u914D\u7F6E\u7684\u6587\u4EF6\u5939",
  "Add hidden folders to Obsidian ignore list": "\u5C06\u9690\u85CF\u6587\u4EF6\u5939\u6DFB\u52A0\u5230 Obsidian \u5FFD\u7565\u5217\u8868",
  "Hide bottom status bar indicator text": "\u9690\u85CF\u5E95\u90E8\u72B6\u6001\u680F\u6307\u793A\u6587\u5B57",
  "Experimental & Unstable Settings": "\u5B9E\u9A8C\u6027 & \u4E0D\u7A33\u5B9A\u8BBE\u7F6E",
  "Enable compatibility with Quick Explorer": "\u542F\u7528\u4E0E Quick Explorer \u7684\u517C\u5BB9\u6027",
  "Folders to hide": "\u8981\u9690\u85CF\u7684\u6587\u4EF6\u5939",
  "The names of the folders to hide, one per line. Either exact folder-names, startsWith::FOLDERPREFIX, or endsWith::FOLDERSUFFIX": "\u8981\u9690\u85CF\u7684\u6587\u4EF6\u5939\u540D\u79F0\uFF0C\u6BCF\u884C\u4E00\u4E2A\u3002\u53EF\u4EE5\u662F\u7CBE\u786E\u7684\u6587\u4EF6\u5939\u540D\u79F0\uFF0C\u6216\u8005\u4F7F\u7528 startsWith::FOLDERPREFIX\u3001endsWith::FOLDERSUFFIX \u8FDB\u884C\u5339\u914D\u3002",
  "attachments\\nendsWith::_attachments": "attachments\\nendsWith::_attachments",
  "Ignore Upper/lowercase": "\u5FFD\u7565\u5927\u5C0F\u5199",
  "If enabled, 'SOMEFOLDER', 'someFolder', or 'sOmeFoldEr' will all be treated the same and matched.": "\u542F\u7528\u540E\uFF0C'SOMEFOLDER'\u3001'someFolder' \u6216 'sOmeFoldEr' \u90FD\u5C06\u88AB\u89C6\u4E3A\u76F8\u540C\u5E76\u5339\u914D\u3002",
  "Hide folders": "\u9690\u85CF\u6587\u4EF6\u5939",
  "If the configured folders should be hidden or not": "\u662F\u5426\u9690\u85CF\u5DF2\u914D\u7F6E\u7684\u6587\u4EF6\u5939",
  "Add Hidden Folders to Obsidian Exclusion-List": "\u5C06\u9690\u85CF\u6587\u4EF6\u5939\u6DFB\u52A0\u5230 Obsidian \u6392\u9664\u5217\u8868",
  "Excluded files will be hidden in Search, Graph View, and Unlinked Mentions, less noticeable in Quick Switcher and link suggestions.": "\u6392\u9664\u7684\u6587\u4EF6\u5C06\u5728\u641C\u7D22\u3001\u5173\u7CFB\u56FE\u8C31\u548C\u53CD\u5411\u94FE\u63A5\u4E2D\u9690\u85CF\uFF0C\u5E76\u4E14\u5728\u5FEB\u901F\u5207\u6362\u548C\u94FE\u63A5\u5EFA\u8BAE\u4E2D\u4E0D\u90A3\u4E48\u663E\u773C\u3002",
  'Hide bottom status-bar "Folders are Hidden" indicator': '\u9690\u85CF\u5E95\u90E8\u72B6\u6001\u680F "\u6587\u4EF6\u5939\u5DF2\u9690\u85CF" \u6307\u793A\u5668',
  "If enable there will be no bottom-bar indicator-text telling you if this plugin is active.": "\u542F\u7528\u540E\uFF0C\u5E95\u90E8\u72B6\u6001\u680F\u5C06\u4E0D\u518D\u663E\u793A\u6B64\u63D2\u4EF6\u662F\u5426\u6D3B\u8DC3\u7684\u6307\u793A\u6587\u672C\u3002",
  "[EXPERIMENTAL] Compatibility: quick-explorer by pjeby": "[\u5B9E\u9A8C\u6027] \u517C\u5BB9\u6027\uFF1Apjeby \u5F00\u53D1\u7684 quick-explorer",
  "[WARNING: UNSTABLE] Also hide hidden folders in the https://github.com/pjeby/quick-explorer plugin. Not affiliated with quick-explorer's author.": "[\u8B66\u544A\uFF1A\u4E0D\u7A33\u5B9A] \u540C\u65F6\u9690\u85CF https://github.com/pjeby/quick-explorer \u63D2\u4EF6\u4E2D\u7684\u9690\u85CF\u6587\u4EF6\u5939\u3002\u4E0E quick-explorer \u7684\u4F5C\u8005\u65E0\u5173\u3002",
  // My Plugins
  "My Plugins": "\u6211\u7684\u63D2\u4EF6",
  "Loading Obsidian Assistant...": "\u6B63\u5728\u52A0\u8F7D Obsidian Assistant...",
  "Loading Settings...": "\u6B63\u5728\u52A0\u8F7D\u8BBE\u7F6E...",
  "Unloading Obsidian Assistant...": "\u6B63\u5728\u5378\u8F7D Obsidian Assistant...",
  "Starting {id} after a {type} delay": "\u5EF6\u8FDF {type} \u540E\u542F\u52A8 {id}",
  "Failed to load plugin {id} after delay:": "\u5EF6\u8FDF\u540E\u52A0\u8F7D\u63D2\u4EF6 {id} \u5931\u8D25\uFF1A",
  "Dual Configurations": "\u53CC\u91CD\u914D\u7F6E",
  "Separated configuration for desktop and mobile.": "\u4E3A\u684C\u9762\u7AEF\u548C\u79FB\u52A8\u7AEF\u4F7F\u7528\u72EC\u7ACB\u7684\u914D\u7F6E\u3002",
  "Show Console Log": "\u663E\u793A\u63A7\u5236\u53F0\u65E5\u5FD7",
  "Show log in console when a plugin is loaded.": "\u63D2\u4EF6\u52A0\u8F7D\u65F6\u5728\u63A7\u5236\u53F0\u663E\u793A\u65E5\u5FD7\u3002",
  "Short Delay Duration (s)": "\u77ED\u5EF6\u8FDF\u65F6\u95F4 (\u79D2)",
  "Long Delay Duration (s)": "\u957F\u5EF6\u8FDF\u65F6\u95F4 (\u79D2)",
  "Default Startup Type": "\u9ED8\u8BA4\u542F\u52A8\u7C7B\u578B",
  "Startup type used when a plugin is not configured.": "\u5F53\u63D2\u4EF6\u672A\u914D\u7F6E\u65F6\u4F7F\u7528\u7684\u542F\u52A8\u7C7B\u578B\u3002",
  "Show Descriptions": "\u663E\u793A\u8BF4\u660E",
  "Show plugin descriptions in the list.": "\u5728\u5217\u8868\u4E2D\u663E\u793A\u63D2\u4EF6\u8BF4\u660E\u3002",
  "Set the delay for all plugins at once": "\u4E00\u6B21\u6027\u8BBE\u7F6E\u6240\u6709\u63D2\u4EF6\u7684\u5EF6\u8FDF",
  "Select a startup type to apply to all plugins.": "\u9009\u62E9\u4E00\u4E2A\u542F\u52A8\u7C7B\u578B\u5E76\u5E94\u7528\u5230\u6240\u6709\u63D2\u4EF6\u3002",
  "Search plugins...": "\u641C\u7D22\u63D2\u4EF6...",
  "All": "\u5168\u90E8",
  "Instant": "\u5373\u65F6",
  "Short": "\u77ED\u5EF6\u8FDF",
  "Long": "\u957F\u5EF6\u8FDF",
  "Disabled": "\u5DF2\u7981\u7528",
  "Separate desktop/mobile configuration": "\u5206\u79BB\u684C\u9762\u7AEF/\u79FB\u52A8\u7AEF\u914D\u7F6E",
  "Enable this if you want to have different settings depending whether you're using a desktop or mobile device. All of the settings below can be configured differently on desktop and mobile. You're currently using the {device} settings.": "\u5982\u679C\u5E0C\u671B\u6839\u636E\u60A8\u4F7F\u7528\u7684\u8BBE\u5907\uFF08\u684C\u9762\u6216\u79FB\u52A8\u7AEF\uFF09\u4F7F\u7528\u4E0D\u540C\u7684\u8BBE\u7F6E\uFF0C\u8BF7\u542F\u7528\u6B64\u9879\u3002\u4EE5\u4E0B\u6240\u6709\u8BBE\u7F6E\u90FD\u53EF\u4EE5\u5728\u684C\u9762\u548C\u79FB\u52A8\u7AEF\u72EC\u7ACB\u914D\u7F6E\u3002\u60A8\u5F53\u524D\u6B63\u5728\u4F7F\u7528 {device} \u8BBE\u7F6E\u3002",
  "Short delay (seconds)": "\u77ED\u5EF6\u8FDF (\u79D2)",
  "Long delay (seconds)": "\u957F\u5EF6\u8FDF (\u79D2)",
  "Default startup type for new plugins": "\u65B0\u63D2\u4EF6\u7684\u9ED8\u8BA4\u542F\u52A8\u7C7B\u578B",
  "Nothing configured": "\u672A\u914D\u7F6E\u5185\u5BB9",
  "Show plugin descriptions": "\u663E\u793A\u63D2\u4EF6\u8BF4\u660E",
  "Set all plugins to be:": "\u5C06\u6240\u6709\u63D2\u4EF6\u8BBE\u7F6E\u4E3A\uFF1A",
  "Plugins": "\u63D2\u4EF6",
  "Filter by: ": "\u8FC7\u6EE4\u65B9\u5F0F\uFF1A",
  "Type to filter list": "\u8F93\u5165\u4EE5\u8FC7\u6EE4\u5217\u8868",
  "\u26D4 Disable plugin": "\u26D4 \u7981\u7528\u63D2\u4EF6",
  "\u26A1 Instant": "\u26A1 \u5373\u65F6",
  "\u231A Short delay": "\u231A \u77ED\u5EF6\u8FDF",
  "\u{1F4A4} Long delay": "\u{1F4A4} \u957F\u5EF6\u8FDF",
  "{id} after a {type} delay": "\u5EF6\u8FDF {type} \u540E\u542F\u52A8 {id}",
  "My Status Bar": "\u6211\u7684\u72B6\u6001\u680F",
  "Drag to reorder": "\u62D6\u62FD\u5E76\u6392\u5E8F",
  "Visibility": "\u53EF\u89C1\u6027",
  "Remove orphan": "\u79FB\u9664\u6B8B\u7559\u9879",
  "This element is currently not present in the status bar.": "\u8BE5\u5143\u7D20\u5F53\u524D\u4E0D\u5728\u72B6\u6001\u680F\u4E2D\u3002",
  "Drag to reorder ribbon icons. Click eye icon to toggle visibility.": "\u62D6\u52A8\u4EE5\u91CD\u65B0\u6392\u5E8F\u529F\u80FD\u533A\u56FE\u6807\u3002\u70B9\u51FB\u773C\u775B\u56FE\u6807\u4EE5\u5207\u6362\u53EF\u89C1\u6027\u3002",
  "No ribbon elements found yet.": "\u5C1A\u672A\u53D1\u73B0\u529F\u80FD\u533A\u5143\u7D20\u3002",
  // My Snippets
  "My Snippets": "\u6211\u7684\u7247\u6BB5",
  "Open snippets in status bar": "\u5728\u72B6\u6001\u680F\u6253\u5F00\u4EE3\u7801\u7247\u6BB5",
  "Create new CSS snippet": "\u521B\u5EFA\u65B0\u7684 CSS \u4EE3\u7801\u7247\u6BB5",
  "Configure Snippets": "\u914D\u7F6E\u4EE3\u7801\u7247\u6BB5",
  "Glass Style": "\u6BDB\u73BB\u7483\u6837\u5F0F",
  "Turn on frosted glass for the status bar menu.": "\u4E3A\u72B6\u6001\u680F\u83DC\u5355\u5F00\u542F\u6BDB\u73BB\u7483\u6548\u679C\u3002",
  "Open Script after Creation": "\u521B\u5EFA\u540E\u6253\u5F00\u811A\u672C",
  "Open the CSS file automatically after creating a new snippet.": "\u521B\u5EFA\u65B0\u7247\u6BB5\u540E\u81EA\u52A8\u6253\u5F00 CSS \u6587\u4EF6\u3002",
  "Enable/Disable after Creation": "\u521B\u5EFA\u540E\u542F\u7528/\u7981\u7528",
  "Set the snippet to enabled or disabled by default after creation.": "\u8BBE\u7F6E\u7247\u6BB5\u521B\u5EFA\u540E\u9ED8\u8BA4\u542F\u7528\u6216\u7981\u7528\u3002",
  "Script Template": "\u811A\u672C\u6A21\u677F",
  "Template for new CSS snippets.": "\u65B0 CSS \u7247\u6BB5\u7684\u6A21\u677F\u3002",
  "Show Status Bar Icon": "\u663E\u793A\u72B6\u6001\u680F\u56FE\u6807",
  "Toggle the visibility of the snippets icon in the status bar.": "\u5207\u6362\u72B6\u6001\u680F\u7247\u6BB5\u56FE\u6807\u7684\u53EF\u89C1\u6027\u3002",
  "Manage Snippets": "\u7BA1\u7406\u4EE3\u7801\u7247\u6BB5",
  "Reload Snippets": "\u91CD\u8F7D\u4EE3\u7801\u7247\u6BB5",
  "Click to refresh the list of snippets.": "\u70B9\u51FB\u5237\u65B0\u4EE3\u7801\u7247\u6BB5\u5217\u8868\u3002",
  "Glass menu effect": "\u6BDB\u73BB\u7483\u83DC\u5355\u6548\u679C",
  "Choose to change the background from the secondary background color of your theme to a glass background.": "\u9009\u62E9\u5C06\u80CC\u666F\u4ECE\u4E3B\u9898\u7684\u6B21\u8981\u80CC\u666F\u989C\u8272\u66F4\u6539\u4E3A\u6BDB\u73BB\u7483\u80CC\u666F\u3002",
  "Auto open new snippet": "\u81EA\u52A8\u6253\u5F00\u65B0\u7247\u6BB5",
  "Choose whether or not to open CSS snippet files immeditaley after creating them. It will open in your default app.": "\u9009\u62E9\u5728\u521B\u5EFA CSS \u7247\u6BB5\u6587\u4EF6\u540E\u662F\u5426\u7ACB\u5373\u6253\u5F00\u5B83\u4EEC\u3002\u5B83\u5C06\u5728\u60A8\u7684\u9ED8\u8BA4\u5E94\u7528\u7A0B\u5E8F\u4E2D\u6253\u5F00\u3002",
  "Set new snippet status": "\u8BBE\u7F6E\u65B0\u7247\u6BB5\u72B6\u6001",
  "Choose whether or not to have newly created CSS snippet files toggled on automatically upon creation.": "\u9009\u62E9\u5728\u521B\u5EFA\u65F6\u662F\u5426\u81EA\u52A8\u542F\u7528\u65B0\u521B\u5EFA\u7684 CSS \u7247\u6BB5\u6587\u4EF6\u3002",
  "CSS snippet template": "CSS \u7247\u6BB5\u6A21\u677F",
  "Set default CSS styling as a template for new CSS files you choose to create.": "\u8BBE\u7F6E\u9ED8\u8BA4 CSS \u6837\u5F0F\u4F5C\u4E3A\u60A8\u9009\u62E9\u521B\u5EFA\u7684\u65B0 CSS \u6587\u4EF6\u7684\u6A21\u677F\u3002",
  "If you like this Plugin and are considering donating to support continued development, use the buttons below!": "\u5982\u679C\u60A8\u559C\u6B22\u8FD9\u4E2A\u63D2\u4EF6\u5E76\u8003\u8651\u6350\u8D60\u4EE5\u652F\u6301\u6301\u7EED\u5F00\u53D1\uFF0C\u8BF7\u4F7F\u7528\u4E0B\u9762\u7684\u6309\u94AE\uFF01",
  "No CSS snippets found.": "\u672A\u627E\u5230 CSS \u7247\u6BB5\u3002",
  "Buy me a coffee": "\u8BF7\u6211\u559D\u676F\u5496\u5561",
  "Created by ": "\u5F00\u53D1\u8005\uFF1A",
  "Open snippet": "\u6253\u5F00\u4EE3\u7801\u7247\u6BB5",
  "Actions": "\u64CD\u4F5C",
  "Reload snippets": "\u91CD\u8F7D\u4EE3\u7801\u7247\u6BB5",
  "Snippets reloaded": "\u4EE3\u7801\u7247\u6BB5\u5DF2\u91CD\u8F7D",
  "Open snippets folder": "\u6253\u5F00\u4EE3\u7801\u7247\u6BB5\u6587\u4EF6\u5939",
  "Create a CSS Snippet": "\u521B\u5EFA CSS \u4EE3\u7801\u7247\u6BB5",
  "CSS Snippet Title": "CSS \u4EE3\u7801\u7247\u6BB5\u6807\u9898",
  "Write the title for this CSS snippet file.": "\u4E3A\u8BE5 CSS \u7247\u6BB5\u6587\u4EF6\u7F16\u5199\u6807\u9898\u3002",
  "CSS Snippet Styles": "CSS \u4EE3\u7801\u7247\u6BB5\u6837\u5F0F",
  "Add in styling for this CSS snippet file.": "\u4E3A\u8BE5 CSS \u7247\u6BB5\u6587\u4EF6\u6DFB\u52A0\u6837\u5F0F\u3002",
  '"{fileName}.css" has been created!': '"{fileName}.css" \u5DF2\u521B\u5EFA\uFF01',
  '"{fileName}.css" already exists.': '"{fileName}.css" \u5DF2\u5B58\u5728\u3002',
  "Missing name for file": "\u6587\u4EF6\u540D\u7F3A\u5931",
  "Create Snippet": "\u521B\u5EFA\u7247\u6BB5",
  // MyHeadings
  "My Headings": "\u6211\u7684\u6807\u9898",
  "Number Headings": "\u6807\u9898\u7F16\u53F7",
  "Remove Heading Numbering": "\u79FB\u9664\u6807\u9898\u7F16\u53F7",
  "Auto Number Headings": "\u81EA\u52A8\u6807\u9898\u7F16\u53F7",
  "Create numbers automatically on blur": "\u81EA\u52A8\u521B\u5EFA\u7F16\u53F7\uFF08\u5728\u5931\u53BB\u7126\u70B9\u65F6\u89E6\u53D1\uFF09",
  "First Level": "\u8D77\u59CB\u7EA7\u522B",
  "Max Level": "\u6700\u5927\u7EA7\u522B",
  "Heading Styles": "\u6807\u9898\u6837\u5F0F",
  "Level": "\u7EA7\u522B",
  "Style": "\u6837\u5F0F",
  "Separator": "\u5206\u9694\u7B26",
  "Start At": "\u8D77\u59CB\u503C",
  // MyFormulas
  "My Formulas": "\u6211\u7684\u516C\u5F0F",
  "Number Formulas": "\u516C\u5F0F\u7F16\u53F7",
  "Remove Formula Numbering": "\u79FB\u9664\u516C\u5F0F\u7F16\u53F7",
  "Auto Number Formulas": "\u81EA\u52A8\u516C\u5F0F\u7F16\u53F7",
  "Automatically number formulas (triggers on blur if enabled)": "\u81EA\u52A8\u516C\u5F0F\u7F16\u53F7\uFF08\u542F\u7528\u65F6\u5728\u5931\u53BB\u7126\u70B9\u65F6\u89E6\u53D1\uFF09",
  "Numbering Mode": "\u7F16\u53F7\u6A21\u5F0F",
  "Continuous (1, 2, 3) or Heading-based (1.1-1, 1.1-2)": "\u8FDE\u7EED (1, 2, 3) \u6216 \u57FA\u4E8E\u6807\u9898 (1.1-1, 1.1-2)",
  "Continuous": "\u8FDE\u7EED",
  "Heading-based": "\u57FA\u4E8E\u6807\u9898",
  "Max Heading Depth": "\u6700\u5927\u6807\u9898\u6DF1\u5EA6",
  "For Heading-based mode: max depth of heading to use as prefix (e.g. 4 means use H4 at most)": "\u57FA\u4E8E\u6807\u9898\u6A21\u5F0F\uFF1A\u7528\u4F5C\u524D\u7F00\u7684\u6700\u5927\u6807\u9898\u6DF1\u5EA6\uFF08\u4F8B\u5982 4 \u8868\u793A\u6700\u591A\u4F7F\u7528 H4\uFF09",
  // Heading Shifter
  "Auto Numbering": "\u81EA\u52A8\u7F16\u53F7",
  "Heading Shifter": "\u6807\u9898\u79FB\u52A8 (Heading Shifter)",
  "Lower limit of Heading": "\u6807\u9898\u7EA7\u522B\u4E0B\u9650",
  "The lower Heading Size that will be decreased by the Heading Shift": "\u6807\u9898\u79FB\u52A8\u529F\u80FD\u53EF\u4EE5\u964D\u4F4E\u7684\u6700\u5C0F\u6807\u9898\u7EA7\u522B",
  "Enable override tab behavior": "\u542F\u7528\u8986\u76D6 Tab \u952E\u884C\u4E3A",
  'Tab execute "Increase Headings" and Shift-Tab execute "Decrease Headings"': "Tab \u952E\u6267\u884C\u201C\u589E\u52A0\u6807\u9898\u7EA7\u522B\u201D\uFF0CShift-Tab \u6267\u884C\u201C\u51CF\u5C11\u6807\u9898\u7EA7\u522B\u201D",
  "Style to remove": "\u8981\u79FB\u9664\u7684\u6837\u5F0F",
  "If this style is at the position of a line, remove it": "\u5982\u679C\u884C\u4E2D\u6307\u5B9A\u4F4D\u7F6E\u5B58\u5728\u6B64\u6837\u5F0F\uFF0C\u5219\u79FB\u9664\u5B83",
  "Beginning": "\u5F00\u5934",
  "Unordered list": "\u65E0\u5E8F\u5217\u8868",
  "Ordered list": "\u6709\u5E8F\u5217\u8868",
  "User defined": "\u7528\u6237\u81EA\u5B9A\u4E49",
  "Arbitrary string (regular expression)": "\u4EFB\u610F\u5B57\u7B26\u4E32 (\u6B63\u5219\u8868\u8FBE\u5F0F)",
  "Surrounding": "\u5305\u56F4",
  "Bold": "\u7C97\u4F53",
  "Italic": "\u659C\u4F53",
  "Children behavior": "\u5B50\u5143\u7D20\u884C\u4E3A",
  "Outdent to 0": "\u7F29\u8FDB\u81F3 0",
  "Sync with headings": "\u4E0E\u6807\u9898\u540C\u6B65",
  "Noting": "\u65E0\u64CD\u4F5C",
  "Tab size": "\u5236\u8868\u7B26\u5BBD\u5EA6 (Tab Size)",
  // Shifter Commands
  "Increase Headings": "\u589E\u52A0\u6807\u9898\u7EA7\u522B",
  "Increase Headings (forced)": "\u589E\u52A0\u6807\u9898\u7EA7\u522B (\u5F3A\u5236)",
  "Decrease Headings": "\u51CF\u5C11\u6807\u9898\u7EA7\u522B",
  "Apply Heading": "\u5E94\u7528\u6807\u9898\u7EA7\u522B",
  "Insert Heading at current level": "\u5728\u5F53\u524D\u7EA7\u522B\u63D2\u5165\u6807\u9898",
  "Insert Heading at one level deeper": "\u5728\u66F4\u6DF1\u4E00\u7EA7\u63D2\u5165\u6807\u9898",
  "Insert Heading at one level higher": "\u5728\u66F4\u6D45\u4E00\u7EA7\u63D2\u5165\u6807\u9898",
  // Commands & Modals
  "Configure Headings": "\u914D\u7F6E\u6807\u9898",
  "Configure Formulas": "\u914D\u7F6E\u516C\u5F0F",
  "Apply Now": "\u7ACB\u5373\u5E94\u7528",
  "Apply numbering once without saving to frontmatter": "\u4E00\u6B21\u6027\u5E94\u7528\u7F16\u53F7\uFF0C\u4E0D\u4FDD\u5B58\u5230frontmatter",
  "Save to Frontmatter": "\u4FDD\u5B58\u5230 Frontmatter",
  "Save settings to frontmatter and apply": "\u4FDD\u5B58\u8BBE\u7F6E\u5230frontmatter\u5E76\u5E94\u7528",
  "Remove Numbering": "\u79FB\u9664\u7F16\u53F7",
  "Numbering applied (one-time)": "\u7F16\u53F7\u5DF2\u5E94\u7528\uFF08\u4E00\u6B21\u6027\uFF09",
  "Formula numbering applied (one-time)": "\u516C\u5F0F\u7F16\u53F7\u5DF2\u5E94\u7528\uFF08\u4E00\u6B21\u6027\uFF09",
  "Settings saved to frontmatter and applied": "\u8BBE\u7F6E\u5DF2\u4FDD\u5B58\u5230frontmatter\u5E76\u5E94\u7528",
  "Heading numbering removed": "\u6807\u9898\u7F16\u53F7\u5DF2\u79FB\u9664",
  "Formula numbering removed": "\u516C\u5F0F\u7F16\u53F7\u5DF2\u79FB\u9664",
  // MySideBar
  "My SideBar": "\u6211\u7684\u4FA7\u8FB9\u680F",
  "Left Sidebar": "\u5DE6\u4FA7\u8FB9\u680F",
  "Right Sidebar": "\u53F3\u4FA7\u8FB9\u680F",
  "Auto Hide": "\u81EA\u52A8\u9690\u85CF",
  "Coming Soon": "\u656C\u8BF7\u671F\u5F85",
  "Settings for Left Sidebar control will be here.": "\u5DE6\u4FA7\u8FB9\u680F\u7684\u76F8\u5173\u8BBE\u7F6E\u5C06\u5728\u6B64\u5904\u663E\u793A\u3002",
  "Settings for Right Sidebar control will be here.": "\u53F3\u4FA7\u8FB9\u680F\u7684\u76F8\u5173\u8BBE\u7F6E\u5C06\u5728\u6B64\u5904\u663E\u793A\u3002",
  "Left sidebar hover": "\u5DE6\u4FA7\u8FB9\u680F\u60AC\u505C",
  "Enables the expansion and collapsing of the left sidebar on hover.": "\u5F00\u542F\u60AC\u505C\u65F6\u81EA\u52A8\u5C55\u5F00/\u6298\u53E0\u5DE6\u4FA7\u8FB9\u680F\u3002",
  "Right sidebar hover": "\u53F3\u4FA7\u8FB9\u680F\u60AC\u505C",
  "Enables the expansion and collapsing of the right sidebar on hover. Only collapses the right panel unless you have a right ribbon.": "\u5F00\u542F\u60AC\u505C\u65F6\u81EA\u52A8\u5C55\u5F00/\u6298\u53E0\u53F3\u4FA7\u8FB9\u680F\u3002\u4EC5\u5728\u5177\u5907\u53F3\u4FA7 Ribbbon \u65F6\u6298\u53E0\u53F3\u4FA7\u9762\u677F\u3002",
  "Sync left and right": "\u5DE6\u53F3\u540C\u6B65",
  "If enabled, hovering over the right sidebar will also expand the left sidebar at the same time, and vice versa. (Left and Right sidebar must both be enabled above)": "\u5982\u679C\u542F\u7528\uFF0C\u60AC\u505C\u53F3\u4FA7\u8FB9\u680F\u4E5F\u4F1A\u540C\u65F6\u5C55\u5F00\u5DE6\u4FA7\u8FB9\u680F\uFF0C\u53CD\u4E4B\u4EA6\u7136\u3002\uFF08\u9700\u540C\u65F6\u542F\u7528\u5DE6\u53F3\u4FA7\u8FB9\u680F\u60AC\u505C\uFF09",
  "Overlay mode": "\u8986\u76D6\u6A21\u5F0F",
  "When enabled, sidebars will slide over the main content without affecting the layout. When disabled, sidebars will expand by pushing content.": "\u542F\u7528\u65F6\uFF0C\u4FA7\u8FB9\u680F\u5C06\u8986\u76D6\u5728\u4E3B\u5185\u5BB9\u4E4B\u4E0A\u800C\u4E0D\u5F71\u54CD\u5E03\u5C40\u3002\u7981\u7528\u65F6\uFF0C\u4FA7\u8FB9\u680F\u5C55\u5F00\u4F1A\u6324\u538B\u5185\u5BB9\u3002",
  "Behavior": "\u884C\u4E3A",
  "Left sidebar pixel trigger": "\u5DE6\u4FA7\u89E6\u53D1\u50CF\u7D20",
  "Specify the number of pixels from the left edge of the editor that will trigger the left sidebar to open on hover (must be greater than 0)": "\u6307\u5B9A\u8DDD\u79BB\u7F16\u8F91\u5668\u5DE6\u8FB9\u7F18\u591A\u5C11\u50CF\u7D20\u65F6\u89E6\u53D1\u5DE6\u4FA7\u8FB9\u680F\u5C55\u5F00\uFF08\u5FC5\u987B\u5927\u4E8E0\uFF09",
  "Right sidebar pixel trigger": "\u53F3\u4FA7\u89E6\u53D1\u50CF\u7D20",
  "Specify the number of pixels from the right edge of the editor that will trigger the right sidebar to open on hover (must be greater than 0)": "\u6307\u5B9A\u8DDD\u79BB\u7F16\u8F91\u5668\u53F3\u8FB9\u7F18\u591A\u5C11\u50CF\u7D20\u65F6\u89E6\u53D1\u53F3\u4FA7\u8FB9\u680F\u5C55\u5F00\uFF08\u5FC5\u987B\u5927\u4E8E0\uFF09",
  "Timing": "\u65F6\u673A",
  "Sidebar collapse delay": "\u4FA7\u8FB9\u680F\u6298\u53E0\u5EF6\u8FDF",
  "The delay in milliseconds before the sidebar collapses after the mouse has left. Enter '0' to disable delay.": "\u9F20\u6807\u79BB\u5F00\u540E\u4FA7\u8FB9\u680F\u6298\u53E0\u524D\u7684\u5EF6\u8FDF\uFF08\u6BEB\u79D2\uFF09\u3002\u8F93\u5165 '0' \u7981\u7528\u5EF6\u8FDF\u3002",
  "Sidebar expand delay": "\u4FA7\u8FB9\u680F\u5C55\u5F00\u5EF6\u8FDF",
  "The delay in milliseconds before the sidebar expands after hovering. Default is 200ms.": "\u60AC\u505C\u540E\u4FA7\u8FB9\u680F\u5C55\u5F00\u524D\u7684\u5EF6\u8FDF\uFF08\u6BEB\u79D2\uFF09\u3002\u9ED8\u8BA4\u4E3A 200ms\u3002",
  "Expand/collapse animation speed": "\u5C55\u5F00/\u6298\u53E0\u52A8\u753B\u901F\u5EA6",
  "The speed of the sidebar expand/collapse animation in milliseconds.": "\u4FA7\u8FB9\u680F\u5C55\u5F00/\u6298\u53E0\u52A8\u753B\u7684\u901F\u5EA6\uFF08\u6BEB\u79D2\uFF09\u3002",
  "Appearance": "\u5916\u89C2",
  "Left sidebar maximum width": "\u5DE6\u4FA7\u8FB9\u680F\u6700\u5927\u5BBD\u5EA6",
  "Specify the maximum width in pixels for the left sidebar when expanded": "\u6307\u5B9A\u5DE6\u4FA7\u8FB9\u680F\u5C55\u5F00\u65F6\u7684\u6700\u5927\u5BBD\u5EA6\uFF08\u50CF\u7D20\uFF09",
  "Right sidebar maximum width": "\u53F3\u4FA7\u8FB9\u680F\u6700\u5927\u5BBD\u5EA6",
  "Specify the maximum width in pixels for the right sidebar when expanded": "\u6307\u5B9A\u53F3\u4FA7\u8FB9\u680F\u5C55\u5F00\u65F6\u7684\u6700\u5927\u5BBD\u5EA6\uFF08\u50CF\u7D20\uFF09",
  "Ribbon Buttons": "\u529F\u80FD\u533A\u6309\u94AE",
  "Startup Display Delay": "\u542F\u52A8\u663E\u793A\u5EF6\u8FDF",
  "Delay in milliseconds before showing ribbon icons on startup. If 'My Plugins' is enabled, this acts as a buffer time added to the max plugin load delay.": "\u542F\u52A8\u65F6\u663E\u793A\u529F\u80FD\u533A\u56FE\u6807\u524D\u7684\u5EF6\u8FDF\uFF08\u6BEB\u79D2\uFF09\u3002\u5982\u679C\u542F\u7528\u4E86 '\u6211\u7684\u63D2\u4EF6'\uFF0C\u6B64\u65F6\u95F4\u5C06\u4F5C\u4E3A\u7F13\u51B2\u65F6\u95F4\u6DFB\u52A0\u5230\u6700\u5927\u63D2\u4EF6\u52A0\u8F7D\u5EF6\u8FDF\u4E4B\u540E\u3002",
  "Sidebar Tabs": "\u4FA7\u8FB9\u680F\u6807\u7B7E\u9875",
  "Manage placement of sidebar tabs (like File Explorer, Search).": "\u7BA1\u7406\u4FA7\u8FB9\u680F\u6807\u7B7E\u9875\uFF08\u5982\u6587\u4EF6\u8D44\u6E90\u7BA1\u7406\u5668\u3001\u641C\u7D22\uFF09\u7684\u653E\u7F6E\u4F4D\u7F6E\u3002",
  "Scan Current Layout": "\u626B\u63CF\u5F53\u524D\u5E03\u5C40",
  "Scan and apply": "\u626B\u63CF\u5E76\u4FDD\u5B58\u5F53\u524D\u4FA7\u8FB9\u680F\u5E03\u5C40",
  "Hidden": "\u9690\u85CF",
  "Default": "\u9ED8\u8BA4",
  "Move to Left Sidebar": "\u79FB\u52A8\u5230\u5DE6\u4FA7\u8FB9\u680F",
  "Move to Right Sidebar": "\u79FB\u52A8\u5230\u53F3\u4FA7\u8FB9\u680F",
  "Hide Tab": "\u9690\u85CF\u6807\u7B7E\u9875",
  "Show Tab": "\u663E\u793A\u6807\u7B7E\u9875",
  "Unknown Tab": "\u672A\u77E5\u6807\u7B7E\u9875",
  // Contextual Groups
  "Contextual Groups": "\u4E0A\u4E0B\u6587\u7F16\u7EC4",
  "Contextual Groups Description": "\u5C06\u4ECE\u5C5E\u89C6\u56FE\uFF08Slave\uFF09\u7ED1\u5B9A\u5230\u4E3B\u89C6\u56FE\uFF08Master\uFF09\u3002\u5F53\u60A8\u6FC0\u6D3B\u4E3B\u89C6\u56FE\u65F6\uFF0C\u4ECE\u5C5E\u89C6\u56FE\u5C06\u4F5C\u4E3A\u5206\u5C4F\u663E\u793A\u5728\u5E95\u90E8\u3002\u4E3B\u89C6\u56FE\u5C06\u663E\u793A\u7EC4\u5408\u7684\u540D\u79F0\u548C\u56FE\u6807\u3002",
  "Add New Group": "\u6DFB\u52A0\u65B0\u7F16\u7EC4",
  "Master View ID": "\u4E3B\u89C6\u56FE ID (\u4F8B\u5982 file-explorer)",
  "Slave View ID": "\u4ECE\u5C5E\u89C6\u56FE ID (\u4F8B\u5982 outline)",
  "Group Name": "\u7F16\u7EC4\u540D\u79F0 (\u53EF\u9009)",
  "Group Icon": "\u7F16\u7EC4\u56FE\u6807 (Lucide \u56FE\u6807\u540D)",
  "Add Binding": "\u6DFB\u52A0\u7ED1\u5B9A",
  "Delete": "\u5220\u9664",
  "Error: Same Side": "\u9519\u8BEF\uFF1A\u4E3B\u89C6\u56FE\u548C\u4ECE\u5C5E\u89C6\u56FE\u5FC5\u987B\u4F4D\u4E8E\u540C\u4E00\u4FA7\u8FB9\u680F\u3002",
  "Error: Invalid ID": "\u9519\u8BEF\uFF1A\u65E0\u6548\u7684\u89C6\u56FE ID \u6216\u8BBE\u7F6E\u4E2D\u672A\u627E\u5230\u8BE5\u89C6\u56FE\u3002",
  "Binding Removed": "\u7ED1\u5B9A\u5DF2\u79FB\u9664\uFF0C\u56E0\u4E3A\u5176\u4E2D\u4E00\u4E2A\u89C6\u56FE\u66F4\u6539\u4E86\u4FA7\u8FB9\u680F\u4F4D\u7F6E\u3002",
  // Group Modal & New UI
  "Create a new contextual group binding": "\u521B\u5EFA\u4E00\u4E2A\u65B0\u7684\u4E0A\u4E0B\u6587\u7F16\u7EC4\u7ED1\u5B9A",
  "The view ID of the main tab (will be replaced by the group tab)": "\u4E3B\u89C6\u56FE ID\uFF08\u5C06\u88AB\u7F16\u7EC4\u6807\u7B7E\u66FF\u6362\uFF09",
  "The view ID of the split tab (hidden until group is active)": "\u4ECE\u5C5E\u89C6\u56FE ID\uFF08\u5728\u7F16\u7EC4\u6FC0\u6D3B\u524D\u9690\u85CF\uFF09",
  "Name to display on the tab": "\u6807\u7B7E\u9875\u663E\u793A\u7684\u540D\u79F0",
  "SVG Code or Lucide Icon Name": "SVG \u4EE3\u7801\u6216 Lucide \u56FE\u6807\u540D\u79F0",
  "Add Group": "\u6DFB\u52A0\u7F16\u7EC4",
  "Unbind": "\u89E3\u9664\u7F16\u7EC4",
  "Error: Master ID already bound": "\u9519\u8BEF\uFF1A\u8BE5\u4E3B\u89C6\u56FE ID \u5DF2\u5728\u53E6\u4E00\u4E2A\u7F16\u7EC4\u4E2D\u7ED1\u5B9A\u3002"
};

// src/i18n/helpers.ts
var localeMap = {
  en: en_default,
  zh: zh_default,
  "zh-cn": zh_default
};
var locale = localeMap[import_obsidian.moment.locale()];
function t(str) {
  if (!locale) {
    return en_default[str] || str;
  }
  return locale[str] || en_default[str] || str;
}

// src/folders/manager.ts
var FoldersManager = class {
  constructor(app, plugin) {
    this.ribbonIconButton = null;
    this.statusBarItem = null;
    this.mutationObserver = null;
    this.layoutChangeRef = null;
    this.processFolders = (0, import_obsidian2.debounce)(async (recheckPreviouslyHiddenFolders) => {
      if (!this.settings.enabled)
        return;
      if (this.settings.attachmentFolderNames.length === 0)
        return;
      if (recheckPreviouslyHiddenFolders) {
        document.querySelectorAll(".obsidian-hide-folders--hidden").forEach((folder) => {
          folder.style.height = "";
          folder.style.overflow = "";
          folder.removeClass("obsidian-hide-folders--hidden");
        });
      }
      this.settings.attachmentFolderNames.forEach((folderName) => {
        var _a, _b;
        if (getFolderNameWithoutPrefix(folderName) === "")
          return;
        const selectorString = [
          this.getQuerySelectorStringForFolderName(folderName),
          this.settings.enableCompatQuickExplorer ? (_b = (_a = CompatQuickExplorer).getAdditionalDocumentSelectorStringForFolder) == null ? void 0 : _b.call(_a, folderName, this.settings) : null
        ].filter((o) => o != null).join(", ");
        if (!selectorString)
          return;
        try {
          const folderElements = document.querySelectorAll(selectorString);
          folderElements.forEach((folder) => {
            if (!folder) {
              return;
            }
            folder.addClass("obsidian-hide-folders--hidden");
            folder.style.height = this.settings.areFoldersHidden ? "0" : "";
            folder.style.display = this.settings.areFoldersHidden ? "none" : "";
            folder.style.overflow = this.settings.areFoldersHidden ? "hidden" : "";
          });
        } catch (e) {
          console.error(`Failed to process folder ${folderName}:`, e);
        }
      });
    }, 100, false);
    this.app = app;
    this.plugin = plugin;
  }
  get settings() {
    return this.plugin.settings.myFolders;
  }
  getQuerySelectorStringForFolderName(folderName) {
    if (folderName.toLowerCase().startsWith("endswith::")) {
      return `*:has(> [data-path$="${getFolderNameWithoutPrefix(folderName)}"${this.settings.matchCaseInsensitive ? " i" : ""}])`;
    } else if (folderName.toLowerCase().startsWith("startswith::")) {
      return `*:has(> .nav-folder-title[data-path^="${getFolderNameWithoutPrefix(folderName)}"${this.settings.matchCaseInsensitive ? " i" : ""}]), *:has(> .nav-folder-title[data-path*="/${getFolderNameWithoutPrefix(folderName)}"${this.settings.matchCaseInsensitive ? " i" : ""}])`;
    } else {
      return `*:has(> [data-path$="/${folderName.trim()}"${this.settings.matchCaseInsensitive ? " i" : ""}]), *:has(> [data-path="${folderName.trim()}"${this.settings.matchCaseInsensitive ? " i" : ""}])`;
    }
  }
  async toggleFunctionality() {
    this.settings.areFoldersHidden = !this.settings.areFoldersHidden;
    if (this.ribbonIconButton) {
      this.ribbonIconButton.ariaLabel = this.settings.areFoldersHidden ? t("Show hidden folders") : t("Hide hidden folders again");
      (0, import_obsidian2.setIcon)(this.ribbonIconButton, this.settings.areFoldersHidden ? "eye" : "eye-off");
    }
    if (this.statusBarItem) {
      this.statusBarItem.innerHTML = this.settings.areFoldersHidden ? t("Configured folders are hidden") : "";
    }
    await this.processFolders();
    await this.plugin.saveSettings();
    await this.updateObsidianIgnoreList();
  }
  updateUI() {
    if (this.ribbonIconButton) {
      this.ribbonIconButton.ariaLabel = this.settings.areFoldersHidden ? t("Show hidden folders") : t("Hide hidden folders again");
      (0, import_obsidian2.setIcon)(this.ribbonIconButton, this.settings.areFoldersHidden ? "eye" : "eye-off");
    }
    if (this.statusBarItem) {
      this.statusBarItem.innerHTML = this.settings.areFoldersHidden ? t("Configured folders are hidden") : "";
    }
  }
  createIgnoreListRegExpForFolderName(rawFolderName) {
    const folderName = this.settings.matchCaseInsensitive ? getFolderNameWithoutPrefix(rawFolderName).split("").map((c) => c.toLowerCase() != c.toUpperCase() ? `[${c.toLowerCase()}${c.toUpperCase()}]` : c).join("") : getFolderNameWithoutPrefix(rawFolderName);
    if (rawFolderName.toLowerCase().startsWith("endswith::")) {
      return `/(${folderName}$)|(${folderName}/)/`;
    } else if (rawFolderName.toLowerCase().startsWith("startswith::")) {
      return `/(^${folderName})|(/${folderName})/`;
    } else {
      return `/${folderName}/`;
    }
  }
  async updateObsidianIgnoreList(processFeatureDisabling) {
    var _a;
    if (!this.settings.addHiddenFoldersToObsidianIgnoreList && !processFeatureDisabling)
      return;
    let ignoreList = (_a = this.app.vault.getConfig("userIgnoreFilters")) != null ? _a : [];
    if (this.settings.areFoldersHidden && !processFeatureDisabling) {
      this.settings.attachmentFolderNames.forEach((folderName) => {
        if (getFolderNameWithoutPrefix(folderName).trim() === "")
          return;
        const regExp = this.createIgnoreListRegExpForFolderName(folderName);
        if (ignoreList.contains(regExp))
          return;
        ignoreList.push(regExp);
      });
    } else {
      const folderNameRegexes = this.settings.attachmentFolderNames.map((folderName) => this.createIgnoreListRegExpForFolderName(folderName));
      ignoreList = ignoreList.filter((s) => !folderNameRegexes.includes(s));
    }
    this.app.vault.setConfig("userIgnoreFilters", ignoreList);
  }
  async removeSpecificFoldersFromObsidianIgnoreList(folderNames) {
    folderNames.forEach((folderName) => {
      var _a;
      (_a = this.app.vault.config.userIgnoreFilters) == null ? void 0 : _a.remove(this.createIgnoreListRegExpForFolderName(folderName));
      this.app.vault.trigger("config-changed");
    });
  }
  createBottomStatusBarIndicatorTextItem() {
    if (this.statusBarItem)
      return;
    this.statusBarItem = this.plugin.addStatusBarItem();
    this.statusBarItem.setText(this.settings.areFoldersHidden ? t("Configured folders are hidden") : "");
  }
  async onload() {
    if (!this.settings.enabled)
      return;
    console.log(t("Loading MyFolders module"));
    this.ribbonIconButton = this.plugin.addRibbonIcon(
      this.settings.areFoldersHidden ? "eye" : "eye-off",
      this.settings.areFoldersHidden ? t("Show hidden folders") : t("Hide hidden folders again"),
      (evt) => {
        this.toggleFunctionality();
      }
    );
    if (!this.settings.hideBottomStatusBarIndicatorText) {
      this.createBottomStatusBarIndicatorTextItem();
    } else if (this.statusBarItem) {
      this.statusBarItem.remove();
      this.statusBarItem = null;
    }
    this.mutationObserver = new MutationObserver((mutationRecord) => {
      const feClasses = [
        "nav-folder",
        "nav-files-container"
      ];
      const shouldTriggerProcessFolders = mutationRecord.some((record) => {
        var _a, _b;
        if (feClasses.some((c) => {
          var _a2, _b2;
          return (_b2 = (_a2 = record.target) == null ? void 0 : _a2.parentElement) == null ? void 0 : _b2.classList.contains(c);
        }))
          return true;
        if (this.settings.enableCompatQuickExplorer && ((_b = (_a = CompatQuickExplorer).shouldMutationRecordTriggerFolderReProcessing) == null ? void 0 : _b.call(_a, record)))
          return true;
        return false;
      });
      if (!shouldTriggerProcessFolders)
        return;
      this.processFolders();
    });
    this.observeFileExplorers();
    this.layoutChangeRef = this.app.workspace.on("layout-change", () => {
      this.observeFileExplorers();
      this.processFolders();
    });
    this.renameEventRef = this.app.vault.on("rename", () => {
      window.setTimeout(() => {
        this.processFolders();
      }, 50);
    });
    if (this.app.workspace.layoutReady) {
      if (this.settings.areFoldersHidden) {
        window.setTimeout(() => {
          this.processFolders();
        }, 1e3);
      }
    } else {
      this.app.workspace.onLayoutReady(() => {
        if (!this.settings.areFoldersHidden)
          return;
        window.setTimeout(() => {
          this.processFolders();
        }, 1e3);
      });
    }
  }
  observeFileExplorers() {
    if (!this.settings.enabled)
      return;
    if (!this.mutationObserver)
      return;
    this.mutationObserver.disconnect();
    const fileExplorers = document.querySelectorAll(".nav-files-container");
    if (fileExplorers.length > 0) {
      fileExplorers.forEach((container) => {
        var _a;
        (_a = this.mutationObserver) == null ? void 0 : _a.observe(container, { childList: true, subtree: true });
      });
    }
  }
  onunload() {
    var _a, _b, _c;
    console.log(t("Unloading MyFolders module"));
    (_a = this.mutationObserver) == null ? void 0 : _a.disconnect();
    this.mutationObserver = null;
    if (this.renameEventRef) {
      this.app.vault.offbyref(this.renameEventRef);
      this.renameEventRef = null;
    }
    if (this.layoutChangeRef) {
      this.app.workspace.offref(this.layoutChangeRef);
      this.layoutChangeRef = null;
    }
    (_b = this.ribbonIconButton) == null ? void 0 : _b.remove();
    this.ribbonIconButton = null;
    (_c = this.statusBarItem) == null ? void 0 : _c.remove();
    this.statusBarItem = null;
  }
};

// src/folders/settings-ui.ts
var import_obsidian3 = require("obsidian");
function renderFoldersSettings(containerEl, manager) {
  const plugin = manager.plugin;
  const settings = manager.settings;
  const experimentalSettingsContainerEl = document.createElement("details");
  experimentalSettingsContainerEl.style.marginBottom = "10px";
  experimentalSettingsContainerEl.style.border = "1px solid var(--background-modifier-border)";
  experimentalSettingsContainerEl.style.borderRadius = "5px";
  experimentalSettingsContainerEl.style.padding = "0.5em";
  const experimentalSettingsTitleEl = document.createElement("summary");
  experimentalSettingsTitleEl.innerText = t("Experimental & Unstable Settings");
  experimentalSettingsTitleEl.style.cursor = "pointer";
  experimentalSettingsTitleEl.style.fontWeight = "bold";
  experimentalSettingsTitleEl.style.outline = "none";
  experimentalSettingsContainerEl.appendChild(experimentalSettingsTitleEl);
  const experimentalContent = experimentalSettingsContainerEl.createDiv();
  experimentalContent.style.marginTop = "10px";
  experimentalContent.style.paddingLeft = "5px";
  experimentalContent.style.borderLeft = "2px solid var(--background-modifier-border)";
  new import_obsidian3.Setting(containerEl).setName(t("Folders to hide")).setDesc(t("The names of the folders to hide, one per line. Either exact folder-names, startsWith::FOLDERPREFIX, or endsWith::FOLDERSUFFIX")).addTextArea((text) => text.setPlaceholder(t("attachments\nendsWith::_attachments")).setValue(settings.attachmentFolderNames.join("\n")).onChange(async (value) => {
    const newSettingsValue = value.split("\n");
    await manager.removeSpecificFoldersFromObsidianIgnoreList(settings.attachmentFolderNames.filter((e) => !newSettingsValue.includes(e)));
    settings.attachmentFolderNames = newSettingsValue;
    await plugin.saveSettings();
    await manager.updateObsidianIgnoreList();
  }));
  new import_obsidian3.Setting(containerEl).setName(t("Ignore Upper/lowercase")).setDesc(t("If enabled, 'SOMEFOLDER', 'someFolder', or 'sOmeFoldEr' will all be treated the same and matched.")).addToggle((toggle) => toggle.setValue(settings.matchCaseInsensitive).onChange(async (value) => {
    await manager.removeSpecificFoldersFromObsidianIgnoreList(settings.attachmentFolderNames);
    settings.matchCaseInsensitive = value;
    await plugin.saveSettings();
    await manager.updateObsidianIgnoreList();
  }));
  new import_obsidian3.Setting(containerEl).setName(t("Hide folders")).setDesc(t("If the configured folders should be hidden or not")).addToggle((toggle) => toggle.setValue(settings.areFoldersHidden).onChange(async (value) => {
    settings.areFoldersHidden = value;
    await plugin.saveSettings();
    await manager.updateObsidianIgnoreList();
    manager.updateUI();
    manager.processFolders();
  }));
  new import_obsidian3.Setting(containerEl).setName(t("Add Hidden Folders to Obsidian Exclusion-List")).setDesc(t("Excluded files will be hidden in Search, Graph View, and Unlinked Mentions, less noticeable in Quick Switcher and link suggestions.")).addToggle((toggle) => toggle.setValue(settings.addHiddenFoldersToObsidianIgnoreList).onChange(async (value) => {
    settings.addHiddenFoldersToObsidianIgnoreList = value;
    await plugin.saveSettings();
    await manager.updateObsidianIgnoreList(!value);
  }));
  new import_obsidian3.Setting(containerEl).setName(t('Hide bottom status-bar "Folders are Hidden" indicator')).setDesc(t("If enable there will be no bottom-bar indicator-text telling you if this plugin is active.")).addToggle((toggle) => toggle.setValue(settings.hideBottomStatusBarIndicatorText).onChange(async (value) => {
    var _a;
    settings.hideBottomStatusBarIndicatorText = value;
    if (value) {
      (_a = manager.statusBarItem) == null ? void 0 : _a.remove();
      manager.statusBarItem = null;
    } else {
      manager.createBottomStatusBarIndicatorTextItem();
    }
    await plugin.saveSettings();
  }));
  new import_obsidian3.Setting(experimentalContent).setName(t("[EXPERIMENTAL] Compatibility: quick-explorer by pjeby")).setDesc(t("[WARNING: UNSTABLE] Also hide hidden folders in the https://github.com/pjeby/quick-explorer plugin. Not affiliated with quick-explorer's author.")).addToggle((toggle) => toggle.setValue(settings.enableCompatQuickExplorer).onChange(async (value) => {
    settings.enableCompatQuickExplorer = value;
    await plugin.saveSettings();
  }));
  containerEl.appendChild(document.createElement("br"));
  containerEl.appendChild(experimentalSettingsContainerEl);
}

// src/statusbar/spooler.ts
var Spooler = class {
  constructor(plugin, callback) {
    this.plugin = plugin;
    this.mutex = false;
    this.spooler = 0;
    this.callback = callback;
    this.observer = new MutationObserver((list, _) => {
      if (!this.mutex && list.some(
        (mutation) => mutation.type == "childList" && mutation.addedNodes.length > 0
      )) {
        this.spoolFix(0);
      }
    });
    this.spoolFix(0);
  }
  /**
   * Disable automatic spooling.
   */
  disableObserver() {
    this.observer.disconnect();
  }
  /**
   * Enable automatic spooling.
   */
  enableObserver() {
    this.observer.observe(this.plugin.statusBar, { childList: true });
  }
  /**
   * Schedule status bar elements to be reordered.
   * 
   * @param timeout 
   */
  spoolFix(timeout = 1e3) {
    clearTimeout(this.spooler);
    this.spooler = window.setTimeout(() => {
      if (this.mutex) {
        this.spoolFix();
      } else {
        this.mutex = true;
        this.disableObserver();
        this.callback(this.plugin);
        this.enableObserver();
        this.mutex = false;
      }
    }, timeout);
  }
};

// src/statusbar/parser.ts
var ignoredClasses = [
  "mod-clickable",
  "status-bar-item",
  "statusbar-organizer-hidden"
];
function getStatusBarElements(statusBar) {
  const elements = [];
  const pluginElementCount = {};
  Array.from(statusBar.children).forEach((element) => {
    let id = element.getAttribute("data-statusbar-organizer-id");
    let name, index;
    if (id == null) {
      name = Array.from(element.classList).filter((x) => !ignoredClasses.contains(x)).join("-");
      index = name in pluginElementCount ? pluginElementCount[name] + 1 : 1;
      id = generateElementId(name, index);
      element.setAttribute("data-statusbar-organizer-id", id);
    } else {
      const parsed = parseElementId(id);
      name = parsed.name;
      index = parsed.index;
    }
    pluginElementCount[name] = Math.max(
      index,
      name in pluginElementCount ? pluginElementCount[name] : 0
    );
    elements.push({
      name,
      index,
      id,
      element
    });
  });
  return elements;
}
function generateElementId(name, index) {
  return `${name};${index}`;
}
function parseElementId(id) {
  const parts = id.split(";");
  const index = Number.parseInt(parts.pop());
  const name = parts.join(";");
  return {
    name,
    index
  };
}

// src/statusbar/organizer.ts
function fixOrder(plugin) {
  if (!plugin.statusBar)
    return;
  const elements = getStatusBarElements(plugin.statusBar);
  const status = plugin.settings.status;
  if (!status)
    return;
  const known = [];
  const orphans = [];
  for (const element of elements) {
    if (element.id in status) {
      const myStatus = status[element.id];
      known.push([element, myStatus.position]);
      if (myStatus.visible)
        element.element.removeClass("statusbar-organizer-element-hidden");
      else
        element.element.addClass("statusbar-organizer-element-hidden");
    } else {
      orphans.push(element.element);
    }
  }
  const orderedElements = known.sort((a, b) => a[1] - b[1]).map((x) => x[0].element);
  const allElements = orderedElements.concat(orphans);
  for (const [i, element] of allElements.entries()) {
    if (element)
      element.style.order = (i + 1).toString();
  }
}

// src/statusbar/manager.ts
var StatusBarManager = class {
  constructor(app, plugin) {
    this.isLoaded = false;
    this.app = app;
    this.plugin = plugin;
    this.settings = this.plugin.settings.myStatusBar;
  }
  async onload() {
    if (this.isLoaded)
      return;
    this.isLoaded = true;
    this.statusBar = document.querySelector(".status-bar");
    if (!this.statusBar) {
      this.app.workspace.onLayoutReady(() => {
        this.statusBar = document.querySelector(".status-bar");
        if (this.statusBar && this.isLoaded)
          this.initializeManager();
      });
      return;
    }
    this.initializeManager();
  }
  initializeManager() {
    if (!this.statusBar)
      return;
    this.spooler = new Spooler(this, fixOrder);
    fixOrder(this);
    this.spooler.enableObserver();
  }
  onunload() {
    if (!this.isLoaded)
      return;
    this.isLoaded = false;
    if (this.spooler)
      this.spooler.disableObserver();
  }
  saveSettings() {
    return this.plugin.saveSettings();
  }
  async saveStatus(currentBarStatus) {
    this.settings.status = currentBarStatus;
    await this.saveSettings();
  }
  /**
   * Merge information about status bar elements based on
   * the saved settings and the state of the actual status bar.
   */
  async consolidateSettingsAndElements() {
    const loadedElementStatus = this.settings.status || {};
    if (!this.statusBar) {
      return { rows: [], barStatus: {}, existsStatus: {} };
    }
    const unorderedStatusBarElements = getStatusBarElements(this.statusBar);
    const defaultElementStatus = {};
    for (const [index, statusBarElement] of unorderedStatusBarElements.entries()) {
      defaultElementStatus[statusBarElement.id] = {
        position: index,
        visible: true
      };
    }
    const barStatus = {};
    const existsStatus = {};
    for (const [index, status] of Object.entries(loadedElementStatus)) {
      barStatus[index] = status;
      existsStatus[index] = index in defaultElementStatus;
    }
    let insertPosition = Object.keys(barStatus).length + 1;
    for (const element of unorderedStatusBarElements) {
      if (element.id in barStatus)
        continue;
      const status = defaultElementStatus[element.id];
      status.position = insertPosition++;
      barStatus[element.id] = status;
      existsStatus[element.id] = true;
    }
    const disabledStatusBarElements = Object.keys(loadedElementStatus).filter((x) => !existsStatus[x]).map((x) => {
      const parsed = parseElementId(x);
      return {
        name: parsed.name,
        index: parsed.index,
        id: x
      };
    });
    const rows = unorderedStatusBarElements.concat(disabledStatusBarElements).map((x) => [x, barStatus[x.id].position]).sort((a, b) => a[1] - b[1]).map((x) => x[0]);
    await this.saveStatus(barStatus);
    this.spooler.spoolFix(0);
    return {
      rows,
      barStatus,
      existsStatus
    };
  }
};

// src/statusbar/rows.ts
var import_obsidian4 = require("obsidian");
var dragging;
async function initializeRows(plugin, settingsContainer) {
  settingsContainer.empty();
  dragging = false;
  const { rows, barStatus, existsStatus } = await plugin.consolidateSettingsAndElements();
  const rowsContainer = document.createElement("div");
  rowsContainer.addClass("statusbar-organizer-rows-container");
  settingsContainer.appendChild(rowsContainer);
  const nameCollisions = {};
  for (const element of rows) {
    if (element.name in nameCollisions)
      nameCollisions[element.name]++;
    else
      nameCollisions[element.name] = 0;
  }
  for (const row of rows) {
    const currentStatus = barStatus[row.id];
    const currentExists = existsStatus[row.id];
    const entry = document.createElement("div");
    entry.addClass("statusbar-organizer-row");
    if (!currentExists) {
      entry.addClass("statusbar-organizer-row-disabled");
      entry.setAttribute("aria-label", t("This element is currently not present in the status bar."));
    }
    if (!currentStatus.visible)
      entry.addClass("statusbar-organizer-row-hidden");
    entry.setAttribute("data-statusbar-organizer-id", row.id);
    row.entry = entry;
    rowsContainer.appendChild(entry);
    const handle = document.createElement("span");
    handle.addClass("statusbar-organizer-row-handle");
    handle.setAttribute("aria-label", t("Drag to reorder"));
    handle.addEventListener(
      "mousedown",
      (event) => handleMouseDown(event, plugin, barStatus, existsStatus, settingsContainer, rowsContainer, rows, row)
    );
    entry.appendChild(handle);
    const formattedName = row.name.replace(/^plugin-(obsidian-)?/, "").split("-").map((x) => x.charAt(0).toUpperCase() + x.slice(1)).join(" ") + (nameCollisions[row.name] ? ` (${row.index})` : "");
    const titleSpan = document.createElement("span");
    titleSpan.addClass("statusbar-organizer-row-title");
    titleSpan.textContent = formattedName;
    entry.appendChild(titleSpan);
    const previewSpan = document.createElement("span");
    previewSpan.addClass("statusbar-organizer-row-preview");
    if (currentExists) {
      previewSpan.innerHTML = row.element.innerHTML;
    }
    entry.appendChild(previewSpan);
    const visibilitySpan = document.createElement("span");
    visibilitySpan.addClass("statusbar-organizer-row-visibility");
    visibilitySpan.setAttribute("aria-label", currentExists ? t("Visibility") : t("Remove orphan"));
    visibilitySpan.onclick = () => {
      if (currentExists)
        toggleVisibility(plugin, barStatus, row);
      else
        removeOrphan(plugin, rowsContainer, barStatus, row);
    };
    (0, import_obsidian4.setIcon)(visibilitySpan, currentExists ? currentStatus.visible ? "eye" : "eye-off" : "trash-2");
    entry.appendChild(visibilitySpan);
  }
  return {
    rows,
    barStatus,
    rowsContainer
  };
}
async function toggleVisibility(plugin, barStatus, row) {
  var _a, _b, _c, _d;
  const status = barStatus[row.id];
  if (status.visible = !status.visible) {
    (_a = row.element) == null ? void 0 : _a.removeClass("statusbar-organizer-element-hidden");
    (_b = row.entry) == null ? void 0 : _b.removeClass("statusbar-organizer-row-hidden");
    (0, import_obsidian4.setIcon)(row.entry.children[3], "eye");
  } else {
    (_c = row.element) == null ? void 0 : _c.addClass("statusbar-organizer-element-hidden");
    (_d = row.entry) == null ? void 0 : _d.addClass("statusbar-organizer-row-hidden");
    (0, import_obsidian4.setIcon)(row.entry.children[3], "eye-off");
  }
  plugin.saveStatus(barStatus);
}
async function removeOrphan(plugin, rowsContainer, barStatus, row) {
  rowsContainer.removeChild(row.entry);
  delete barStatus[row.id];
  for (const [entryIndex, entry] of Array.from(rowsContainer.children).entries())
    barStatus[entry.getAttribute("data-statusbar-organizer-id")].position = entryIndex;
  plugin.saveStatus(barStatus);
}
function cloneRow(settingsContainer, barStatus, existsStatus, rowsContainer, event, row) {
  const realEntry = row.entry;
  realEntry.addClass("statusbar-organizer-row-clone");
  const fauxEntry = document.createElement("div");
  fauxEntry.addClass("statusbar-organizer-row");
  fauxEntry.addClass("statusbar-organizer-row-drag");
  if (!existsStatus[row.id])
    fauxEntry.addClass("statusbar-organizer-row-disabled");
  if (!barStatus[row.id].visible)
    fauxEntry.addClass("statusbar-organizer-row-hidden");
  settingsContainer.appendChild(fauxEntry);
  const containerX = settingsContainer.getBoundingClientRect().left;
  const containerY = settingsContainer.getBoundingClientRect().top;
  fauxEntry.style.left = realEntry.getBoundingClientRect().left - containerX + "px";
  fauxEntry.style.top = realEntry.getBoundingClientRect().top - containerY + "px";
  fauxEntry.style.width = realEntry.offsetWidth + "px";
  for (const child of Array.from(realEntry.children)) {
    const fauxSpan = document.createElement("span");
    fauxSpan.className = child.className;
    fauxSpan.innerHTML = child.innerHTML;
    fauxEntry.appendChild(fauxSpan);
  }
  let offsetX = event.clientX - fauxEntry.getBoundingClientRect().left;
  let offsetY = event.clientY - fauxEntry.getBoundingClientRect().top;
  let index = Array.from(rowsContainer.children).indexOf(realEntry);
  return {
    stationaryRow: realEntry,
    movableRow: fauxEntry,
    offsetX: offsetX + containerX,
    offsetY: offsetY + containerY,
    index
  };
}
function deleteRowClone(settingsContainer, stationaryRow, movableRow) {
  stationaryRow.removeClass("statusbar-organizer-row-clone");
  settingsContainer.removeChild(movableRow);
}
function calculateRowIndex(event, rowsContainer, movableRow, stationaryRow, offsetX, offsetY, index) {
  movableRow.style.left = event.clientX - offsetX + "px";
  movableRow.style.top = event.clientY - offsetY + "px";
  const dist = movableRow.getBoundingClientRect().top - stationaryRow.getBoundingClientRect().top;
  if (Math.abs(dist) > stationaryRow.offsetHeight * 0.75) {
    const dir = dist / Math.abs(dist);
    const newIndex = Math.max(0, Math.min(index + dir, rowsContainer.children.length - 1));
    return newIndex;
  }
  return index;
}
function handlePositionChange(barStatus, existsStatus, rowsContainer, rows, row, stationaryRow, newIndex) {
  const passedEntry = rowsContainer.children[newIndex];
  const passedId = passedEntry.getAttribute("data-statusbar-organizer-id");
  const statusBarChangeRequired = existsStatus[row.id] && existsStatus[passedId];
  if (statusBarChangeRequired && row.element) {
    const passedElement = rows.filter((x) => x.id == passedId)[0].element;
    const temp = passedElement.style.order;
    passedElement.style.order = row.element.style.order;
    row.element.style.order = temp;
  }
  rowsContainer.removeChild(stationaryRow);
  if (newIndex != rowsContainer.children.length)
    rowsContainer.insertBefore(stationaryRow, rowsContainer.children[newIndex]);
  else
    rowsContainer.appendChild(stationaryRow);
  for (const [entryIndex, entry] of Array.from(rowsContainer.children).entries())
    barStatus[entry.getAttribute("data-statusbar-organizer-id")].position = entryIndex;
}
function handleMouseDown(event, plugin, barStatus, existsStatus, settingsContainer, rowsContainer, rows, row) {
  if (dragging)
    return;
  dragging = true;
  let { stationaryRow, movableRow, offsetX, offsetY, index } = cloneRow(settingsContainer, barStatus, existsStatus, rowsContainer, event, row);
  function handleMouseMove(event2) {
    plugin.spooler.disableObserver();
    const newIndex = calculateRowIndex(event2, rowsContainer, movableRow, stationaryRow, offsetX, offsetY, index);
    if (newIndex != index) {
      handlePositionChange(barStatus, existsStatus, rowsContainer, rows, row, stationaryRow, newIndex);
      index = newIndex;
    }
    plugin.spooler.enableObserver();
  }
  window.addEventListener("mousemove", handleMouseMove);
  async function handleMouseUp() {
    deleteRowClone(settingsContainer, stationaryRow, movableRow);
    dragging = false;
    window.removeEventListener("mouseup", handleMouseUp);
    window.removeEventListener("mousemove", handleMouseMove);
    plugin.saveStatus(barStatus);
  }
  window.addEventListener("mouseup", handleMouseUp);
}

// src/statusbar/settings-ui.ts
function renderStatusBarSettings(containerEl, manager) {
  const plugin = manager;
  showSettings(plugin, containerEl);
}
async function showSettings(plugin, topContainer) {
  topContainer.empty();
  const settingsContainer = document.createElement("div");
  settingsContainer.addClass("statusbar-organizer-rows-container-wrapper");
  topContainer.appendChild(settingsContainer);
  await initializeRows(plugin, settingsContainer);
}

// src/plugins/manager.ts
var import_obsidian5 = require("obsidian");
var PluginsManager = class {
  constructor(app, plugin) {
    this.manifests = [];
    this.pendingTimeouts = [];
    this.device = "desktop/global";
    this.isLoaded = false;
    this.app = app;
    this.plugin = plugin;
  }
  get settings() {
    return this.plugin.settings.myPlugins;
  }
  get deviceSettings() {
    if (this.settings.dualConfigs && import_obsidian5.Platform.isMobile) {
      return this.settings.mobile || this.settings.desktop;
    }
    return this.settings.desktop;
  }
  async onload() {
    if (this.isLoaded)
      return;
    this.isLoaded = true;
    if (!this.settings.enabled)
      return;
    if (this.settings.dualConfigs && import_obsidian5.Platform.isMobile) {
      if (!this.settings.mobile) {
        this.settings.mobile = JSON.parse(JSON.stringify(this.settings.desktop));
        await this.plugin.saveSettings();
      }
      this.device = "mobile";
    } else {
      this.device = "desktop/global";
    }
    this.updateManifests();
    await this.setInitialPluginsConfiguration();
    this.manifests.forEach((plugin) => this.setPluginStartup(plugin.id));
  }
  onunload() {
    if (!this.isLoaded)
      return;
    this.isLoaded = false;
    this.pendingTimeouts.forEach((timeout) => clearTimeout(timeout));
    this.pendingTimeouts = [];
  }
  async setPluginStartup(pluginId) {
    var _a, _b;
    const obsidian = this.app.plugins;
    const startupType = this.getPluginStartup(pluginId);
    const isActiveOnStartup = obsidian.enabledPlugins.has(pluginId);
    const isRunning = (_b = (_a = obsidian.plugins) == null ? void 0 : _a[pluginId]) == null ? void 0 : _b._loaded;
    switch (startupType) {
      case "disabled" /* disabled */:
        await obsidian.disablePluginAndSave(pluginId);
        break;
      case "instant" /* instant */:
        if (!isActiveOnStartup && !isRunning)
          await obsidian.enablePluginAndSave(pluginId);
        break;
      case "short" /* short */:
      case "long" /* long */:
        if (isActiveOnStartup) {
          await obsidian.disablePluginAndSave(pluginId);
          await obsidian.enablePlugin(pluginId);
        } else if (!isRunning) {
          const seconds = startupType === "short" /* short */ ? this.deviceSettings.shortDelaySeconds : this.deviceSettings.longDelaySeconds;
          const stagger = isNaN(this.deviceSettings.delayBetweenPlugins) ? 40 : this.deviceSettings.delayBetweenPlugins;
          const delay = this.manifests.findIndex((x) => x.id === pluginId) * stagger;
          const timeout = setTimeout(async () => {
            var _a2, _b2;
            try {
              if (!((_b2 = (_a2 = obsidian.plugins) == null ? void 0 : _a2[pluginId]) == null ? void 0 : _b2._loaded)) {
                if (this.settings.showConsoleLog) {
                  console.log(t("Starting {id} after a {type} delay").replace("{id}", pluginId).replace("{type}", startupType));
                }
                await obsidian.enablePlugin(pluginId);
              }
            } catch (e) {
              console.error(t("Failed to load plugin {id} after delay:").replace("{id}", pluginId), e);
            }
          }, seconds * 1e3 + delay);
          this.pendingTimeouts.push(timeout);
        }
        break;
    }
  }
  getPluginStartup(pluginId) {
    var _a, _b;
    return ((_b = (_a = this.deviceSettings.plugins) == null ? void 0 : _a[pluginId]) == null ? void 0 : _b.startupType) || this.deviceSettings.defaultStartupType || // @ts-expect-error
    (this.app.plugins.enabledPlugins.has(pluginId) ? "instant" /* instant */ : "disabled" /* disabled */);
  }
  async setInitialPluginsConfiguration() {
    var _a, _b;
    let changed = false;
    for (const plugin of this.manifests) {
      if (!((_b = (_a = this.deviceSettings.plugins) == null ? void 0 : _a[plugin.id]) == null ? void 0 : _b.startupType)) {
        this.updatePluginSettingsWithNoSave(plugin.id, this.getPluginStartup(plugin.id));
        changed = true;
      }
    }
    if (changed)
      await this.plugin.saveSettings();
  }
  async updatePluginSettings(pluginId, startupType) {
    this.deviceSettings.plugins[pluginId] = { startupType };
    await this.plugin.saveSettings();
  }
  updatePluginSettingsWithNoSave(pluginId, startupType) {
    this.deviceSettings.plugins[pluginId] = { startupType };
  }
  updateManifests() {
    this.manifests = Object.values(this.app.plugins.manifests).filter((plugin) => plugin.id !== this.plugin.manifest.id && !(import_obsidian5.Platform.isMobile && plugin.isDesktopOnly)).sort((a, b) => a.name.localeCompare(b.name));
  }
};

// src/plugins/settings-ui.ts
var import_obsidian6 = require("obsidian");
function renderPluginsSettings(containerEl, manager) {
  const view = new PluginsSettingsView(containerEl, manager);
  view.display();
}
var PluginsSettingsView = class {
  constructor(containerEl, manager) {
    this.dropdowns = [];
    this.containerEl = containerEl;
    this.manager = manager;
  }
  get settings() {
    return this.manager.settings;
  }
  async display() {
    const { containerEl } = this;
    if (!this.settings.enabled)
      return;
    new import_obsidian6.Setting(containerEl).setName(t("Separate desktop/mobile configuration")).setDesc(t("Enable this if you want to have different settings depending whether you're using a desktop or mobile device. All of the settings below can be configured differently on desktop and mobile. You're currently using the {device} settings.").replace("{device}", this.manager.device)).addToggle((toggle) => {
      toggle.setValue(this.settings.dualConfigs).onChange(async (value) => {
        this.settings.dualConfigs = value;
        await this.manager.plugin.saveSettings();
        await this.manager.onload();
      });
    });
    Object.entries({
      shortDelaySeconds: t("Short delay (seconds)"),
      longDelaySeconds: t("Long delay (seconds)")
    }).forEach(([key, name]) => {
      new import_obsidian6.Setting(containerEl).setName(name).addText((text) => text.setValue(this.manager.deviceSettings[key].toString()).onChange(async (value) => {
        this.manager.deviceSettings[key] = parseFloat(parseFloat(value).toFixed(3));
        await this.manager.plugin.saveSettings();
      }));
    });
    new import_obsidian6.Setting(containerEl).setName(t("Default startup type for new plugins")).addDropdown((dropdown) => {
      dropdown.addOption("", t("Nothing configured"));
      this.addDelayOptions(dropdown);
      dropdown.setValue(this.manager.deviceSettings.defaultStartupType || "").onChange(async (value) => {
        this.manager.deviceSettings.defaultStartupType = value || null;
        await this.manager.plugin.saveSettings();
      });
    });
    new import_obsidian6.Setting(containerEl).setName(t("Show plugin descriptions")).addToggle((toggle) => {
      toggle.setValue(this.manager.deviceSettings.showDescriptions).onChange(async (value) => {
        this.manager.deviceSettings.showDescriptions = value;
        await this.manager.plugin.saveSettings();
        this.buildPluginList();
      });
    });
    new import_obsidian6.Setting(containerEl).setName(t("Set the delay for all plugins at once")).addDropdown((dropdown) => {
      dropdown.addOption("", t("Set all plugins to be:"));
      this.addDelayOptions(dropdown);
      dropdown.onChange(async (value) => {
        this.manager.manifests.forEach((plugin) => {
          this.manager.deviceSettings.plugins[plugin.id] = { startupType: value };
        });
        this.dropdowns.forEach((d) => d.setValue(value));
        dropdown.setValue("");
        await this.manager.plugin.saveSettings();
      });
    });
    const pluginsDetails = containerEl.createEl("details");
    pluginsDetails.style.marginBottom = "10px";
    pluginsDetails.style.border = "1px solid var(--background-modifier-border)";
    pluginsDetails.style.borderRadius = "5px";
    pluginsDetails.style.padding = "0.5em";
    pluginsDetails.open = true;
    const pluginsSummary = pluginsDetails.createEl("summary");
    pluginsSummary.setText(t("Plugins"));
    pluginsSummary.style.cursor = "pointer";
    pluginsSummary.style.fontWeight = "bold";
    pluginsSummary.style.outline = "none";
    const pluginsContent = pluginsDetails.createEl("div");
    pluginsContent.style.marginTop = "10px";
    pluginsContent.style.paddingLeft = "5px";
    pluginsContent.style.borderLeft = "2px solid var(--background-modifier-border)";
    const filterContainer = pluginsContent.createDiv();
    filterContainer.createSpan({ text: t("Filter by: "), style: "margin-right: 10px; font-weight: bold;" });
    this.addFilterButton(filterContainer, t("All"));
    Object.keys(LoadingMethod).forEach((key) => this.addFilterButton(filterContainer, t(LoadingMethod[key]) || key, key));
    new import_obsidian6.Setting(pluginsContent).addText((text) => text.setPlaceholder(t("Type to filter list")).onChange((value) => {
      this.filterString = value;
      this.buildPluginList();
    }));
    this.pluginListContainer = pluginsContent.createEl("div");
    this.buildPluginList();
  }
  buildPluginList() {
    this.pluginListContainer.empty();
    this.manager.updateManifests();
    this.manager.manifests.forEach((plugin) => {
      const currentValue = this.manager.getPluginStartup(plugin.id);
      if (this.filterMethod && currentValue !== this.filterMethod)
        return;
      if (this.filterString && !plugin.name.toLowerCase().includes(this.filterString.toLowerCase()))
        return;
      new import_obsidian6.Setting(this.pluginListContainer).setName(plugin.name).addDropdown((dropdown) => {
        this.dropdowns.push(dropdown);
        this.addDelayOptions(dropdown);
        dropdown.setValue(currentValue).onChange(async (value) => {
          await this.manager.updatePluginSettings(plugin.id, value);
          this.manager.setPluginStartup(plugin.id);
        });
      }).then((setting) => {
        if (this.manager.deviceSettings.showDescriptions) {
          setting.setDesc(plugin.description);
        }
      });
    });
  }
  addDelayOptions(el) {
    const loadingMethodsDisplay = {
      disabled: t("\u26D4 Disable plugin"),
      instant: t("\u26A1 Instant"),
      short: t("\u231A Short delay"),
      long: t("\u{1F4A4} Long delay")
    };
    Object.keys(loadingMethodsDisplay).forEach((key) => {
      el.addOption(key, loadingMethodsDisplay[key]);
    });
  }
  addFilterButton(el, text, value) {
    const link = el.createEl("button", { text });
    link.addClass("lazy-plugin-filter");
    link.style.marginRight = "5px";
    link.onclick = () => {
      this.filterMethod = value;
      this.buildPluginList();
    };
  }
};

// src/snippets/manager.ts
var import_obsidian10 = require("obsidian");

// src/snippets/icons/customIcons.ts
var import_obsidian7 = require("obsidian");
var icons = {
  "art-fill": `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke-width="0" stroke-linecap="round" stroke-linejoin="round"><path d="M20 14c-.092.064-2 2.083-2 3.5c0 1.494.949 2.448 2 2.5c.906.044 2-.891 2-2.5c0-1.5-1.908-3.436-2-3.5zM9.586 20c.378.378.88.586 1.414.586s1.036-.208 1.414-.586l7-7l-.707-.707L11 4.586L8.707 2.293L7.293 3.707L9.586 6L4 11.586c-.378.378-.586.88-.586 1.414s.208 1.036.586 1.414L9.586 20zM11 7.414L16.586 13H5.414L11 7.414z" fill="currentColor"/></svg>`,
  "art-brush": `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke-width="0" stroke-linecap="round" stroke-linejoin="round"><path d="M18 2H7c-1.103 0-2 .897-2 2v3c0 1.103.897 2 2 2h11c1.103 0 2-.897 2-2V4c0-1.103-.897-2-2-2zM7 7V4h11l.002 3H7z" fill="currentColor"/><path d="M13 15v-2c0-1.103-.897-2-2-2H4V5c-1.103 0-2 .897-2 2v4c0 1.103.897 2 2 2h7v2a1 1 0 0 0-1 1v5a1 1 0 0 0 1 1h2a1 1 0 0 0 1-1v-5a1 1 0 0 0-1-1z" fill="currentColor"/></svg>`,
  "ms-create-file": `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke-width="0" stroke-linecap="round" stroke-linejoin="round"><g class="icon-tabler" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20 4l-2 14.5l-6 2l-6-2L4 4z"/><path d="M8.5 8h7L11 12h4l-.5 3.5l-2.5.75l-2.5-.75l-.1-.5"/></g></svg>`,
  "pantone-line": `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke-width="0" stroke-linecap="round" stroke-linejoin="round"><path d="M5.764 8l-.295-.73a1 1 0 0 1 .553-1.302l9.272-3.746a1 1 0 0 1 1.301.552l5.62 13.908a1 1 0 0 1-.553 1.302L12.39 21.73a1 1 0 0 1-1.302-.553L11 20.96V21H7a1 1 0 0 1-1-1v-.27l-3.35-1.353a1 1 0 0 1-.552-1.302L5.764 8zM8 19h2.209L8 13.533V19zm-2-6.244l-1.673 4.141L6 17.608v-4.852zm1.698-5.309l4.87 12.054l7.418-2.997l-4.87-12.053l-7.418 2.996zm2.978 2.033a1 1 0 1 1-.749-1.855a1 1 0 0 1 .75 1.855z" fill="currentColor"/></svg>`,
  "ms-code": `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke-width="0" stroke-linecap="round" stroke-linejoin="round"><g fill="none"><path d="M20 21H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2zM4 7v12h16V7H4zm10.707 9.707l-1.413-1.413L15.586 13l-2.293-2.293l1.414-1.414L18.414 13l-3.706 3.706l-.001.001zm-5.414 0L5.586 13l3.707-3.707l1.414 1.414L8.414 13l2.292 2.293l-1.413 1.413v.001z" fill="currentColor"/></g></svg>`,
  "ms-reload": `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><path d="M6 4h15a1 1 0 0 1 1 1v7h-2V6H6v3L1 5l5-4v3zm12 16H3a1 1 0 0 1-1-1v-7h2v6h14v-3l5 4l-5 4v-3z" fill="white"/></svg>`,
  "ms-folder": `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><path fill="white" d="M20 5h-8.586L9.707 3.293A.997.997 0 0 0 9 3H4c-1.103 0-2 .897-2 2v14c0 1.103.897 2 2 2h16c1.103 0 2-.897 2-2V7c0-1.103-.897-2-2-2zM4 19V7h16l.002 12H4z"></path></svg>`,
  "ms-snippet": `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><path d="M7.375 16.781l1.25-1.562L4.601 12l4.024-3.219l-1.25-1.562l-5 4a1 1 0 0 0 0 1.562l5 4zm9.25-9.562l-1.25 1.562L19.399 12l-4.024 3.219l1.25 1.562l5-4a1 1 0 0 0 0-1.562l-5-4zm-1.649-4.003l-4 18l-1.953-.434l4-18z" fill="white"/></svg>`,
  "ms-add": `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke="white" stroke-width="0" stroke-linecap="round" stroke-linejoin="round"><path d="M13 7h-2v4H7v2h4v4h2v-4h4v-2h-4z" fill="white"/><path d="M12 2C6.486 2 2 6.486 2 12s4.486 10 10 10s10-4.486 10-10S17.514 2 12 2zm0 18c-4.411 0-8-3.589-8-8s3.589-8 8-8s8 3.589 8 8s-3.589 8-8 8z" fill="white"/></svg>`,
  "ms-save": `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke="white" stroke-width="0" stroke-linecap="round" stroke-linejoin="round"><path d="M5 21h14a2 2 0 0 0 2-2V8a1 1 0 0 0-.29-.71l-4-4A1 1 0 0 0 16 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2zm10-2H9v-5h6zM13 7h-2V5h2zM5 5h2v4h8V5h.59L19 8.41V19h-2v-5a2 2 0 0 0-2-2H9a2 2 0 0 0-2 2v5H5z" fill="white"/></svg>`,
  "ms-delete": `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke="white" stroke-width="0" stroke-linecap="round" stroke-linejoin="round"><path d="M5 20a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V8h2V6h-4V4a2 2 0 0 0-2-2H9a2 2 0 0 0-2 2v2H3v2h2zM9 4h6v2H9zM8 8h9v12H7V8z" fill="white"/><path d="M9 10h2v8H9zm4 0h2v8h-2z" fill="white"/></svg>`,
  "ms-css-file": `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke-width="0" stroke-linecap="round" stroke-linejoin="round"><path d="M 6 2 C 4.895 2 4 2.895 4 4 L 4 9 L 3 9 C 1.895 9 1 9.895 1 11 L 1 16 C 1 17.105 1.895 18 3 18 L 4 18 L 4 20 C 4 21.105 4.895 22 6 22 L 18 22 C 19.105 22 20 21.105 20 20 L 20 7.828125 C 20 7.298125 19.789062 6.7890625 19.414062 6.4140625 L 15.585938 2.5859375 C 15.210937 2.2109375 14.701875 2 14.171875 2 L 6 2 z M 6 4 L 14 4 L 14 7 C 14 7.552 14.448 8 15 8 L 18 8 L 18 20 L 6 20 L 6 18 L 15 18 C 16.105 18 17 17.105 17 16 L 17 11 C 17 9.895 16.105 9 15 9 L 6 9 L 6 4 z M 5 11 C 6.105 11 7 11.895 7 13 L 6 13 C 6 12.449 5.551 12 5 12 C 4.449 12 4 12.449 4 13 L 4 14 C 4 14.551 4.449 15 5 15 C 5.551 15 6 14.551 6 14 L 7 14 C 7 15.105 6.105 16 5 16 C 3.895 16 3 15.105 3 14 L 3 13 C 3 11.895 3.895 11 5 11 z M 9.6445312 11.001953 C 11.067531 11.042953 11.154297 12.284859 11.154297 12.505859 L 10.1875 12.505859 C 10.1875 12.402859 10.204906 11.806641 9.6289062 11.806641 C 9.4539062 11.806641 9.0598438 11.884187 9.0898438 12.367188 C 9.1188437 12.808188 9.7035469 13.018406 9.8105469 13.066406 C 10.034547 13.148406 11.141391 13.642391 11.150391 14.650391 C 11.152391 14.864391 11.097062 15.985 9.6640625 16 C 8.1050625 16.017 8 14.675438 8 14.398438 L 8.9746094 14.398438 C 8.9746094 14.545438 8.9870625 15.256172 9.6640625 15.201172 C 10.071063 15.167172 10.159828 14.87425 10.173828 14.65625 C 10.195828 14.29025 9.8465625 14.070578 9.4765625 13.892578 C 8.9565625 13.642578 8.1341406 13.335328 8.1191406 12.361328 C 8.1061406 11.484328 8.7505312 10.976953 9.6445312 11.001953 z M 13.490234 11.001953 C 14.913234 11.042953 15 12.284859 15 12.505859 L 14.03125 12.505859 C 14.03125 12.402859 14.048656 11.806641 13.472656 11.806641 C 13.297656 11.806641 12.905547 11.884187 12.935547 12.367188 C 12.964547 12.808188 13.547297 13.018406 13.654297 13.066406 C 13.878297 13.148406 14.987094 13.642391 14.996094 14.650391 C 14.998094 14.864391 14.942766 15.985 13.509766 16 C 11.950766 16.017 11.845703 14.675437 11.845703 14.398438 L 12.820312 14.398438 C 12.820312 14.545438 12.832766 15.256172 13.509766 15.201172 C 13.916766 15.167172 14.005531 14.87425 14.019531 14.65625 C 14.041531 14.29025 13.692266 14.070578 13.322266 13.892578 C 12.802266 13.642578 11.979844 13.335328 11.964844 12.361328 C 11.951844 11.484328 12.596234 10.976953 13.490234 11.001953 z" fill="currentColor"/></svg>`
};
function addIcons() {
  Object.keys(icons).forEach((key) => {
    (0, import_obsidian7.addIcon)(key, icons[key]);
  });
}

// src/snippets/ui/snippetsMenu.ts
var import_obsidian9 = require("obsidian");

// src/snippets/util/setAttributes.ts
function setAttributes(element, attributes) {
  for (let key in attributes) {
    element.setAttribute(key, attributes[key]);
  }
}

// src/snippets/modal/createSnippetModal.ts
var import_obsidian8 = require("obsidian");
var CreateSnippetModal = class extends import_obsidian8.Modal {
  constructor(app, manager) {
    super(app);
    this.app = app;
    this.manager = manager;
    this.onOpen = () => this.display(true);
  }
  async display(focus) {
    const { contentEl } = this;
    const customCss = this.app.customCss;
    contentEl.empty();
    contentEl.setAttribute("style", "margin-top: 0px");
    const title = document.createElement("h1");
    title.setText(t("Create a CSS Snippet"));
    contentEl.appendChild(title);
    const fileTitleSetting = new import_obsidian8.Setting(contentEl);
    const fileTitleValue = new import_obsidian8.TextComponent(fileTitleSetting.controlEl);
    fileTitleSetting.setName(t("CSS Snippet Title")).setDesc(t("Write the title for this CSS snippet file."));
    const cssStylesSetting = new import_obsidian8.Setting(contentEl);
    cssStylesSetting.settingEl.setAttribute(
      "style",
      "display: grid; grid-template-columns: 1fr;"
    );
    const cssStylesValue = new import_obsidian8.TextAreaComponent(cssStylesSetting.controlEl);
    setAttributes(cssStylesValue.inputEl, {
      style: "margin-top: 12px; width: 100%;  height: 32vh;",
      class: "ms-css-editor"
    });
    cssStylesSetting.setName(t("CSS Snippet Styles")).setDesc(t("Add in styling for this CSS snippet file."));
    cssStylesValue.setValue(this.manager.settings.stylingTemplate);
    const doAdd = async () => {
      let fileName = fileTitleValue.getValue();
      let fileContents = cssStylesValue.getValue();
      let snippetPath = customCss.getSnippetPath(fileName);
      if (fileName) {
        if (!customCss.snippets.includes(fileName)) {
          await this.app.vault.create(
            `${customCss.getSnippetsFolder()}/${fileName}.css`,
            fileContents
          );
          console.log("%c" + t('"{fileName}.css" has been created!').replace("{fileName}", fileName), "color: Violet");
          if (this.manager.settings.snippetEnabledStatus)
            customCss.setCssEnabledStatus(fileName, true);
          if (this.manager.settings.openSnippetFile)
            this.app.openWithDefaultApp(snippetPath);
          customCss.requestLoadSnippets();
          this.close();
        } else
          new import_obsidian8.Notice(t('"{fileName}.css" already exists.').replace("{fileName}", fileName));
      } else
        new import_obsidian8.Notice(t("Missing name for file"));
    };
    const saveButton = new import_obsidian8.ButtonComponent(contentEl).setButtonText(t("Create Snippet")).onClick(doAdd);
    saveButton.buttonEl.addClass("wg-button");
    fileTitleValue.inputEl.focus();
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/snippets/ui/snippetsMenu.ts
function snippetsMenu(app, manager, settings) {
  const windowX = window.innerWidth;
  const windowY = window.innerHeight;
  const menuExists = document.querySelector(".menu.MySnippets-statusbar-menu");
  if (!menuExists) {
    const menu = new import_obsidian9.Menu();
    const menuDom = menu.dom;
    menuDom.addClass("MySnippets-statusbar-menu");
    if (settings.aestheticStyle) {
      menuDom.setAttribute(
        "style",
        "background-color: transparent; backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px);"
      );
    }
    const customCss = app.customCss;
    const currentSnippets = customCss.snippets;
    const snippetsFolder = customCss.getSnippetsFolder();
    currentSnippets.forEach((snippet) => {
      const snippetPath = customCss.getSnippetPath(snippet);
      menu.addItem((snippetElement) => {
        snippetElement.setTitle(snippet);
        const snippetElementDom = snippetElement.dom;
        const toggleComponent = new import_obsidian9.ToggleComponent(snippetElementDom);
        const buttonComponent = new import_obsidian9.ButtonComponent(snippetElementDom);
        function changeSnippetStatus() {
          const isEnabled = customCss.enabledSnippets.has(snippet);
          customCss.setCssEnabledStatus(snippet, !isEnabled);
        }
        toggleComponent.setValue(customCss.enabledSnippets.has(snippet)).onChange(changeSnippetStatus);
        buttonComponent.setIcon("ms-snippet").setClass("MS-OpenSnippet").setTooltip(t(`Open snippet`)).onClick((e) => {
          app.openWithDefaultApp(snippetPath);
        });
        snippetElement.onClick((e) => {
          e.preventDefault();
          e.stopImmediatePropagation();
        });
      });
    });
    menu.addSeparator();
    menu.addItem((actions) => {
      const enhancedActions = actions;
      enhancedActions.setIcon(null);
      enhancedActions.setTitle(t("Actions"));
      const actionsDom = enhancedActions.dom;
      setAttributes(enhancedActions.titleEl, { style: "font-weight: 700" });
      const reloadButton = new import_obsidian9.ButtonComponent(actionsDom);
      const folderButton = new import_obsidian9.ButtonComponent(actionsDom);
      const addButton = new import_obsidian9.ButtonComponent(actionsDom);
      setAttributes(reloadButton.buttonEl, { style: "margin-right: 3px" });
      setAttributes(addButton.buttonEl, { style: "margin-left: 3px" });
      reloadButton.setIcon("ms-reload").setClass("MySnippetsButton").setClass("MS-Reload").setTooltip(t("Reload snippets")).onClick((e) => {
        customCss.requestLoadSnippets();
        new import_obsidian9.Notice(t("Snippets reloaded"));
      });
      folderButton.setIcon("ms-folder").setClass("MySnippetsButton").setClass("MS-Folder").setTooltip(t("Open snippets folder")).onClick((e) => {
        app.openWithDefaultApp(snippetsFolder);
      });
      addButton.setIcon("ms-add").setClass("MySnippetsButton").setClass("MS-Folder").setTooltip(t("Create new snippet")).onClick((e) => {
        new CreateSnippetModal(app, manager).open();
      });
    });
    menu.showAtPosition({
      x: windowX - 15,
      y: windowY - 37
    });
  }
}

// src/snippets/manager.ts
var SnippetsManager = class {
  constructor(app, plugin) {
    this.isLoaded = false;
    this.app = app;
    this.plugin = plugin;
    this.settings = this.plugin.settings.mySnippets;
  }
  async onload() {
    if (this.isLoaded)
      return;
    this.isLoaded = true;
    console.log(t("Loading MySnippets module..."));
    addIcons();
    if (this.app.workspace.layoutReady) {
      this.setupSnippetsStatusBarIcon();
    } else {
      this.app.workspace.onLayoutReady(() => {
        setTimeout(() => {
          this.setupSnippetsStatusBarIcon();
        });
      });
    }
  }
  openMenu() {
    if (this.settings.enabled)
      snippetsMenu(this.app, this, this.settings);
  }
  openCreateModal() {
    if (this.settings.enabled)
      new CreateSnippetModal(this.app, this).open();
  }
  onunload() {
    if (!this.isLoaded)
      return;
    this.isLoaded = false;
    console.log(t("Unloading MySnippets module..."));
    if (this.statusBarIcon) {
      this.statusBarIcon.remove();
      this.statusBarIcon = void 0;
    }
  }
  setupSnippetsStatusBarIcon() {
    if (!this.settings.showStatusBarIcon) {
      if (this.statusBarIcon) {
        this.statusBarIcon.remove();
        this.statusBarIcon = void 0;
      }
      return;
    }
    if (this.statusBarIcon)
      return;
    this.statusBarIcon = this.plugin.addStatusBarItem();
    this.statusBarIcon.addClass("MiniSettings-statusbar-button");
    this.statusBarIcon.addClass("mod-clickable");
    setAttributes(this.statusBarIcon, {
      "aria-label": "Configure Snippets",
      "aria-label-position": "top"
    });
    (0, import_obsidian10.setIcon)(this.statusBarIcon, "pantone-line");
    this.plugin.registerDomEvent(this.statusBarIcon, "click", () => {
      snippetsMenu(this.app, this, this.settings);
    });
  }
  updateStatusBar() {
    this.setupSnippetsStatusBarIcon();
  }
  saveSettings() {
    return this.plugin.saveSettings();
  }
};

// src/snippets/settings-ui.ts
var import_obsidian11 = require("obsidian");
function renderSnippetsSettings(containerEl, manager) {
  const plugin = manager.plugin;
  const settings = manager.settings;
  new import_obsidian11.Setting(containerEl).setName(t("Show Status Bar Icon")).setDesc(t("Toggle the visibility of the snippets icon in the status bar.")).addToggle((toggle) => {
    toggle.setValue(settings.showStatusBarIcon).onChange(async (value) => {
      settings.showStatusBarIcon = value;
      await manager.saveSettings();
      manager.updateStatusBar();
    });
  });
  const snippetsSection = containerEl.createEl("details");
  snippetsSection.style.marginBottom = "10px";
  snippetsSection.style.border = "1px solid var(--background-modifier-border)";
  snippetsSection.style.borderRadius = "5px";
  snippetsSection.style.padding = "0.5em";
  const snippetsSummary = snippetsSection.createEl("summary");
  snippetsSummary.style.cursor = "pointer";
  snippetsSummary.style.fontWeight = "bold";
  snippetsSummary.innerText = t("Manage Snippets");
  snippetsSummary.style.outline = "none";
  const snippetsContainer = snippetsSection.createDiv();
  snippetsContainer.style.marginTop = "10px";
  snippetsContainer.style.paddingLeft = "5px";
  snippetsContainer.style.borderLeft = "2px solid var(--background-modifier-border)";
  snippetsContainer.addClass("ms-manage-snippets-container");
  renderSnippetsList(snippetsContainer, manager);
  containerEl.appendChild(snippetsSection);
  new import_obsidian11.Setting(containerEl).setName(t("Glass menu effect")).setDesc(
    t("Choose to change the background from the secondary background color of your theme to a glass background.")
  ).addToggle((toggle) => {
    toggle.setValue(settings.aestheticStyle).onChange(async (value) => {
      settings.aestheticStyle = value;
      await manager.saveSettings();
    });
  });
  new import_obsidian11.Setting(containerEl).setName(t("Auto open new snippet")).setDesc(
    t("Choose whether or not to open CSS snippet files immeditaley after creating them. It will open in your default app.")
  ).addToggle((toggle) => {
    toggle.setValue(settings.openSnippetFile).onChange(async (value) => {
      settings.openSnippetFile = value;
      await manager.saveSettings();
    });
  });
  new import_obsidian11.Setting(containerEl).setName(t("Set new snippet status")).setDesc(
    t("Choose whether or not to have newly created CSS snippet files toggled on automatically upon creation.")
  ).addToggle((toggle) => {
    toggle.setValue(settings.snippetEnabledStatus).onChange(async (value) => {
      settings.snippetEnabledStatus = value;
      await manager.saveSettings();
    });
  });
  const stylingTemplateSetting = new import_obsidian11.Setting(containerEl);
  stylingTemplateSetting.settingEl.setAttribute(
    "style",
    "display: grid; grid-template-columns: 1fr;"
  );
  stylingTemplateSetting.setName(t("CSS snippet template")).setDesc(
    t("Set default CSS styling as a template for new CSS files you choose to create.")
  );
  const stylingTemplateContent = new import_obsidian11.TextAreaComponent(
    stylingTemplateSetting.controlEl
  );
  setAttributes(stylingTemplateContent.inputEl, {
    style: "margin-top: 12px; width: 100%;  height: 32vh;",
    class: "ms-css-editor"
  });
  stylingTemplateContent.setValue(settings.stylingTemplate).onChange(async (value) => {
    settings.stylingTemplate = value;
    await manager.saveSettings();
  });
}
function renderSnippetsList(containerEl, manager) {
  containerEl.empty();
  const app = manager.app;
  const customCss = app.customCss;
  const currentSnippets = customCss.snippets;
  if (currentSnippets.length === 0) {
    containerEl.createEl("p", { text: t("No CSS snippets found.") });
    return;
  }
  currentSnippets.forEach((snippet) => {
    new import_obsidian11.Setting(containerEl).setName(snippet).addToggle((toggle) => {
      toggle.setValue(customCss.enabledSnippets.has(snippet)).onChange((value) => {
        customCss.setCssEnabledStatus(snippet, value);
      });
    });
  });
  const buttonContainer = containerEl.createDiv();
  buttonContainer.addClass("ms-reload-container");
  new import_obsidian11.Setting(buttonContainer).addButton((button) => button.setButtonText(t("Reload Snippets")).onClick(() => {
    customCss.requestLoadSnippets();
    renderSnippetsList(containerEl, manager);
  }));
}

// src/headings/manager.ts
var import_obsidian17 = require("obsidian");

// src/utils/numbering-tokens.ts
var chineseNumbers = ["\u96F6", "\u4E00", "\u4E8C", "\u4E09", "\u56DB", "\u4E94", "\u516D", "\u4E03", "\u516B", "\u4E5D", "\u5341"];
var circledNumbers = ["\u24EA", "\u2460", "\u2461", "\u2462", "\u2463", "\u2464", "\u2465", "\u2466", "\u2467", "\u2468", "\u2469", "\u246A", "\u246B", "\u246C", "\u246D", "\u246E", "\u246F", "\u2470", "\u2471", "\u2472", "\u2473"];
function firstNumberingTokenInStyle(style, startValue) {
  const startNum = parseInt(startValue);
  const isNumericStart = !isNaN(startNum);
  switch (style) {
    case "1":
      return { style: "1", value: startNum };
    case "A":
      if (isNumericStart) {
        if (startNum === 0)
          return { style: "A", value: "&" };
        if (startNum > 0)
          return { style: "A", value: String.fromCharCode("A".charCodeAt(0) + startNum - 1) };
        return { style: "A", value: "A" };
      }
      return { style: "A", value: startValue || "A" };
    case "a":
      if (isNumericStart) {
        if (startNum === 0)
          return { style: "a", value: "&" };
        if (startNum > 0)
          return { style: "a", value: String.fromCharCode("a".charCodeAt(0) + startNum - 1) };
        return { style: "a", value: "a" };
      }
      return { style: "a", value: startValue || "a" };
    case "\u4E00":
      if (isNumericStart) {
        if (startNum >= 0 && startNum < chineseNumbers.length) {
          return { style: "\u4E00", value: chineseNumbers[startNum] };
        }
        if (startNum >= chineseNumbers.length) {
          return { style: "\u4E00", value: String(startNum) };
        }
      }
      return { style: "\u4E00", value: startValue || "\u4E00" };
    case "\u2460":
      if (isNumericStart) {
        if (startNum >= 0 && startNum < circledNumbers.length) {
          return { style: "\u2460", value: circledNumbers[startNum] };
        }
        if (startNum >= circledNumbers.length) {
          return { style: "\u2460", value: String(startNum) };
        }
      }
      return { style: "\u2460", value: startValue || "\u2460" };
  }
  return { style: "1", value: 1 };
}
function nextNumberingToken(t2) {
  switch (t2.style) {
    case "1":
      return { style: "1", value: t2.value + 1 };
    case "A":
      if (t2.value === "&")
        return { style: "A", value: "A" };
      if (t2.value === "Z")
        return { style: "A", value: "A" };
      return { style: "A", value: String.fromCharCode(t2.value.charCodeAt(0) + 1) };
    case "a":
      if (t2.value === "&")
        return { style: "a", value: "a" };
      if (t2.value === "z")
        return { style: "a", value: "a" };
      return { style: "a", value: String.fromCharCode(t2.value.charCodeAt(0) + 1) };
    case "\u4E00":
      const cnIndex = chineseNumbers.indexOf(t2.value);
      if (cnIndex > -1 && cnIndex < chineseNumbers.length - 1) {
        return { style: "\u4E00", value: chineseNumbers[cnIndex + 1] };
      }
      if (cnIndex === chineseNumbers.length - 1)
        return { style: "\u4E00", value: "11" };
      const cnNum = parseInt(t2.value);
      if (!isNaN(cnNum))
        return { style: "\u4E00", value: String(cnNum + 1) };
      return { style: "\u4E00", value: "\u4E00" };
    case "\u2460":
      const cIndex = circledNumbers.indexOf(t2.value);
      if (cIndex > -1 && cIndex < circledNumbers.length - 1) {
        return { style: "\u2460", value: circledNumbers[cIndex + 1] };
      }
      if (cIndex === circledNumbers.length - 1)
        return { style: "\u2460", value: "21" };
      const cNum = parseInt(t2.value);
      if (!isNaN(cNum))
        return { style: "\u2460", value: String(cNum + 1) };
      return { style: "\u2460", value: "\u2460" };
  }
  return { style: "1", value: t2.value + 1 };
}
function printableNumberingToken(t2) {
  if (t2.style === "1")
    return t2.value.toString();
  return t2.value;
}
function makeNumberingString(numberingStack, separators) {
  let numberingString = "";
  for (let i = 0; i < numberingStack.length; i++) {
    if (i === 0) {
      numberingString += " ";
    } else {
      numberingString += separators[i] || "";
    }
    numberingString += printableNumberingToken(numberingStack[i]);
  }
  return numberingString;
}

// src/utils/text-processing.ts
function getRegexForHeaderString(flags) {
  return /^\s{0,3}#+( )?([0-9a-zA-Z\u4e00-\u9fa5\u2460-\u2473&]+[.:\-]+( )?)*([0-9a-zA-Z\u4e00-\u9fa5\u2460-\u2473&]+)?( )?[.:\-]?( )+/g;
}
function findRangeInHeaderString(lineText, lineNumber) {
  const regex = getRegexForHeaderString();
  if (!lineText)
    return void 0;
  const matches = lineText.match(regex);
  if (matches && matches.length !== 1) {
    return void 0;
  }
  const match = matches ? matches[0] : "";
  return {
    from: { line: lineNumber, ch: 0 },
    to: { line: lineNumber, ch: match.length }
  };
}
function findHeadingPrefixRange(editor, heading) {
  const lineNumber = heading.position.start.line;
  const lineText = editor.getLine(lineNumber);
  return findRangeInHeaderString(lineText, lineNumber);
}
function makeHeadingHashString(editor, heading) {
  const regex = /^\s{0,4}#+/g;
  const headingLineString = editor.getLine(heading.position.start.line);
  if (!headingLineString)
    return void 0;
  const matches = headingLineString.match(regex);
  if (!matches || matches.length !== 1)
    return void 0;
  return matches[0].trimLeft();
}
function replaceRangeEconomically(editor, changes, range, text) {
  const previousText = editor.getRange(range.from, range.to);
  if (previousText !== text) {
    changes.push({
      from: range.from,
      to: range.to,
      text
    });
  }
}
function restoreCursor(editor, cursor) {
  const lineCount = editor.lineCount();
  if (cursor.line < lineCount) {
    const lineLength = editor.getLine(cursor.line).length;
    if (cursor.ch <= lineLength) {
      editor.setCursor(cursor);
    } else {
      editor.setCursor(cursor.line, lineLength);
    }
  }
}
function getCodeBlockRanges(data) {
  if (!data || !data.sections)
    return [];
  return data.sections.filter((section) => section.type === "code").map((section) => ({
    start: section.position.start.line,
    end: section.position.end.line
  }));
}
function isLineIgnored(lineNum, lineText, codeRanges) {
  for (const range of codeRanges) {
    if (lineNum >= range.start && lineNum <= range.end)
      return true;
  }
  if (/^\s*\|/.test(lineText))
    return true;
  return false;
}

// src/utils/frontmatter.ts
var import_obsidian12 = require("obsidian");
function parseHeadingsFrontMatter(fm, defaultSettings) {
  const settings = Object.assign({}, defaultSettings);
  if (!fm)
    return settings;
  const entry = (0, import_obsidian12.parseFrontMatterEntry)(fm, "number headings");
  if (entry) {
    const parts = String(entry).split(",").map((p) => p.trim()).filter((p) => p.length > 0);
    const rangeRegex = /^\d-\d$/;
    const stylesRegex = /^[0-9a-zA-Z\u4e00-\u9fa5\u2460-\u2473&]{6}$/;
    const startValuesRegex = /^\d{6}$/;
    const separatorsRegex = /^[-:.]{5}$/;
    let rangeFound = false;
    let stylesFound = false;
    let separatorsFound = false;
    let startValuesFound = false;
    for (const part of parts) {
      if (part === "auto")
        settings.auto = true;
      else if (part === "off")
        settings.enabled = false;
      else if (part.startsWith("first-level")) {
        const n = parseInt(part.substring("first-level".length + 1));
        if (!isNaN(n) && n >= 1 && n <= 6)
          settings.firstLevel = n;
      } else if (part.startsWith("max")) {
        const n = parseInt(part.substring("max".length + 1));
        if (!isNaN(n) && n >= 1 && n <= 6)
          settings.maxLevel = n;
      } else if (!rangeFound && rangeRegex.test(part)) {
        const [min, max] = part.split("-").map(Number);
        if (!isNaN(min) && !isNaN(max)) {
          settings.firstLevel = min;
          settings.maxLevel = max;
          rangeFound = true;
        }
      } else if (!stylesFound && stylesRegex.test(part)) {
        settings.headingStyles = part.split("");
        stylesFound = true;
      } else if (!startValuesFound && startValuesRegex.test(part)) {
        settings.headingStartValues = part.split("");
        startValuesFound = true;
      } else if (!separatorsFound && separatorsRegex.test(part)) {
        const seps = part.split("");
        settings.headingSeparators = ["", seps[0], seps[1], seps[2], seps[3], seps[4]];
        separatorsFound = true;
      } else if (part.startsWith("skip")) {
      }
    }
  }
  return settings;
}
function serializeHeadingsFrontMatter(settings) {
  if (!settings.enabled)
    return "off";
  const parts = [];
  if (settings.auto)
    parts.push("auto");
  if (settings.firstLevel !== 1 || settings.maxLevel !== 6) {
    parts.push(`${settings.firstLevel}-${settings.maxLevel}`);
  } else {
    parts.push("1-6");
  }
  if (settings.headingStyles && settings.headingStyles.length >= 6) {
    parts.push(settings.headingStyles.join(""));
  } else {
    parts.push("1aA\u4E00\u24601");
  }
  if (settings.headingSeparators && settings.headingSeparators.length >= 6) {
    parts.push(settings.headingSeparators.slice(1, 6).join(""));
  } else {
    parts.push(DEFAULT_MY_HEADINGS_SETTINGS.headingSeparators.slice(1, 6).join(""));
  }
  if (settings.headingStartValues && settings.headingStartValues.length >= 6) {
    parts.push(settings.headingStartValues.join(""));
  } else {
    parts.push("011111");
  }
  return parts.join(", ");
}
function parseFormulasFrontMatter(fm, defaultSettings) {
  const settings = Object.assign({}, defaultSettings);
  if (!fm)
    return settings;
  const entry = (0, import_obsidian12.parseFrontMatterEntry)(fm, "number formulas");
  if (entry) {
    const parts = String(entry).split(",").map((p) => p.trim());
    for (const part of parts) {
      if (part === "auto")
        settings.auto = true;
      else if (part === "off")
        settings.enabled = false;
      else if (part === "continuous")
        settings.mode = "continuous";
      else if (part.startsWith("heading-based")) {
        settings.mode = "heading-based";
        const match = part.match(/heading-based\((\d+)\)/);
        if (match && match[1]) {
          const depth = parseInt(match[1]);
          if (!isNaN(depth) && depth >= 1 && depth <= 6) {
            settings.maxDepth = depth;
          }
        }
      }
    }
  }
  return settings;
}
function serializeFormulasFrontMatter(settings) {
  if (!settings.enabled)
    return "off";
  const parts = [];
  if (settings.auto)
    parts.push("auto");
  if (settings.mode === "heading-based") {
    const depth = settings.maxDepth || 4;
    parts.push(`heading-based(${depth})`);
  } else {
    parts.push("continuous");
  }
  return parts.join(", ");
}
async function saveSettingsToFrontMatter(app, file, headingsSettings, formulasSettings) {
  await app.fileManager.processFrontMatter(file, (fm) => {
    if (headingsSettings) {
      fm["number headings"] = serializeHeadingsFrontMatter(headingsSettings);
    }
    if (formulasSettings) {
      fm["number formulas"] = serializeFormulasFrontMatter(formulasSettings);
    }
  });
}

// src/headings/modal.ts
var import_obsidian13 = require("obsidian");
var HeadingsControlModal = class extends import_obsidian13.Modal {
  constructor(app, plugin, file) {
    super(app);
    this.plugin = plugin;
    this.file = file;
    const cache = app.metadataCache.getFileCache(file);
    const fm = cache ? cache.frontmatter : void 0;
    this.settings = JSON.parse(JSON.stringify(parseHeadingsFrontMatter(fm, this.plugin.settings.myHeadings)));
  }
  onOpen() {
    var _a, _b, _c;
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: t("Configure Headings") });
    new import_obsidian13.Setting(contentEl).setName(t("Auto Number Headings")).setDesc(t("Automatically number headings on blur")).addToggle((toggle) => toggle.setValue(this.settings.auto).onChange((v) => this.settings.auto = v));
    new import_obsidian13.Setting(contentEl).setName(t("First Level")).setDesc(t("Starting heading level for numbering")).addSlider((slider) => slider.setLimits(1, 6, 1).setValue(this.settings.firstLevel).setDynamicTooltip().onChange((v) => this.settings.firstLevel = v));
    new import_obsidian13.Setting(contentEl).setName(t("Max Level")).setDesc(t("Maximum heading level for numbering")).addSlider((slider) => slider.setLimits(1, 6, 1).setValue(this.settings.maxLevel).setDynamicTooltip().onChange((v) => this.settings.maxLevel = v));
    const stylesSetting = new import_obsidian13.Setting(contentEl).setName(t("Heading Styles")).setDesc(t("Numbering style for each level (1-6)")).setClass("heading-styles-setting");
    const stylesContainer = createDiv({ cls: "heading-styles-container" });
    stylesSetting.settingEl.appendChild(stylesContainer);
    const styleOptions = ["1", "a", "A", "\u4E00", "\u2460"];
    for (let i = 0; i < 6; i++) {
      const wrapper = stylesContainer.createDiv({ cls: "style-item" });
      wrapper.createEl("label", { text: `H${i + 1}: ` });
      const select = wrapper.createEl("select");
      styleOptions.forEach((option) => {
        select.createEl("option", { text: option, value: option });
      });
      select.value = ((_a = this.settings.headingStyles) == null ? void 0 : _a[i]) || DEFAULT_HEADING_STYLES[i];
      select.onchange = () => {
        if (!this.settings.headingStyles)
          this.settings.headingStyles = [...DEFAULT_HEADING_STYLES];
        this.settings.headingStyles[i] = select.value;
      };
    }
    const separatorsSetting = new import_obsidian13.Setting(contentEl).setName(t("Heading Separators")).setDesc(t("Separator after each level (empty for H1, then 2-6)")).setClass("heading-separators-setting");
    const separatorsContainer = createDiv({ cls: "heading-separators-container" });
    separatorsSetting.settingEl.appendChild(separatorsContainer);
    for (let i = 1; i < 6; i++) {
      const wrapper = separatorsContainer.createDiv({ cls: "separator-item" });
      wrapper.createEl("label", { text: `H${i + 1}: ` });
      const input = wrapper.createEl("input", { type: "text" });
      input.value = ((_b = this.settings.headingSeparators) == null ? void 0 : _b[i]) || DEFAULT_HEADING_SEPARATORS[i];
      input.maxLength = 1;
      input.style.width = "2em";
      input.oninput = () => {
        if (!this.settings.headingSeparators)
          this.settings.headingSeparators = [...DEFAULT_HEADING_SEPARATORS];
        this.settings.headingSeparators[i] = input.value || "";
      };
    }
    const startValuesSetting = new import_obsidian13.Setting(contentEl).setName(t("Start Values")).setDesc(t("Starting number for each level")).setClass("heading-start-values-setting");
    const startValuesContainer = createDiv({ cls: "heading-start-values-container" });
    startValuesSetting.settingEl.appendChild(startValuesContainer);
    for (let i = 0; i < 6; i++) {
      const wrapper = startValuesContainer.createDiv({ cls: "start-value-item" });
      wrapper.createEl("label", { text: `H${i + 1}: ` });
      const input = wrapper.createEl("input", { type: "text" });
      input.value = ((_c = this.settings.headingStartValues) == null ? void 0 : _c[i]) || DEFAULT_HEADING_START_VALUES[i];
      input.maxLength = 1;
      input.style.width = "2em";
      input.oninput = () => {
        if (!this.settings.headingStartValues)
          this.settings.headingStartValues = [...DEFAULT_HEADING_START_VALUES];
        this.settings.headingStartValues[i] = input.value || "1";
      };
    }
    const buttonContainer = contentEl.createDiv({ cls: "modal-button-container" });
    new import_obsidian13.Setting(buttonContainer).addButton((btn) => btn.setButtonText(t("Apply Now")).setTooltip(t("Apply numbering once without saving to frontmatter")).onClick(() => {
      this.applyNumbering();
      this.close();
    })).addButton((btn) => btn.setButtonText(t("Save to Frontmatter")).setTooltip(t("Save settings to frontmatter and apply")).setCta().onClick(async () => {
      await this.saveAndApply();
      this.close();
    })).addButton((btn) => btn.setButtonText(t("Remove Numbering")).setWarning().onClick(() => {
      this.plugin.headingsManager.removeNumbering();
      new import_obsidian13.Notice(t("Heading numbering removed"));
      this.close();
    }));
  }
  applyNumbering() {
    const info = this.plugin.headingsManager.getActiveViewInfo();
    if (!info)
      return;
    const { data, editor } = info;
    const originalSettings = this.plugin.settings.myHeadings;
    this.plugin.settings.myHeadings = this.settings;
    this.plugin.headingsManager.updateNumbering(true, true);
    this.plugin.settings.myHeadings = originalSettings;
    new import_obsidian13.Notice(t("Numbering applied (one-time)"));
  }
  async saveAndApply() {
    await saveSettingsToFrontMatter(this.app, this.file, this.settings);
    await new Promise((resolve) => setTimeout(resolve, 100));
    this.plugin.headingsManager.updateNumbering(true, true);
    new import_obsidian13.Notice(t("Settings saved to frontmatter and applied"));
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/headings/shifter/manager.ts
var import_obsidian16 = require("obsidian");
var import_state = require("@codemirror/state");
var import_view = require("@codemirror/view");

// src/headings/shifter/features/shift.ts
var import_obsidian14 = require("obsidian");

// src/headings/shifter/utils/constants.ts
var TABSIZE = 4;

// src/headings/shifter/utils/range.ts
var setMin = (prev, cur) => {
  if (prev === void 0 || prev !== void 0 && cur < prev) {
    return cur;
  }
  return prev;
};
var setMax = (prev, cur) => {
  if (prev === void 0 || prev !== void 0 && cur > prev) {
    return cur;
  }
  return prev;
};
var createRange = (start, num) => Array.from(Array(num), (v, k) => k + start);

// src/headings/shifter/utils/markdown.ts
var checkHeading = (content) => {
  const match = content.match(/^(#+) /);
  if (!match || !match[1])
    return 0;
  return match[1].length;
};
var checkFence = (content) => {
  const backticks = content.match(/^(`{3,})/);
  if (backticks == null ? void 0 : backticks[1])
    return { fenceType: "`", fenceNum: backticks[1].length };
  const tildes = content.match(/^(~{3,})/);
  if (tildes == null ? void 0 : tildes[1])
    return { fenceType: "~", fenceNum: tildes[1].length };
  return null;
};
var getFenceStatus = (prev, current) => {
  if (!current)
    return prev;
  if (!prev)
    return current;
  if (current.fenceType === prev.fenceType && current.fenceNum >= prev.fenceNum) {
    return null;
  }
  return prev;
};
var getHeadingLines = (editor, from, to, options) => {
  const headingLines = [];
  let minHeading;
  let maxHeading;
  let fence = null;
  for (let line = Math.min(from, to); line <= Math.max(from, to); line++) {
    fence = getFenceStatus(fence, checkFence(editor.getLine(line)));
    if (fence)
      continue;
    const heading = checkHeading(editor.getLine(line));
    if ((options == null ? void 0 : options.includesNoHeadingsLine) || heading > 0) {
      headingLines.push(line);
      minHeading = setMin(minHeading, heading);
      maxHeading = setMax(maxHeading, heading);
    }
  }
  return { headingLines, minHeading, maxHeading };
};
var getPreviousHeading = (editor, from) => {
  let fence = null;
  const start = from > 0 ? from - 1 : 0;
  for (let line = start; line >= 0; line--) {
    fence = getFenceStatus(fence, checkFence(editor.getLine(line)));
    if (fence)
      continue;
    if (checkHeading(editor.getLine(line)) > 0) {
      return line;
    }
  }
  return void 0;
};
var replaceFunc = (str, regExp) => {
  try {
    const replaced = str.replace(regExp, "$1");
    if (replaced !== str) {
      return replaced;
    }
  } catch (error) {
    console.error(error);
  }
  return void 0;
};
var removeUsingRegexpStrings = (str, regExpStrings) => {
  var _a, _b;
  let removed = str;
  for (const regExpStr of (_a = regExpStrings.beginning) != null ? _a : []) {
    const regExp = new RegExp(`^\\s*${regExpStr}(.*)`);
    const result = replaceFunc(removed, regExp);
    if (result !== void 0) {
      removed = result;
      break;
    }
  }
  for (const regExpStr of (_b = regExpStrings.surrounding) != null ? _b : []) {
    const regExp = new RegExp(`${regExpStr}(.*)${regExpStr}`);
    const result = replaceFunc(removed, regExp);
    if (result !== void 0) {
      removed = result;
      break;
    }
  }
  return removed;
};
var countIndentLevel = (line, tabSize = TABSIZE) => {
  var _a;
  const leadingContent = (_a = line.match(/^(\s*)/)) == null ? void 0 : _a[0];
  if (!leadingContent)
    return 0;
  const tabCount = (leadingContent.match(/\t/g) || []).length;
  const spaceCount = (leadingContent.match(/ /g) || []).length;
  return tabCount + Math.floor(spaceCount / tabSize);
};
var getListChildrenLines = (editor, {
  parentLineNumber,
  tabSize
}) => {
  const lineNumbers = [];
  const startLine = editor.getLine(parentLineNumber);
  const prevParentIndentLevel = countIndentLevel(startLine, tabSize);
  for (let lineN = parentLineNumber + 1; lineN < editor.lineCount(); lineN++) {
    const line = editor.getLine(lineN);
    const indentLevel = countIndentLevel(line, tabSize);
    const isBulleted = /^\s*[-*]\s+/.test(line);
    const isNumbered = /^\s*\d+\.\s+/.test(line);
    if (!isBulleted && !isNumbered)
      break;
    if (indentLevel <= prevParentIndentLevel)
      break;
    lineNumbers.push(lineN);
  }
  return lineNumbers;
};

// src/headings/shifter/utils/editorChange.ts
var composeLineChanges = (editor, lineNumbers, changeCallback, settings) => {
  const editorChange = [];
  for (const line of lineNumbers) {
    const shifted = changeCallback(editor.getLine(line), settings);
    editorChange.push({
      text: shifted,
      from: { line, ch: 0 },
      to: {
        line,
        ch: editor.getLine(line).length
      }
    });
  }
  return editorChange;
};
var createListIndentChanges = (editor, {
  parentLineNumber,
  parentIndentLevel,
  tabSize = TABSIZE
}) => {
  const parentLine = editor.getLine(parentLineNumber);
  const prevParentIndentLevel = countIndentLevel(parentLine, tabSize);
  const childrenNumbers = getListChildrenLines(editor, {
    parentLineNumber,
    tabSize
  });
  const indentDelta = parentIndentLevel - prevParentIndentLevel;
  const changes = [];
  childrenNumbers.forEach((lineNumber) => {
    var _a, _b, _c, _d;
    const line = editor.getLine(lineNumber);
    const newIndentLevel = Math.max(
      countIndentLevel(line, tabSize) + indentDelta,
      0
    );
    const match = line.match(
      /^(?<whitespace>\s*)(?<bullet>[-*]\s*|(?<numbered>\d+\.\s*))(?<heading>#+\s*)?(?<content>.*)$/
    );
    const tabsMarkers = "	".repeat(newIndentLevel);
    const bulletMarkers = ((_a = match == null ? void 0 : match.groups) == null ? void 0 : _a.bullet) || "";
    const numberedMarkers = ((_b = match == null ? void 0 : match.groups) == null ? void 0 : _b.numbered) || "";
    const listMarker = bulletMarkers || numberedMarkers;
    const headingMarkers = ((_c = match == null ? void 0 : match.groups) == null ? void 0 : _c.heading) ? "#".repeat(Math.min(newIndentLevel + 1, 6)) + " " : "";
    const content = ((_d = match == null ? void 0 : match.groups) == null ? void 0 : _d.content) || "";
    const newLine = `${tabsMarkers}${listMarker}${headingMarkers}${content}`;
    changes.push({
      text: newLine,
      from: { line: lineNumber, ch: 0 },
      to: { line: lineNumber, ch: line.length }
    });
  });
  return changes;
};

// src/headings/shifter/utils/regExp.ts
var RegExpExample = {
  beginning: {
    ol: String.raw`\d+\. `,
    ul: String.raw`(?:\-|\*) `
  },
  surrounding: {
    // Only one match
    italic: String.raw`(?:(?<!\*)\*(?!\*)|(?<!_)_(?!_))`,
    // Same
    // bold: String.raw`(?:\*\*|__)`,
    bold: String.raw`(?:(?<!\*)\*\*(?!\*)|(?<!_)__(?!_))`
  }
};

// src/headings/shifter/features/apply.ts
var applyHeading = (chunk, headingSize, settings) => {
  var _a;
  const extractRegExp = (settingObj, regExpObj) => {
    return Object.entries(settingObj != null ? settingObj : {}).flatMap(([k, v]) => {
      var _a2;
      if (Array.isArray(v)) {
        return v;
      }
      if (k in regExpObj && v === true) {
        return [(_a2 = regExpObj[k]) != null ? _a2 : []];
      }
      return [];
    });
  };
  const bulletRegExp = /\s*(- \[.+\]|-|\*|[0-9]+)\s+/;
  const headingRegExp = /#+\s+/;
  const isBullet = ((_a = settings == null ? void 0 : settings.list) == null ? void 0 : _a.childrenBehavior) === "sync with headings" && bulletRegExp.test(chunk);
  let removed = chunk;
  if (!checkHeading(chunk)) {
    removed = (settings == null ? void 0 : settings.styleToRemove) ? removeUsingRegexpStrings(chunk, {
      beginning: extractRegExp(
        {
          ...settings.styleToRemove.beginning,
          ul: !isBullet && settings.styleToRemove.beginning.ul
        },
        RegExpExample.beginning
      ),
      surrounding: extractRegExp(
        settings.styleToRemove.surrounding,
        RegExpExample.surrounding
      )
    }) : chunk;
  }
  const leadingMarkersRegExp = isBullet ? new RegExp(
    `^(?:${bulletRegExp.source}${headingRegExp.source}|${bulletRegExp.source})`
  ) : new RegExp(`^${headingRegExp.source}`);
  let capturedBullet = "-";
  const principleText = removed.replace(leadingMarkersRegExp, (match, p1) => {
    if (isBullet && p1) {
      capturedBullet = p1;
      const m = match.match(bulletRegExp);
      if (m && m[1])
        capturedBullet = m[1];
    }
    return "";
  });
  const bulletMarkers = `${"	".repeat(Math.max(headingSize - 1, 0))}${capturedBullet} `;
  const headingMarkers = "#".repeat(Math.max(headingSize, 0)) + (headingSize > 0 ? " " : "");
  const leadingMarkers = isBullet ? `${bulletMarkers}${headingMarkers}` : headingMarkers;
  return leadingMarkers + principleText;
};
var createListIndentChangesByListBehavior = (editor, {
  listBehavior,
  tabSize = TABSIZE,
  parentIndentLevel,
  parentLineNumber
}) => {
  if (listBehavior !== "outdent to zero" && listBehavior !== "sync with headings") {
    return [];
  }
  const parentIndentLevelByBehavior = listBehavior === "sync with headings" ? (
    // follow parent
    Math.max(0, parentIndentLevel)
  ) : (
    // Force the next line of parent to be 0
    -countIndentLevel(editor.getLine(parentLineNumber + 1), tabSize) + countIndentLevel(editor.getLine(parentLineNumber), tabSize)
  );
  const indentChanges = createListIndentChanges(editor, {
    parentLineNumber,
    parentIndentLevel: parentIndentLevelByBehavior,
    tabSize
  });
  return indentChanges;
};
var ApplyHeading = class {
  constructor(settings, headingSize) {
    this.editorCallback = (editor) => {
      var _a;
      const lines = createRange(
        editor.getCursor("from").line,
        editor.getCursor("to").line - editor.getCursor("from").line + 1
      );
      const isOneLine = editor.getCursor("from").line === editor.getCursor("to").line;
      const lastHeaderLineNumber = (_a = lines[lines.length - 1]) != null ? _a : 0;
      const headingsChanges = composeLineChanges(
        editor,
        lines,
        (chunk) => applyHeading(chunk, this.headingSize, this.settings)
      );
      const indentChanges = createListIndentChangesByListBehavior(editor, {
        parentIndentLevel: this.headingSize - 1,
        tabSize: this.settings.editor.tabSize,
        listBehavior: this.settings.list.childrenBehavior,
        parentLineNumber: lastHeaderLineNumber
      });
      editor.transaction({
        changes: [...headingsChanges, ...indentChanges]
      });
      if (isOneLine) {
        editor.setCursor(editor.getCursor("anchor").line);
      }
      return true;
    };
    this.createCommand = () => {
      return {
        id: `heading-shifter-apply-heading-${this.headingSize}`,
        name: `${t("Apply Heading")} ${this.headingSize}`,
        icon: `headingShifter_heading${this.headingSize}`,
        editorCallback: this.editorCallback
      };
    };
    this.settings = settings;
    this.headingSize = headingSize;
  }
};

// src/headings/shifter/features/shift.ts
var shiftHeading = (chunk, dir, settings) => {
  const heading = checkHeading(chunk);
  return applyHeading(chunk, heading + dir, settings);
};
var increaseHeading = (chunk, settings) => {
  return shiftHeading(chunk, 1, settings);
};
var decreaseHeading = (chunk, settings) => {
  return shiftHeading(chunk, -1, settings);
};
var IncreaseHeading = class {
  constructor(settings, includesNoHeadingsLine) {
    this.editorCallback = (editor) => {
      const { headingLines, maxHeading } = getHeadingLines(
        editor,
        editor.getCursor("from").line,
        editor.getCursor("to").line,
        {
          includesNoHeadingsLine: this.includesNoHeadingsLine
        }
      );
      if (maxHeading !== void 0 && maxHeading >= 6) {
        new import_obsidian14.Notice("Cannot Increase (contains more than Heading 6)");
        return true;
      }
      const isOneLine = editor.getCursor("from").line === editor.getCursor("to").line;
      const editorChange = composeLineChanges(
        editor,
        headingLines,
        increaseHeading,
        this.settings
      );
      editor.transaction({
        changes: editorChange
      });
      if (isOneLine) {
        editor.setCursor(editor.getCursor("anchor").line);
      }
      return editorChange.length ? true : false;
    };
    this.createCommand = () => {
      return {
        id: `heading-shifter-increase-heading${this.includesNoHeadingsLine ? "-forced" : ""}`,
        name: this.includesNoHeadingsLine ? t("Increase Headings (forced)") : t("Increase Headings"),
        icon: "headingShifter_increaseIcon",
        // Should check if icon exists or use default
        editorCallback: this.editorCallback
      };
    };
    this.check = (editor) => {
      const { maxHeading } = getHeadingLines(
        editor,
        editor.getCursor("from").line,
        editor.getCursor("to").line
      );
      if (maxHeading === void 0)
        return false;
      return this.settings.overrideTab;
    };
    this.settings = settings;
    this.includesNoHeadingsLine = includesNoHeadingsLine;
  }
};
var DecreaseHeading = class {
  constructor(settings) {
    this.editorCallback = (editor) => {
      const { headingLines, minHeading } = getHeadingLines(
        editor,
        editor.getCursor("from").line,
        editor.getCursor("to").line
      );
      if (minHeading !== void 0 && minHeading <= Number(this.settings.limitHeadingFrom)) {
        new import_obsidian14.Notice(
          `Cannot Decrease (contains less than Heading${Number(
            this.settings.limitHeadingFrom
          )})`
        );
        return true;
      }
      const isOneLine = editor.getCursor("from").line === editor.getCursor("to").line;
      const editorChange = composeLineChanges(
        editor,
        headingLines,
        decreaseHeading,
        this.settings
      );
      editor.transaction({
        changes: editorChange
      });
      if (isOneLine) {
        editor.setCursor(editor.getCursor("anchor").line);
      }
      return editorChange.length ? true : false;
    };
    this.createCommand = () => {
      return {
        id: "heading-shifter-decrease-heading",
        name: t("Decrease Headings"),
        icon: "headingShifter_decreaseIcon",
        editorCallback: this.editorCallback
      };
    };
    this.check = (editor) => {
      const { maxHeading } = getHeadingLines(
        editor,
        editor.getCursor("from").line,
        editor.getCursor("to").line
      );
      if (maxHeading === void 0)
        return false;
      return this.settings.overrideTab;
    };
    this.settings = settings;
  }
};

// src/headings/shifter/features/insert.ts
var import_obsidian15 = require("obsidian");
var InsertHeadingAtCurrentLevel = class {
  constructor(settings) {
    this.editorCallback = (editor) => {
      const cursorLine = editor.getCursor("from").line;
      const lastHeadingLine = getPreviousHeading(editor, cursorLine);
      const headingLevel = lastHeadingLine !== void 0 ? checkHeading(editor.getLine(lastHeadingLine)) : 0;
      const targetHeadingLevel = headingLevel;
      const headingChanges = composeLineChanges(
        editor,
        [cursorLine],
        (chunk) => applyHeading(chunk, targetHeadingLevel, this.settings)
      );
      const indentChanges = createListIndentChangesByListBehavior(editor, {
        parentIndentLevel: targetHeadingLevel - 1,
        tabSize: this.settings.editor.tabSize,
        listBehavior: this.settings.list.childrenBehavior,
        parentLineNumber: cursorLine
      });
      editor.transaction({
        changes: [...headingChanges, ...indentChanges]
      });
      editor.setCursor(editor.getCursor().line);
      return true;
    };
    this.createCommand = () => {
      return {
        id: `heading-shifter-insert-heading-current`,
        name: t("Insert Heading at current level"),
        icon: `headingShifter_heading`,
        editorCallback: this.editorCallback
      };
    };
    this.settings = settings;
  }
};
var InsertHeadingAtDeeperLevel = class {
  constructor(settings) {
    this.editorCallback = (editor) => {
      const cursorLine = editor.getCursor("from").line;
      const lastHeadingLine = getPreviousHeading(editor, cursorLine);
      const headingLevel = lastHeadingLine ? checkHeading(editor.getLine(lastHeadingLine)) : 0;
      if (headingLevel + 1 > 6) {
        new import_obsidian15.Notice("Cannot Increase (contains more than Heading 6)");
        return true;
      }
      const targetHeadingLevel = headingLevel + 1;
      const headingChanges = composeLineChanges(
        editor,
        [cursorLine],
        (chunk) => applyHeading(chunk, targetHeadingLevel, this.settings)
      );
      const indentChanges = createListIndentChangesByListBehavior(editor, {
        parentIndentLevel: targetHeadingLevel - 1,
        tabSize: this.settings.editor.tabSize,
        listBehavior: this.settings.list.childrenBehavior,
        parentLineNumber: cursorLine
      });
      editor.transaction({
        changes: [...headingChanges, ...indentChanges]
      });
      editor.setCursor(editor.getCursor().line);
      return true;
    };
    this.createCommand = () => {
      return {
        id: `heading-shifter-insert-heading-deeper`,
        name: t("Insert Heading at one level deeper"),
        icon: `headingShifter_heading`,
        editorCallback: this.editorCallback
      };
    };
    this.settings = settings;
  }
};
var InsertHeadingAtHigherLevel = class {
  constructor(settings) {
    this.editorCallback = (editor) => {
      const cursorLine = editor.getCursor("from").line;
      const lastHeadingLine = getPreviousHeading(editor, cursorLine);
      const headingLevel = lastHeadingLine ? checkHeading(editor.getLine(lastHeadingLine)) : 0;
      const targetHeadingLevel = headingLevel - 1;
      const headingChanges = composeLineChanges(
        editor,
        [cursorLine],
        (chunk) => applyHeading(chunk, targetHeadingLevel, this.settings)
      );
      const indentChanges = createListIndentChangesByListBehavior(editor, {
        parentIndentLevel: targetHeadingLevel,
        tabSize: this.settings.editor.tabSize,
        listBehavior: this.settings.list.childrenBehavior,
        parentLineNumber: cursorLine
      });
      editor.transaction({
        changes: [...headingChanges, ...indentChanges]
      });
      editor.setCursor(editor.getCursor().line);
      return true;
    };
    this.createCommand = () => {
      return {
        id: `heading-shifter-insert-heading-higher`,
        name: t("Insert Heading at one level higher"),
        icon: `headingShifter_heading`,
        editorCallback: this.editorCallback
      };
    };
    this.settings = settings;
  }
};

// src/headings/shifter/manager.ts
var HEADINGS = [0, 1, 2, 3, 4, 5, 6];
var ShifterManager = class {
  constructor(app, plugin) {
    this.app = app;
    this.plugin = plugin;
  }
  onload() {
    this.addCommands();
  }
  addCommands() {
    const settings = this.plugin.settings.myHeadings;
    const increaseHeading2 = new IncreaseHeading(settings, false);
    const increaseHeadingForced = new IncreaseHeading(settings, true);
    const decreaseHeading2 = new DecreaseHeading(settings);
    const insertHeadingAtCurrentLabel = new InsertHeadingAtCurrentLevel(settings);
    const insertHeadingAtDeeperLevel = new InsertHeadingAtDeeperLevel(settings);
    const insertHeadingAtHigherLevel = new InsertHeadingAtHigherLevel(settings);
    HEADINGS.forEach((heading) => {
      const applyHeadingCmd = new ApplyHeading(settings, heading);
      this.plugin.addCommand({
        ...applyHeadingCmd.createCommand()
        // Unified naming: Use the ID from the command itself (e.g., 'shifter-apply-heading-0')
        // Obsidian will prefix with 'obsidian-assistant:' automatically.
      });
    });
    this.plugin.addCommand(increaseHeading2.createCommand());
    this.plugin.addCommand(increaseHeadingForced.createCommand());
    this.plugin.addCommand(decreaseHeading2.createCommand());
    this.plugin.addCommand(insertHeadingAtCurrentLabel.createCommand());
    this.plugin.addCommand(insertHeadingAtDeeperLevel.createCommand());
    this.plugin.addCommand(insertHeadingAtHigherLevel.createCommand());
    if (settings.overrideTab) {
      this.plugin.registerEditorExtension(
        import_state.Prec.high(
          import_view.keymap.of([
            {
              key: "Tab",
              run: this.createKeyMapRunCallback({
                check: increaseHeading2.check,
                run: increaseHeading2.editorCallback
              })
            }
          ])
        )
      );
      this.plugin.registerEditorExtension(
        import_state.Prec.high(
          import_view.keymap.of([
            {
              key: "s-Tab",
              run: this.createKeyMapRunCallback({
                check: decreaseHeading2.check,
                run: decreaseHeading2.editorCallback
              })
            }
          ])
        )
      );
    }
  }
  // Helper from ObsidianService
  getEditorFromState(state) {
    var _a, _b;
    try {
      return (_b = (_a = state.field(import_obsidian16.editorInfoField)) == null ? void 0 : _a.editor) != null ? _b : null;
    } catch (e) {
      console.error("Failed to get editor from state:", e);
      return null;
    }
  }
  createKeyMapRunCallback(config) {
    const check = config.check || (() => true);
    const { run } = config;
    return (view) => {
      const editor = this.getEditorFromState(view.state);
      if (!editor) {
        return false;
      }
      if (!check(editor)) {
        return false;
      }
      return run(editor);
    };
  }
};

// src/headings/manager.ts
var DEFAULT_HEADING_STYLES = ["1", "a", "A", "\u4E00", "\u2460", "1"];
var DEFAULT_HEADING_SEPARATORS = ["", "-", ":", ".", "\u2014", "-"];
var DEFAULT_HEADING_START_VALUES = ["0", "1", "1", "1", "1", "1"];
var HeadingsManager = class {
  constructor(app, plugin) {
    this.isLoaded = false;
    this.app = app;
    this.plugin = plugin;
    this.shifterManager = new ShifterManager(app, plugin);
  }
  async onload() {
    if (this.isLoaded)
      return;
    this.isLoaded = true;
    this.shifterManager.onload();
  }
  openControlModal() {
    if (!this.isLoaded)
      return;
    const activeView = this.app.workspace.getActiveViewOfType(import_obsidian17.MarkdownView);
    if (activeView && activeView.file) {
      new HeadingsControlModal(this.app, this.plugin, activeView.file).open();
    }
  }
  onunload() {
    if (!this.isLoaded)
      return;
    this.isLoaded = false;
    this.shifterManager.onunload();
  }
  getActiveViewInfo() {
    const activeView = this.app.workspace.getActiveViewOfType(import_obsidian17.MarkdownView);
    if (activeView && activeView.file) {
      const data = this.app.metadataCache.getFileCache(activeView.file);
      const editor = activeView.editor;
      if (data && editor) {
        return { activeView, data, editor };
      }
    }
    return void 0;
  }
  getEffectiveSettings(fm) {
    return parseHeadingsFrontMatter(fm, this.plugin.settings.myHeadings);
  }
  // Returns true if changes were made
  updateNumbering(force = false, performRestore = true) {
    var _a;
    const info = this.getActiveViewInfo();
    if (!info)
      return false;
    const { data, editor } = info;
    const settings = this.getEffectiveSettings(data.frontmatter);
    if (!settings.enabled && !force)
      return false;
    const cursorBefore = editor.getCursor();
    const scrollBefore = editor.getScrollInfo();
    const headings = (_a = data.headings) != null ? _a : [];
    if (headings.length === 0)
      return false;
    const codeRanges = getCodeBlockRanges(data);
    const headingStyles = settings.headingStyles || DEFAULT_HEADING_STYLES;
    const headingSeparators = settings.headingSeparators || DEFAULT_HEADING_SEPARATORS;
    const headingStartValues = settings.headingStartValues || DEFAULT_HEADING_START_VALUES;
    let previousLevel = settings.firstLevel - 1;
    let numberingStack = [];
    const changes = [];
    for (const heading of headings) {
      const level = heading.level;
      const lineNum = heading.position.start.line;
      const lineText = editor.getLine(lineNum);
      if (isLineIgnored(lineNum, lineText, codeRanges))
        continue;
      if (settings.firstLevel > level) {
        previousLevel = settings.firstLevel - 1;
        numberingStack = [];
        continue;
      }
      if (settings.skipHeadings && settings.skipHeadings.length > 0) {
        if (heading.heading.endsWith(settings.skipHeadings))
          continue;
      }
      if (level === previousLevel) {
        const x = numberingStack.pop();
        if (x)
          numberingStack.push(nextNumberingToken(x));
      } else if (level < previousLevel) {
        for (let i = previousLevel; i > level; i--)
          numberingStack.pop();
        const x = numberingStack.pop();
        if (x)
          numberingStack.push(nextNumberingToken(x));
      } else if (level > previousLevel) {
        for (let i = previousLevel; i < level; i++) {
          const styleIndex = Math.min(i, headingStyles.length - 1);
          const startVal = headingStartValues[styleIndex] !== void 0 ? headingStartValues[styleIndex] : "1";
          numberingStack.push(firstNumberingTokenInStyle(headingStyles[styleIndex], startVal));
        }
      }
      previousLevel = level;
      if (level > settings.maxLevel)
        continue;
      const prefixRange = findHeadingPrefixRange(editor, heading);
      if (!prefixRange)
        continue;
      const headingHashString = makeHeadingHashString(editor, heading);
      if (!headingHashString)
        continue;
      const prefixString = makeNumberingString(numberingStack, headingSeparators);
      const separator = headingSeparators[0] || "";
      replaceRangeEconomically(editor, changes, prefixRange, headingHashString + prefixString + separator + " ");
    }
    if (changes.length > 0) {
      editor.transaction({ changes });
      if (performRestore) {
        restoreCursor(editor, cursorBefore);
        editor.scrollTo(scrollBefore.left, scrollBefore.top);
      }
      return true;
    }
    return false;
  }
  removeNumbering() {
    var _a;
    const info = this.getActiveViewInfo();
    if (!info)
      return;
    const { data, editor } = info;
    const changes = [];
    const headings = (_a = data.headings) != null ? _a : [];
    if (headings.length === 0)
      return;
    for (const heading of headings) {
      const prefixRange = findHeadingPrefixRange(editor, heading);
      if (!prefixRange)
        continue;
      const headingHashString = makeHeadingHashString(editor, heading);
      if (!headingHashString)
        continue;
      replaceRangeEconomically(editor, changes, prefixRange, headingHashString + " ");
    }
    if (changes.length > 0) {
      editor.transaction({ changes });
    }
  }
};

// src/headings/settings-ui.ts
var import_obsidian18 = require("obsidian");
function renderHeadingsSettings(containerEl, manager) {
  const settings = manager.plugin.settings.myHeadings;
  const autoNumberingDetails = containerEl.createEl("details");
  autoNumberingDetails.open = false;
  autoNumberingDetails.style.marginBottom = "10px";
  autoNumberingDetails.style.border = "1px solid var(--background-modifier-border)";
  autoNumberingDetails.style.borderRadius = "5px";
  autoNumberingDetails.style.padding = "0.5em";
  const autoNumberingSummary = autoNumberingDetails.createEl("summary");
  autoNumberingSummary.setText(t("Auto Numbering"));
  autoNumberingSummary.style.fontWeight = "bold";
  autoNumberingSummary.style.cursor = "pointer";
  autoNumberingSummary.style.outline = "none";
  const autoNumberingContent = autoNumberingDetails.createEl("div");
  autoNumberingContent.style.marginTop = "10px";
  autoNumberingContent.style.paddingLeft = "5px";
  autoNumberingContent.style.borderLeft = "2px solid var(--background-modifier-border)";
  new import_obsidian18.Setting(autoNumberingContent).setName(t("Auto Number Headings")).setDesc(t("Create numbers automatically on blur")).addToggle((toggle) => toggle.setValue(settings.auto).onChange(async (value) => {
    settings.auto = value;
    await manager.plugin.saveSettings();
  }));
  new import_obsidian18.Setting(autoNumberingContent).setName(t("First Level")).addSlider((slider) => slider.setLimits(1, 6, 1).setValue(settings.firstLevel).setDynamicTooltip().onChange(async (value) => {
    settings.firstLevel = value;
    await manager.plugin.saveSettings();
  }));
  new import_obsidian18.Setting(autoNumberingContent).setName(t("Max Level")).addSlider((slider) => slider.setLimits(1, 6, 1).setValue(settings.maxLevel).setDynamicTooltip().onChange(async (value) => {
    settings.maxLevel = value;
    await manager.plugin.saveSettings();
  }));
  autoNumberingContent.createEl("h3", { text: t("Heading Styles") });
  const stylesContainer = autoNumberingContent.createEl("div");
  stylesContainer.style.display = "grid";
  stylesContainer.style.gridTemplateColumns = "0.5fr 1fr 1fr 1fr";
  stylesContainer.style.gap = "10px";
  stylesContainer.style.marginBottom = "20px";
  stylesContainer.createEl("div", { text: t("Level"), style: "font-weight: bold;" });
  stylesContainer.createEl("div", { text: t("Style"), style: "font-weight: bold;" });
  stylesContainer.createEl("div", { text: t("Separator"), style: "font-weight: bold;" });
  stylesContainer.createEl("div", { text: t("Start At"), style: "font-weight: bold;" });
  const styleOptions = { "1": "1, 2, 3", "a": "a, b, c", "A": "A, B, C", "I": "I, II, III", "\u4E00": "\u4E00, \u4E8C, \u4E09", "\u2460": "\u2460, \u2461, \u2462" };
  const separatorOptions = { "": "None", ".": ".", "-": "-", ":": ":", "\u2014": "\u2014" };
  for (let i = 0; i < 6; i++) {
    stylesContainer.createEl("div", { text: `H${i + 1}`, style: "align-self: center;" });
    const styleSelect = stylesContainer.createEl("select");
    Object.entries(styleOptions).forEach(([key, label]) => {
      styleSelect.createEl("option", { value: key, text: label });
    });
    styleSelect.value = settings.headingStyles[i];
    styleSelect.onchange = async () => {
      settings.headingStyles[i] = styleSelect.value;
      await manager.plugin.saveSettings();
    };
    const sepSelect = stylesContainer.createEl("select");
    Object.entries(separatorOptions).forEach(([key, label]) => {
      sepSelect.createEl("option", { value: key, text: label });
    });
    sepSelect.value = settings.headingSeparators[i];
    sepSelect.onchange = async () => {
      settings.headingSeparators[i] = sepSelect.value;
      await manager.plugin.saveSettings();
    };
    const startInput = stylesContainer.createEl("input", { type: "text" });
    startInput.style.width = "100%";
    startInput.value = settings.headingStartValues[i];
    startInput.onchange = async () => {
      settings.headingStartValues[i] = startInput.value;
      await manager.plugin.saveSettings();
    };
  }
  containerEl.createEl("br");
  const shifterDetails = containerEl.createEl("details");
  shifterDetails.open = false;
  shifterDetails.style.marginBottom = "10px";
  shifterDetails.style.border = "1px solid var(--background-modifier-border)";
  shifterDetails.style.borderRadius = "5px";
  shifterDetails.style.padding = "0.5em";
  const shifterSummary = shifterDetails.createEl("summary");
  shifterSummary.setText(t("Heading Shifter"));
  shifterSummary.style.fontWeight = "bold";
  shifterSummary.style.cursor = "pointer";
  shifterSummary.style.outline = "none";
  const shifterContent = shifterDetails.createEl("div");
  shifterContent.style.marginTop = "10px";
  shifterContent.style.paddingLeft = "5px";
  shifterContent.style.borderLeft = "2px solid var(--background-modifier-border)";
  new import_obsidian18.Setting(shifterContent).setName(t("Lower limit of Heading")).setDesc(t("The lower Heading Size that will be decreased by the Heading Shift")).addDropdown((dropdown) => {
    const headingOptions = {};
    [0, 1, 2, 3, 4, 5, 6].forEach((h) => headingOptions[String(h)] = String(h));
    dropdown.addOptions(headingOptions).setValue(String(settings.limitHeadingFrom)).onChange(async (value) => {
      settings.limitHeadingFrom = Number(value);
      await manager.plugin.saveSettings();
    });
  });
  new import_obsidian18.Setting(shifterContent).setName(t("Enable override tab behavior")).setDesc(t('Tab execute "Increase Headings" and Shift-Tab execute "Decrease Headings"')).addToggle(
    (toggle) => toggle.setValue(settings.overrideTab).onChange(async (value) => {
      settings.overrideTab = value;
      await manager.plugin.saveSettings();
    })
  );
  shifterContent.createEl("h3", { text: t("Style to remove") });
  shifterContent.createEl("p", { text: t("If this style is at the position of a line, remove it") });
  shifterContent.createEl("b", { text: t("Beginning") });
  new import_obsidian18.Setting(shifterContent).setName(t("Unordered list")).setDesc("-").addToggle(
    (toggle) => {
      var _a, _b;
      return toggle.setValue((_b = (_a = settings.styleToRemove) == null ? void 0 : _a.beginning) == null ? void 0 : _b.ul).onChange(async (value) => {
        settings.styleToRemove.beginning.ul = value;
        await manager.plugin.saveSettings();
      });
    }
  );
  new import_obsidian18.Setting(shifterContent).setName(t("Ordered list")).setDesc("1., 2. ,3. ,...").addToggle(
    (toggle) => {
      var _a, _b;
      return toggle.setValue((_b = (_a = settings.styleToRemove) == null ? void 0 : _a.beginning) == null ? void 0 : _b.ol).onChange(async (value) => {
        settings.styleToRemove.beginning.ol = value;
        await manager.plugin.saveSettings();
      });
    }
  );
  new import_obsidian18.Setting(shifterContent).setName(t("User defined")).setDesc(t("Arbitrary string (regular expression)")).addTextArea((str) => {
    var _a, _b;
    str.setValue((_b = (_a = settings.styleToRemove.beginning) == null ? void 0 : _a.userDefined) == null ? void 0 : _b.join("\n")).onChange(async (str2) => {
      settings.styleToRemove.beginning.userDefined = str2.split("\n");
      await manager.plugin.saveSettings();
    });
  });
  shifterContent.createEl("b", { text: t("Surrounding") });
  new import_obsidian18.Setting(shifterContent).setName(t("Bold")).setDesc("**|__").addToggle(
    (toggle) => {
      var _a, _b;
      return toggle.setValue((_b = (_a = settings.styleToRemove) == null ? void 0 : _a.surrounding) == null ? void 0 : _b.bold).onChange(async (value) => {
        settings.styleToRemove.surrounding.bold = value;
        await manager.plugin.saveSettings();
      });
    }
  );
  new import_obsidian18.Setting(shifterContent).setName(t("Italic")).setDesc("*|_").addToggle(
    (toggle) => {
      var _a, _b;
      return toggle.setValue((_b = (_a = settings.styleToRemove) == null ? void 0 : _a.surrounding) == null ? void 0 : _b.italic).onChange(async (value) => {
        settings.styleToRemove.surrounding.italic = value;
        await manager.plugin.saveSettings();
      });
    }
  );
  new import_obsidian18.Setting(shifterContent).setName(t("User defined")).setDesc(t("Arbitrary string (regular expression)")).addTextArea((str) => {
    var _a, _b, _c;
    str.setValue((_c = (_b = (_a = settings.styleToRemove) == null ? void 0 : _a.surrounding) == null ? void 0 : _b.userDefined) == null ? void 0 : _c.join("\n")).onChange(async (str2) => {
      settings.styleToRemove.surrounding.userDefined = str2.split("\n");
      await manager.plugin.saveSettings();
    });
  });
  shifterContent.createEl("h3", { text: t("List") });
  new import_obsidian18.Setting(shifterContent).setName(t("Children behavior")).addDropdown((dropdown) => {
    dropdown.addOption("outdent to zero", t("Outdent to 0")).addOption("sync with headings", t("Sync with headings")).addOption("noting", t("Noting")).setValue(settings.list.childrenBehavior).onChange((v) => {
      settings.list.childrenBehavior = v;
      manager.plugin.saveSettings();
    });
  });
  shifterContent.createEl("h3", { text: t("Editor") });
  new import_obsidian18.Setting(shifterContent).setName(t("Tab size")).addSlider((cb) => {
    cb.setDynamicTooltip().setLimits(2, 8, 2).setValue(settings.editor.tabSize).onChange((v) => {
      settings.editor.tabSize = v;
      manager.plugin.saveSettings();
    });
  });
}

// src/formulas/manager.ts
var import_obsidian20 = require("obsidian");

// src/formulas/modal.ts
var import_obsidian19 = require("obsidian");
var FormulasControlModal = class extends import_obsidian19.Modal {
  constructor(app, plugin, file) {
    super(app);
    this.plugin = plugin;
    this.file = file;
    const cache = app.metadataCache.getFileCache(file);
    const fm = cache ? cache.frontmatter : void 0;
    this.settings = JSON.parse(JSON.stringify(parseFormulasFrontMatter(fm, this.plugin.settings.myFormulas)));
  }
  onOpen() {
    this.display();
  }
  display() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: t("Configure Formulas") });
    new import_obsidian19.Setting(contentEl).setName(t("Auto Number Formulas")).setDesc(t("Automatically number formulas on blur")).addToggle((toggle) => toggle.setValue(this.settings.auto).onChange((v) => this.settings.auto = v));
    new import_obsidian19.Setting(contentEl).setName(t("Numbering Mode")).setDesc(t("Continuous: 1,2,3... | Heading-based: 1.1-1, 1.1-2...")).addDropdown((dropdown) => dropdown.addOption("continuous", t("Continuous")).addOption("heading-based", t("Heading-based")).setValue(this.settings.mode).onChange((v) => {
      this.settings.mode = v;
      this.display();
    }));
    if (this.settings.mode === "heading-based") {
      new import_obsidian19.Setting(contentEl).setName(t("Max Heading Depth")).setDesc(t("Maximum heading level to use for formula numbering")).addSlider((slider) => slider.setLimits(1, 6, 1).setValue(this.settings.maxDepth).setDynamicTooltip().onChange((v) => this.settings.maxDepth = v));
    }
    const buttonContainer = contentEl.createDiv({ cls: "modal-button-container" });
    new import_obsidian19.Setting(buttonContainer).addButton((btn) => btn.setButtonText(t("Apply Now")).setTooltip(t("Apply numbering once without saving to frontmatter")).onClick(() => {
      this.applyNumbering();
      this.close();
    })).addButton((btn) => btn.setButtonText(t("Save to Frontmatter")).setTooltip(t("Save settings to frontmatter and apply")).setCta().onClick(async () => {
      await this.saveAndApply();
      this.close();
    })).addButton((btn) => btn.setButtonText(t("Remove Numbering")).setWarning().onClick(() => {
      this.plugin.formulasManager.removeNumbering();
      new import_obsidian19.Notice(t("Formula numbering removed"));
      this.close();
    }));
  }
  applyNumbering() {
    const info = this.plugin.formulasManager.getActiveViewInfo();
    if (!info)
      return;
    const originalSettings = this.plugin.settings.myFormulas;
    this.plugin.settings.myFormulas = this.settings;
    this.plugin.formulasManager.updateNumbering(true, true);
    this.plugin.settings.myFormulas = originalSettings;
    new import_obsidian19.Notice(t("Formula numbering applied (one-time)"));
  }
  async saveAndApply() {
    await saveSettingsToFrontMatter(this.app, this.file, void 0, this.settings);
    await new Promise((resolve) => setTimeout(resolve, 100));
    this.plugin.formulasManager.updateNumbering(true, true);
    new import_obsidian19.Notice(t("Settings saved to frontmatter and applied"));
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/formulas/manager.ts
var TAG_REGEX = /\\tag\{([^}]*)\}/;
var TAG_REMOVE_REGEX = /\s*\\tag\{[^}]*\}/;
var HEADING_NUMBER_REGEX = /^\s{0,4}#+\s*([0-9a-zA-Z\u4e00-\u9fa5\u2460-\u2473&].*?)(\s|$)/;
var FormulasManager = class {
  constructor(app, plugin) {
    this.isLoaded = false;
    this.app = app;
    this.plugin = plugin;
  }
  async onload() {
    if (this.isLoaded)
      return;
    this.isLoaded = true;
  }
  openControlModal() {
    if (!this.isLoaded)
      return;
    const activeView = this.app.workspace.getActiveViewOfType(import_obsidian20.MarkdownView);
    if (activeView && activeView.file) {
      new FormulasControlModal(this.app, this.plugin, activeView.file).open();
    }
  }
  onunload() {
    if (!this.isLoaded)
      return;
    this.isLoaded = false;
  }
  getActiveViewInfo() {
    const activeView = this.app.workspace.getActiveViewOfType(import_obsidian20.MarkdownView);
    if (activeView && activeView.file) {
      const data = this.app.metadataCache.getFileCache(activeView.file);
      const editor = activeView.editor;
      if (data && editor) {
        return { activeView, data, editor };
      }
    }
    return void 0;
  }
  getEffectiveSettings(fm) {
    return parseFormulasFrontMatter(fm, this.plugin.settings.myFormulas);
  }
  updateNumbering(force = false, performRestore = true) {
    const info = this.getActiveViewInfo();
    if (!info)
      return false;
    const { data, editor } = info;
    const settings = this.getEffectiveSettings(data.frontmatter);
    if (!settings.enabled && !force)
      return false;
    const cursorBefore = editor.getCursor();
    const scrollBefore = editor.getScrollInfo();
    const lineCount = editor.lineCount();
    const codeRanges = getCodeBlockRanges(data);
    const changes = [];
    let equationCounter = 1;
    const headingFormulaCounters = {};
    const dollarPositions = [];
    for (let i = 0; i < lineCount; i++) {
      const line = editor.getLine(i);
      if (isLineIgnored(i, line, codeRanges))
        continue;
      let pos = -1;
      while ((pos = line.indexOf("$$", pos + 1)) !== -1) {
        dollarPositions.push({ line: i, ch: pos });
      }
    }
    if (dollarPositions.length === 0)
      return false;
    for (let i = 0; i < dollarPositions.length - 1; i += 2) {
      const start = dollarPositions[i];
      const end = dollarPositions[i + 1];
      if (start.line > end.line || start.line === end.line && start.ch >= end.ch)
        continue;
      let formulaContent = "";
      if (start.line === end.line) {
        const line = editor.getLine(start.line);
        formulaContent = line.substring(start.ch, end.ch + 2);
      } else {
        const startLine = editor.getLine(start.line);
        formulaContent += startLine.substring(start.ch) + "\n";
        for (let lineNum = start.line + 1; lineNum < end.line; lineNum++) {
          formulaContent += editor.getLine(lineNum) + "\n";
        }
        const endLine = editor.getLine(end.line);
        formulaContent += endLine.substring(0, end.ch + 2);
      }
      const tagRegex = TAG_REGEX;
      const hasTag = formulaContent.match(tagRegex);
      let equationNumber = "";
      if (settings.mode === "heading-based") {
        let currentHeadingNumber = "";
        const headings = data.headings || [];
        const maxDepth = settings.maxDepth || 4;
        let searchIndex = -1;
        for (let j = headings.length - 1; j >= 0; j--) {
          if (headings[j].position.start.line <= start.line) {
            searchIndex = j;
            break;
          }
        }
        let targetHeading = null;
        if (searchIndex !== -1) {
          for (let k = searchIndex; k >= 0; k--) {
            if (headings[k].level <= maxDepth) {
              targetHeading = headings[k];
              break;
            }
          }
        }
        if (targetHeading) {
          const headingLine = editor.getLine(targetHeading.position.start.line);
          const numberExtractRegex = HEADING_NUMBER_REGEX;
          const match = headingLine.match(numberExtractRegex);
          if (match && match[1]) {
            currentHeadingNumber = match[1].trim();
            if ([".", ":", "\u2014", "-"].some((c) => currentHeadingNumber.endsWith(c))) {
              currentHeadingNumber = currentHeadingNumber.slice(0, -1);
            }
          }
        }
        if (currentHeadingNumber) {
          if (!headingFormulaCounters[currentHeadingNumber])
            headingFormulaCounters[currentHeadingNumber] = 1;
          equationNumber = `${currentHeadingNumber}-${headingFormulaCounters[currentHeadingNumber]}`;
          headingFormulaCounters[currentHeadingNumber]++;
        } else {
          equationNumber = `${equationCounter}`;
          equationCounter++;
        }
      } else {
        equationNumber = `${equationCounter}`;
        equationCounter++;
      }
      if (!hasTag) {
        const endLine = editor.getLine(end.line);
        const beforeDollars = endLine.substring(0, end.ch);
        const afterDollars = endLine.substring(end.ch);
        const newLine = beforeDollars + ` \\tag{${equationNumber}}` + afterDollars;
        changes.push({
          from: { line: end.line, ch: 0 },
          to: { line: end.line, ch: endLine.length },
          text: newLine
        });
      } else {
        const updatedContent = formulaContent.replace(tagRegex, `\\tag{${equationNumber}}`);
        if (updatedContent !== formulaContent) {
          if (start.line === end.line) {
            const line = editor.getLine(start.line);
            changes.push({
              from: { line: start.line, ch: 0 },
              to: { line: start.line, ch: line.length },
              text: line.substring(0, start.ch) + updatedContent + line.substring(end.ch + 2)
            });
          } else {
            changes.push({
              from: { line: start.line, ch: start.ch },
              to: { line: end.line, ch: end.ch + 2 },
              text: updatedContent
            });
          }
        }
      }
    }
    if (changes.length > 0) {
      editor.transaction({ changes });
      if (performRestore) {
        restoreCursor(editor, cursorBefore);
        editor.scrollTo(scrollBefore.left, scrollBefore.top);
      }
      return true;
    }
    return false;
  }
  removeNumbering() {
    const info = this.getActiveViewInfo();
    if (!info)
      return;
    const { editor } = info;
    const changes = [];
    const lineCount = editor.lineCount();
    const tagRegex = TAG_REMOVE_REGEX;
    const dollarPositions = [];
    for (let i = 0; i < lineCount; i++) {
      const line = editor.getLine(i);
      let pos = -1;
      while ((pos = line.indexOf("$$", pos + 1)) !== -1) {
        dollarPositions.push({ line: i, ch: pos });
      }
    }
    if (dollarPositions.length === 0)
      return;
    for (let i = 0; i < dollarPositions.length - 1; i += 2) {
      const start = dollarPositions[i];
      const end = dollarPositions[i + 1];
      if (start.line === end.line) {
        const line = editor.getLine(start.line);
        const content = line.substring(start.ch + 2, end.ch);
        if (tagRegex.test(content)) {
          const newContent = content.replace(tagRegex, "");
          changes.push({
            from: { line: start.line, ch: start.ch + 2 },
            to: { line: end.line, ch: end.ch },
            text: newContent
          });
        }
      } else {
        for (let j = start.line; j <= end.line; j++) {
          const line = editor.getLine(j);
          let s = 0, e = line.length;
          if (j === start.line)
            s = start.ch + 2;
          if (j === end.line)
            e = end.ch;
          const c = line.substring(s, e);
          if (tagRegex.test(c)) {
            const n = c.replace(tagRegex, "");
            changes.push({
              from: { line: j, ch: s },
              to: { line: j, ch: e },
              text: n
            });
          }
        }
      }
    }
    if (changes.length > 0) {
      editor.transaction({ changes });
    }
  }
};

// src/formulas/settings-ui.ts
var import_obsidian21 = require("obsidian");
function renderFormulasSettings(containerEl, manager) {
  const settings = manager.plugin.settings.myFormulas;
  new import_obsidian21.Setting(containerEl).setName(t("Auto Number Formulas")).setDesc(t("Automatically number formulas (triggers on blur if enabled)")).addToggle((toggle) => toggle.setValue(settings.auto).onChange(async (value) => {
    settings.auto = value;
    await manager.plugin.saveSettings();
  }));
  new import_obsidian21.Setting(containerEl).setName(t("Numbering Mode")).setDesc(t("Continuous (1, 2, 3) or Heading-based (1.1-1, 1.1-2)")).addDropdown((dropdown) => dropdown.addOption("continuous", t("Continuous")).addOption("heading-based", t("Heading-based")).setValue(settings.mode).onChange(async (value) => {
    settings.mode = value;
    await manager.plugin.saveSettings();
    const nextSetting = containerEl.lastElementChild;
  }));
  const depthSetting = new import_obsidian21.Setting(containerEl).setName(t("Max Heading Depth")).setDesc(t("For Heading-based mode: max depth of heading to use as prefix (e.g. 4 means use H4 at most)")).addSlider((slider) => slider.setLimits(1, 6, 1).setValue(settings.maxDepth).setDynamicTooltip().onChange(async (value) => {
    settings.maxDepth = value;
    await manager.plugin.saveSettings();
  }));
  const updateVisibility = () => {
    if (settings.mode === "heading-based") {
      depthSetting.settingEl.style.display = "";
    } else {
      depthSetting.settingEl.style.display = "none";
    }
  };
  updateVisibility();
  const modeSetting = containerEl.children[containerEl.children.length - 2];
}

// src/sidebar/features/auto-hide.ts
var SidebarSideController = class {
  constructor(side, app, plugin, split, onExpand, onCollapse) {
    this.isHovering = false;
    this.isAutoExpanded = false;
    this.expandTimer = null;
    this.collapseTimer = null;
    // Event Handlers
    this.onMouseEnter = () => {
      this.isHovering = true;
      this.split.containerEl.addClass("hovered");
      this.cancelTimers();
    };
    this.onMouseMove = () => {
      this.split.containerEl.addClass("hovered");
    };
    this.onMouseLeave = (event) => {
      var _a;
      const target = event.relatedTarget;
      if (target && (target.closest(".workspace-tab-header-container-inner") || target.hasClass && target.hasClass("menu") || ((_a = target == null ? void 0 : target.classList) == null ? void 0 : _a.contains("menu")) || (target == null ? void 0 : target.closest(".menu")))) {
        return;
      }
      if (this.isSideEnabled) {
        this.isHovering = false;
        this.split.containerEl.removeClass("hovered");
        if (this.collapseTimer)
          clearTimeout(this.collapseTimer);
        this.collapseTimer = window.setTimeout(() => {
          if (!this.isHovering) {
            this.onCollapse();
          }
          this.collapseTimer = null;
        }, this.settings.sidebarDelay);
      }
    };
    this.side = side;
    this.app = app;
    this.plugin = plugin;
    this.split = split;
    this.onExpand = onExpand;
    this.onCollapse = onCollapse;
  }
  get settings() {
    return this.plugin.settings.mySideBar.autoHide;
  }
  get isSideEnabled() {
    return this.side === "left" ? this.settings.leftSidebar : this.settings.rightSidebar;
  }
  get pixelTrigger() {
    return this.side === "left" ? this.settings.leftSideBarPixelTrigger : this.settings.rightSideBarPixelTrigger;
  }
  expand() {
    if (this.split.collapsed)
      this.isAutoExpanded = true;
    this.split.expand();
    this.isHovering = true;
  }
  collapse() {
    if (this.isAutoExpanded) {
      this.split.collapse();
      this.isAutoExpanded = false;
    }
    this.isHovering = false;
  }
  cancelTimers() {
    if (this.expandTimer) {
      clearTimeout(this.expandTimer);
      this.expandTimer = null;
    }
    if (this.collapseTimer) {
      clearTimeout(this.collapseTimer);
      this.collapseTimer = null;
    }
  }
  cleanup() {
    this.cancelTimers();
    if (this.split && this.split.containerEl) {
      this.split.containerEl.removeClass("hovered");
      this.split.containerEl.removeEventListener("mouseenter", this.onMouseEnter);
      this.split.containerEl.removeEventListener("mousemove", this.onMouseMove);
      this.split.containerEl.removeEventListener("mouseleave", this.onMouseLeave);
    }
  }
  attach() {
    if (this.split && this.split.containerEl) {
      this.split.containerEl.addEventListener("mouseenter", this.onMouseEnter);
      this.split.containerEl.addEventListener("mousemove", this.onMouseMove);
      this.split.containerEl.addEventListener("mouseleave", this.onMouseLeave);
    }
  }
};
var AutoHideFeature = class {
  constructor(app, plugin) {
    this.layoutChangeRef = null;
    this.isInitialized = false;
    this.resizeObserver = null;
    this.editorWidth = 0;
    this.rafId = null;
    this.app = app;
    this.plugin = plugin;
  }
  get settings() {
    return this.plugin.settings.mySideBar.autoHide;
  }
  onload() {
    if (this.settings.overlayMode) {
      document.body.classList.add("sidebar-overlay-mode");
    }
    document.body.classList.add("open-sidebar-hover-plugin");
    this.updateCSSVariables();
    this.app.workspace.onLayoutReady(() => {
      this.init();
    });
  }
  init() {
    if (this.isInitialized)
      return;
    this.isInitialized = true;
    const leftSplit = this.app.workspace.leftSplit;
    const rightSplit = this.app.workspace.rightSplit;
    this.leftRibbon = this.app.workspace.leftRibbon;
    this.leftController = new SidebarSideController(
      "left",
      this.app,
      this.plugin,
      leftSplit,
      () => {
        if (this.settings.syncLeftRight && this.settings.rightSidebar) {
          this.expandBoth();
        } else {
          this.leftController.expand();
        }
      },
      () => {
        if (this.settings.syncLeftRight && this.settings.rightSidebar) {
          this.collapseBoth();
        } else {
          this.leftController.collapse();
        }
      }
    );
    this.rightController = new SidebarSideController(
      "right",
      this.app,
      this.plugin,
      rightSplit,
      () => {
        if (this.settings.syncLeftRight && this.settings.leftSidebar) {
          this.expandBoth();
        } else {
          this.rightController.expand();
        }
      },
      () => {
        if (this.settings.syncLeftRight && this.settings.leftSidebar) {
          this.collapseBoth();
        } else {
          this.rightController.collapse();
        }
      }
    );
    this.leftController.attach();
    this.rightController.attach();
    this.initializeHandlers();
    this.updateEditorDimensions();
    document.addEventListener("mousemove", this.mouseMoveHandler);
    document.addEventListener("mouseleave", this.documentMouseLeaveHandler);
    document.addEventListener("click", this.documentClickHandler);
    this.resizeObserver = new ResizeObserver(() => {
      this.updateEditorDimensions();
    });
    this.resizeObserver.observe(this.app.workspace.containerEl);
    if (this.leftRibbon && this.leftRibbon.containerEl) {
      this.leftRibbon.containerEl.addEventListener("mouseenter", this.leftRibbonMouseEnterHandler);
    }
    this.layoutChangeRef = this.app.workspace.on("layout-change", () => {
      if (this.leftController.split.collapsed)
        this.leftController.isAutoExpanded = false;
      if (this.rightController.split.collapsed)
        this.rightController.isAutoExpanded = false;
    });
  }
  onunload() {
    var _a, _b;
    if (!this.isInitialized)
      return;
    (_a = this.leftController) == null ? void 0 : _a.cleanup();
    (_b = this.rightController) == null ? void 0 : _b.cleanup();
    document.body.classList.remove("sidebar-overlay-mode");
    document.body.classList.remove("open-sidebar-hover-plugin");
    document.removeEventListener("mousemove", this.mouseMoveHandler);
    if (this.documentClickHandler)
      document.removeEventListener("click", this.documentClickHandler);
    if (this.documentMouseLeaveHandler)
      document.removeEventListener("mouseleave", this.documentMouseLeaveHandler);
    if (this.leftRibbon && this.leftRibbon.containerEl) {
      this.leftRibbon.containerEl.removeEventListener("mouseenter", this.leftRibbonMouseEnterHandler);
    }
    if (this.resizeObserver) {
      this.resizeObserver.disconnect();
      this.resizeObserver = null;
    }
    if (this.rafId) {
      cancelAnimationFrame(this.rafId);
      this.rafId = null;
    }
    const styleEl = document.getElementById("obsidian-assistant-sidebar-variables");
    if (styleEl)
      styleEl.remove();
    if (this.layoutChangeRef) {
      this.app.workspace.offref(this.layoutChangeRef);
      this.layoutChangeRef = null;
    }
    this.isInitialized = false;
  }
  updateEditorDimensions() {
    if (this.app.workspace.containerEl) {
      this.editorWidth = this.app.workspace.containerEl.clientWidth;
    }
  }
  initializeHandlers() {
    this.documentClickHandler = (e) => {
      const target = e.target;
      if (!this.leftController.split || !this.rightController.split)
        return;
      const leftSplitEl = this.leftController.split.containerEl;
      const rightSplitEl = this.rightController.split.containerEl;
      if (!leftSplitEl.contains(target) && !rightSplitEl.contains(target)) {
        if (!this.leftController.split.collapsed && this.settings.leftSidebar) {
          this.leftController.collapse();
        }
        if (!this.rightController.split.collapsed && this.settings.rightSidebar) {
          this.rightController.collapse();
        }
      }
    };
    this.documentMouseLeaveHandler = (e) => {
      this.leftController.cancelTimers();
      this.leftController.isHovering = false;
      this.rightController.cancelTimers();
      this.rightController.isHovering = false;
    };
    this.leftRibbonMouseEnterHandler = () => {
      if (this.settings.leftSidebar) {
        this.leftController.isHovering = true;
        if (this.leftController.expandTimer)
          clearTimeout(this.leftController.expandTimer);
        this.leftController.expandTimer = window.setTimeout(() => {
          if (this.leftController.isHovering) {
            this.leftController.onExpand();
          }
          this.leftController.expandTimer = null;
        }, this.settings.sidebarExpandDelay);
      }
    };
    this.mouseMoveHandler = (event) => {
      if (this.rafId)
        return;
      this.rafId = requestAnimationFrame(() => {
        this.rafId = null;
        const mouseX = event.clientX;
        const editorWidth = this.editorWidth;
        if (this.settings.rightSidebar && this.rightController.split.collapsed) {
          const inTriggerZone = mouseX >= editorWidth - this.settings.rightSideBarPixelTrigger;
          if (inTriggerZone) {
            if (!this.rightController.isHovering) {
              this.rightController.isHovering = true;
              if (this.rightController.expandTimer)
                clearTimeout(this.rightController.expandTimer);
              this.rightController.expandTimer = window.setTimeout(() => {
                this.rightController.onExpand();
                this.rightController.expandTimer = null;
              }, this.settings.sidebarExpandDelay);
            }
          } else {
            if (this.rightController.isHovering) {
              this.rightController.isHovering = false;
              if (this.rightController.expandTimer) {
                clearTimeout(this.rightController.expandTimer);
                this.rightController.expandTimer = null;
              }
            }
          }
        }
        if (this.settings.leftSidebar && this.leftController.split.collapsed) {
          const inTriggerZone = mouseX <= this.settings.leftSideBarPixelTrigger;
          if (inTriggerZone) {
            if (!this.leftController.isHovering) {
              this.leftController.isHovering = true;
              if (this.leftController.expandTimer)
                clearTimeout(this.leftController.expandTimer);
              this.leftController.expandTimer = window.setTimeout(() => {
                this.leftController.onExpand();
                this.leftController.expandTimer = null;
              }, this.settings.sidebarExpandDelay);
            }
          } else {
            if (this.leftController.isHovering) {
              this.leftController.isHovering = false;
              if (this.leftController.expandTimer) {
                clearTimeout(this.leftController.expandTimer);
                this.leftController.expandTimer = null;
              }
            }
          }
        }
      });
    };
  }
  updateCSSVariables() {
    const styleEl = document.createElement("style");
    styleEl.id = "obsidian-assistant-sidebar-variables";
    const existingStyle = document.getElementById(styleEl.id);
    if (existingStyle)
      existingStyle.remove();
    styleEl.textContent = `
            :root {
                --sidebar-expand-collapse-speed: ${this.settings.expandCollapseSpeed}ms;
                --sidebar-expand-delay: ${this.settings.sidebarExpandDelay}ms;
                --left-sidebar-max-width: ${this.settings.leftSidebarMaxWidth}px;
                --right-sidebar-max-width: ${this.settings.rightSidebarMaxWidth}px;
            }
        `;
    document.head.appendChild(styleEl);
  }
  expandBoth() {
    this.rightController.expand();
    this.leftController.expand();
  }
  collapseBoth() {
    this.rightController.collapse();
    this.leftController.collapse();
  }
};

// src/sidebar/features/ribbon.ts
var RibbonFeature = class {
  constructor(app, plugin) {
    // Debounce timer for observer
    this.observerTimer = null;
    this.isInternalChange = false;
    this.app = app;
    this.plugin = plugin;
  }
  get settings() {
    return this.plugin.settings.mySideBar.ribbon;
  }
  async onload() {
    var _a;
    if (!((_a = this.plugin.settings.mySideBar) == null ? void 0 : _a.ribbon)) {
      if (!this.plugin.settings.mySideBar) {
        this.plugin.settings.mySideBar = {};
      }
      this.plugin.settings.mySideBar.ribbon = { elements: {} };
      await this.plugin.saveSettings();
    }
    this.app.workspace.onLayoutReady(() => {
      this.init();
    });
  }
  onunload() {
    if (this.observer) {
      this.observer.disconnect();
    }
    const resetEl = (el) => {
      el.style.removeProperty("order");
      el.style.removeProperty("display");
      el.removeClass("assistant-ribbon-hidden");
    };
    if (this.ribbonActions)
      Array.from(this.ribbonActions.children).forEach((el) => resetEl(el));
    if (this.ribbonSettings)
      Array.from(this.ribbonSettings.children).forEach((el) => resetEl(el));
  }
  init() {
    const ribbon = document.querySelector(".workspace-ribbon.mod-left");
    if (!ribbon)
      return;
    this.ribbonActions = ribbon.querySelector(".side-dock-actions");
    this.ribbonSettings = ribbon.querySelector(".side-dock-settings");
    if (!this.ribbonActions && !this.ribbonSettings)
      return;
    this.ribbonActions.addClass("assistant-ribbon-loading");
    const configuredDelay = this.plugin.settings.mySideBar.ribbon.ribbonDisplayDelay || 1e3;
    let delayMs = configuredDelay;
    if (this.plugin.settings.myPlugins.enabled) {
      const deviceSettings = this.plugin.settings.myPlugins.dualConfigs && this.app.isMobile ? this.plugin.settings.myPlugins.mobile || this.plugin.settings.myPlugins.desktop : this.plugin.settings.myPlugins.desktop;
      const maxDelay = Math.max(deviceSettings.shortDelaySeconds, deviceSettings.longDelaySeconds);
      delayMs = maxDelay * 1e3 + configuredDelay;
    } else {
      delayMs = configuredDelay;
    }
    setTimeout(async () => {
      await this.processRibbon();
      this.ribbonActions.removeClass("assistant-ribbon-loading");
      this.observer = new MutationObserver((mutations) => {
        if (this.isInternalChange)
          return;
        let shouldUpdate = false;
        for (const mutation of mutations) {
          if (mutation.type === "childList") {
            shouldUpdate = true;
            break;
          }
        }
        if (shouldUpdate) {
          this.scheduleProcess();
        }
      });
      if (this.ribbonActions)
        this.observer.observe(this.ribbonActions, { childList: true });
      if (this.ribbonSettings)
        this.observer.observe(this.ribbonSettings, { childList: true });
    }, delayMs);
  }
  scheduleProcess() {
    if (this.observerTimer !== null) {
      window.clearTimeout(this.observerTimer);
    }
    this.observerTimer = window.setTimeout(() => {
      this.processRibbon();
      this.observerTimer = null;
    }, 200);
  }
  async processRibbon() {
    var _a, _b;
    if (!this.ribbonActions && !this.ribbonSettings)
      return;
    const actionsChildren = this.ribbonActions ? Array.from(this.ribbonActions.children) : [];
    const settingsChildren = this.ribbonSettings ? Array.from(this.ribbonSettings.children) : [];
    const domElementsMap = /* @__PURE__ */ new Map();
    actionsChildren.forEach((el) => {
      const ariaLabel = el.getAttribute("aria-label");
      if (ariaLabel && !el.classList.contains("assistant-ghost")) {
        domElementsMap.set(ariaLabel, el);
      }
    });
    settingsChildren.forEach((el) => {
      const ariaLabel = el.getAttribute("aria-label");
      if (ariaLabel && !el.classList.contains("assistant-ghost")) {
        domElementsMap.set(ariaLabel, el);
      }
    });
    const settingsElements = this.settings.elements;
    const knownIDs = Object.keys(settingsElements);
    let maxOrder = 0;
    Object.values(settingsElements).forEach((el) => {
      if (el.order > maxOrder)
        maxOrder = el.order;
    });
    const newElements = [];
    for (const [id, el] of domElementsMap.entries()) {
      if (!settingsElements[id]) {
        maxOrder++;
        const newEl = {
          id,
          name: id,
          visible: true,
          order: maxOrder,
          icon: ((_a = el.querySelector("svg")) == null ? void 0 : _a.outerHTML) || el.innerHTML
        };
        newElements.push(newEl);
        settingsElements[id] = newEl;
      } else {
        const icon = ((_b = el.querySelector("svg")) == null ? void 0 : _b.outerHTML) || el.innerHTML;
        if (icon && settingsElements[id].icon !== icon) {
          settingsElements[id].icon = icon;
        }
      }
    }
    this.isInternalChange = true;
    const sortedIDs = Object.keys(settingsElements).sort((a, b) => settingsElements[a].order - settingsElements[b].order);
    for (const id of sortedIDs) {
      const setting = settingsElements[id];
      const el = domElementsMap.get(id);
      if (el) {
        if (setting.visible) {
          el.style.setProperty("display", "flex", "important");
          el.removeClass("assistant-ribbon-hidden");
        } else {
          el.style.setProperty("display", "none", "important");
          el.addClass("assistant-ribbon-hidden");
        }
        if (this.ribbonActions && el.parentElement !== this.ribbonActions) {
          this.ribbonActions.appendChild(el);
        }
        if (this.ribbonActions) {
          this.ribbonActions.appendChild(el);
        }
      }
    }
    this.isInternalChange = false;
    if (newElements.length > 0) {
      await this.plugin.saveSettings();
    }
  }
  async toggleVisibility(id) {
    if (this.settings.elements[id]) {
      this.settings.elements[id].visible = !this.settings.elements[id].visible;
      await this.plugin.saveSettings();
      await this.processRibbon();
    }
  }
  async saveOrder(newOrder) {
    newOrder.forEach((id, index) => {
      if (this.settings.elements[id]) {
        this.settings.elements[id].order = index;
      }
    });
    await this.plugin.saveSettings();
    await this.processRibbon();
  }
};

// src/sidebar/features/tabs.ts
var import_obsidian22 = require("obsidian");
var SidebarTabsFeature = class {
  constructor(app, plugin) {
    this.scanTimer = null;
    this.app = app;
    this.plugin = plugin;
  }
  async onload() {
    var _a;
    if (!((_a = this.plugin.settings.mySideBar.tabs) == null ? void 0 : _a.enabled))
      return;
    this.app.workspace.onLayoutReady(() => {
      this.scanTimer = window.setTimeout(() => {
        this.scanAndApply();
        this.scanTimer = null;
      }, 1e3);
    });
  }
  async scanAndApply() {
    if (!this.plugin.settings.mySideBar.tabs.enabled)
      return;
    await this.scan();
    await this.applyLayout();
  }
  async scan() {
    const settings = this.plugin.settings.mySideBar.tabs;
    let changed = false;
    const processSplit = (split, side) => {
      if (!split)
        return;
      this.app.workspace.iterateLeaves((leaf) => {
        const viewType = leaf.view.getViewType();
        if (leaf.view.containerEl.dataset.assistantContextualSlave === "true")
          return;
        if (!settings.elements[viewType]) {
          const maxOrder = Object.values(settings.elements).reduce((max, el) => Math.max(max, el.order), -1);
          settings.elements[viewType] = {
            id: viewType,
            side,
            visible: true,
            order: maxOrder + 1,
            icon: leaf.view.icon
          };
          changed = true;
        } else if (!settings.elements[viewType].icon && leaf.view.icon) {
          settings.elements[viewType].icon = leaf.view.icon;
          changed = true;
        }
      }, split);
    };
    processSplit(this.app.workspace.leftSplit, "left");
    processSplit(this.app.workspace.rightSplit, "right");
    if (changed) {
      await this.plugin.saveSettings();
    }
    return settings.elements;
  }
  async applyLayout() {
    const settings = this.plugin.settings.mySideBar.tabs;
    if (!settings.enabled)
      return;
    const elements = Object.values(settings.elements);
    const leftItems = elements.filter((e) => e.side === "left" && e.visible).sort((a, b) => a.order - b.order);
    const rightItems = elements.filter((e) => e.side === "right" && e.visible).sort((a, b) => a.order - b.order);
    const getSplitIds = (split) => {
      if (!split)
        return [];
      const ids = [];
      this.app.workspace.iterateLeaves((leaf) => {
        if (leaf.view.containerEl.dataset.assistantContextualSlave === "true")
          return;
        ids.push(leaf.view.getViewType());
      }, split);
      return ids;
    };
    const currentLeft = getSplitIds(this.app.workspace.leftSplit);
    const currentRight = getSplitIds(this.app.workspace.rightSplit);
    const targetLeftIds = leftItems.map((e) => e.id);
    const targetRightIds = rightItems.map((e) => e.id);
    const isLeftMatch = JSON.stringify(currentLeft) === JSON.stringify(targetLeftIds);
    const isRightMatch = JSON.stringify(currentRight) === JSON.stringify(targetRightIds);
    if (isLeftMatch && isRightMatch) {
      return;
    }
    const viewStates = {};
    const leavesToDetach = [];
    const processSide = (split, isMatch) => {
      if (isMatch)
        return;
      if (!split)
        return;
      this.app.workspace.iterateLeaves((leaf) => {
        const type = leaf.view.getViewType();
        if (settings.elements[type]) {
          viewStates[type] = leaf.getViewState();
          leavesToDetach.push(leaf);
        }
      }, split);
    };
    processSide(this.app.workspace.leftSplit, isLeftMatch);
    processSide(this.app.workspace.rightSplit, isRightMatch);
    leavesToDetach.forEach((leaf) => leaf.detach());
    if (!isLeftMatch)
      await this.openInSplit(leftItems, "left", viewStates);
    if (!isRightMatch)
      await this.openInSplit(rightItems, "right", viewStates);
  }
  async openInSplit(items, side, viewStates) {
    for (const item of items) {
      let leaf;
      if (side === "left")
        leaf = this.app.workspace.getLeftLeaf(false);
      else
        leaf = this.app.workspace.getRightLeaf(false);
      let state = viewStates[item.id];
      if (!state) {
        state = { type: item.id };
      }
      try {
        await leaf.setViewState(state);
      } catch (e) {
        console.error(`Assistant: Failed to restore tab ${item.id}`, e);
        leaf.detach();
      }
    }
  }
  // Helper to toggle side or visibility
  async updateTab(id, updates) {
    const settings = this.plugin.settings.mySideBar.tabs;
    if (settings.elements[id]) {
      const oldSide = settings.elements[id].side;
      Object.assign(settings.elements[id], updates);
      if (updates.side && updates.side !== oldSide && settings.bindings) {
        const initialLength = settings.bindings.length;
        settings.bindings = settings.bindings.filter((b) => {
          var _a, _b;
          if (b.masterId === id || b.slaveId === id) {
            const masterSide = (_a = settings.elements[b.masterId]) == null ? void 0 : _a.side;
            const slaveSide = (_b = settings.elements[b.slaveId]) == null ? void 0 : _b.side;
            return masterSide === slaveSide;
          }
          return true;
        });
        if (settings.bindings.length < initialLength) {
          new import_obsidian22.Notice(t("Binding Removed"));
        }
      }
      await this.plugin.saveSettings();
      await this.applyLayout();
    }
  }
  onunload() {
    if (this.scanTimer) {
      window.clearTimeout(this.scanTimer);
      this.scanTimer = null;
    }
  }
};

// src/sidebar/features/contextual-split.ts
var import_obsidian23 = require("obsidian");
var ContextualSplitFeature = class {
  constructor(app, plugin) {
    // Store original visual states of master tabs: { viewType: { icon: string, title: string } }
    this.originalStates = /* @__PURE__ */ new Map();
    this.activeBinding = null;
    this.listeners = [];
    this.app = app;
    this.plugin = plugin;
  }
  onload() {
    if (this.listeners.length > 0) {
      this.onunload();
    }
    const runInit = () => {
      this.cleanOrphans();
      this.applyAllMasquerades();
    };
    if (this.app.workspace.layoutReady) {
      runInit();
    } else {
      this.app.workspace.onLayoutReady(() => {
        runInit();
      });
    }
    this.listeners.push(
      this.app.workspace.on("layout-change", (0, import_obsidian23.debounce)(() => {
        this.applyAllMasquerades();
        this.checkActiveBindingValidity();
      }, 200))
    );
    this.listeners.push(
      this.app.workspace.on("resize", (0, import_obsidian23.debounce)(() => {
        this.saveSplitState();
      }, 500))
    );
    this.listeners.push(
      this.app.workspace.on("active-leaf-change", (0, import_obsidian23.debounce)((leaf) => {
        if (leaf)
          this.handleActiveLeaf(leaf);
      }, 50, true))
    );
  }
  onunload() {
    this.listeners.forEach((ref) => this.app.workspace.offref(ref));
    this.listeners = [];
    if (this.activeBinding) {
      this.cleanupSplit(this.activeBinding);
    }
    const bindings = this.plugin.settings.mySideBar.tabs.bindings || [];
    bindings.forEach((b) => {
      const masterLeaves = this.findLeavesByType(b.masterId);
      masterLeaves.forEach((l) => this.restoreVisuals(l, b.masterId));
    });
  }
  cleanOrphans() {
    const removeOrphans = (split) => {
      if (!split)
        return;
      const toDetach = [];
      this.app.workspace.iterateLeaves((leaf) => {
        if (leaf.view.containerEl.dataset.assistantContextualSlave === "true") {
          toDetach.push(leaf);
        }
      }, split);
      toDetach.forEach((l) => l.detach());
    };
    removeOrphans(this.app.workspace.leftSplit);
    removeOrphans(this.app.workspace.rightSplit);
  }
  applyAllMasquerades() {
    const bindings = this.plugin.settings.mySideBar.tabs.bindings || [];
    bindings.forEach((b) => {
      const masterLeaves = this.findLeavesByType(b.masterId);
      masterLeaves.forEach((leaf) => this.applyVisualOverride(leaf, b));
    });
  }
  async handleActiveLeaf(leaf) {
    var _a;
    if (!((_a = this.plugin.settings.mySideBar.tabs) == null ? void 0 : _a.enabled))
      return;
    const viewType = leaf.view.getViewType();
    const bindings = this.plugin.settings.mySideBar.tabs.bindings || [];
    const matchingBinding = bindings.find((b) => b.masterId === viewType);
    if (matchingBinding) {
      if (this.activeBinding && this.activeBinding !== matchingBinding) {
        await this.cleanupSplit(this.activeBinding);
      }
      this.activeBinding = matchingBinding;
      await this.activateSplit(leaf, matchingBinding);
    } else {
      if (this.activeBinding) {
        if (viewType === this.activeBinding.slaveId) {
          if (leaf.view.containerEl.dataset.assistantContextualSlave === "true") {
            return;
          }
        }
        if (this.isMasterVisible(this.activeBinding.masterId)) {
          return;
        }
        await this.cleanupSplit(this.activeBinding);
        this.activeBinding = null;
      }
    }
  }
  checkActiveBindingValidity() {
    const bindings = this.plugin.settings.mySideBar.tabs.bindings || [];
    for (const binding of bindings) {
      if (this.isMasterVisible(binding.masterId)) {
        if (this.activeBinding !== binding) {
          if (this.activeBinding)
            this.cleanupSplit(this.activeBinding);
          this.activeBinding = binding;
          const leaves = this.findLeavesByType(binding.masterId);
          const visibleLeaf = leaves.find((l) => l.view.containerEl.isShown());
          if (visibleLeaf)
            this.activateSplit(visibleLeaf, binding);
        }
        return;
      }
    }
    if (this.activeBinding) {
      this.cleanupSplit(this.activeBinding);
      this.activeBinding = null;
    }
  }
  isMasterVisible(masterId) {
    const leaves = this.findLeavesByType(masterId);
    return leaves.some((l) => l.view.containerEl.isShown());
  }
  saveSplitState() {
    if (!this.activeBinding)
      return;
    const slaveLeaf = this.findUniqueSlaveLeaf(this.activeBinding.slaveId);
    if (slaveLeaf) {
      const parent = slaveLeaf.parent;
      if (parent && typeof parent.dimension === "number") {
        let dim = parent.dimension;
        dim = Math.round(dim);
        if (dim < 10)
          dim = 10;
        if (dim > 90)
          dim = 90;
        if (this.activeBinding.splitRatio !== dim) {
          this.activeBinding.splitRatio = dim;
          this.plugin.saveSettings();
        }
      }
    }
  }
  async activateSplit(masterLeaf, binding) {
    let slaveLeaf = this.findUniqueSlaveLeaf(binding.slaveId);
    if (!slaveLeaf) {
      slaveLeaf = this.app.workspace.createLeafBySplit(masterLeaf, "horizontal");
      await slaveLeaf.setViewState({ type: binding.slaveId });
      slaveLeaf.view.containerEl.dataset.assistantContextualSlave = "true";
    }
    const parent = slaveLeaf.parent;
    if (parent && parent.containerEl) {
      parent.containerEl.addClass("contextual-split-hidden-header");
      if (typeof parent.setDimension === "function") {
        let dim = binding.splitRatio || 50;
        dim = Math.round(dim);
        if (dim < 10)
          dim = 10;
        if (dim > 90)
          dim = 90;
        const split = parent.parent;
        if (split && split.children) {
          const others = split.children.filter((c) => c !== parent);
          if (others.length > 0) {
            const sibling = others[0];
            try {
              if (typeof parent.setDimension === "function") {
                parent.setDimension(dim);
              }
              if (typeof sibling.setDimension === "function") {
                sibling.setDimension(100 - dim);
              }
            } catch (e) {
              console.error("Assistant Assistant: Failed to set split dimension", e);
            }
          } else {
            try {
              if (typeof parent.setDimension === "function") {
                parent.setDimension(dim);
              }
            } catch (e) {
              console.error("Assistant Assistant: Failed to set split dimension (fallback)", e);
            }
          }
        }
      }
    }
  }
  async cleanupSplit(binding) {
    const slaveLeaf = this.findUniqueSlaveLeaf(binding.slaveId);
    if (slaveLeaf) {
      if (slaveLeaf.view.containerEl.dataset.assistantContextualSlave === "true") {
        slaveLeaf.detach();
      }
    }
  }
  findLeavesByType(type) {
    const leaves = [];
    this.app.workspace.iterateAllLeaves((l) => {
      if (l.view.getViewType() === type)
        leaves.push(l);
    });
    return leaves;
  }
  findUniqueSlaveLeaf(type) {
    let found = null;
    const checkSplit = (split) => {
      if (!split)
        return;
      this.app.workspace.iterateLeaves((l) => {
        if (l.view.getViewType() === type && l.view.containerEl.dataset.assistantContextualSlave === "true") {
          found = l;
        }
      }, split);
    };
    checkSplit(this.app.workspace.leftSplit);
    checkSplit(this.app.workspace.rightSplit);
    return found;
  }
  applyVisualOverride(leaf, binding) {
    if (!binding.groupName && !binding.groupSvg)
      return;
    const viewType = leaf.view.getViewType();
    if (!this.originalStates.has(viewType)) {
      const icon = leaf.view.icon;
      const title = leaf.view.getDisplayText();
      this.originalStates.set(viewType, { icon, title });
    }
    const workspaceTabs = leaf.parent;
    if (workspaceTabs && workspaceTabs.tabHeaderContainerEl) {
      const header = workspaceTabs.tabHeaderContainerEl.querySelector(`.workspace-tab-header[data-type="${viewType}"]`);
      if (header) {
        if (binding.groupName) {
          const titleEl = header.querySelector(".workspace-tab-header-inner-title");
          if (titleEl) {
            titleEl.textContent = binding.groupName;
            header.setAttribute("aria-label", binding.groupName);
          }
        }
        if (binding.groupSvg && binding.groupSvg.trim().length > 0) {
          const iconEl = header.querySelector(".workspace-tab-header-inner-icon");
          if (iconEl) {
            const val = binding.groupSvg.trim();
            if (val.startsWith("<svg")) {
              iconEl.empty();
              iconEl.innerHTML = val;
            } else {
              if (!val.includes("<") && !val.includes(">")) {
                iconEl.empty();
                (0, import_obsidian23.setIcon)(iconEl, val);
              }
            }
          }
        }
        header.addClass("assistant-contextual-group-tab");
      }
    }
  }
  restoreVisuals(leaf, viewType) {
    const original = this.originalStates.get(viewType);
    if (!original)
      return;
    const workspaceTabs = leaf.parent;
    if (workspaceTabs && workspaceTabs.tabHeaderContainerEl) {
      const header = workspaceTabs.tabHeaderContainerEl.querySelector(`.workspace-tab-header[data-type="${viewType}"]`);
      if (header) {
        const titleEl = header.querySelector(".workspace-tab-header-inner-title");
        if (titleEl) {
          titleEl.textContent = original.title;
          header.setAttribute("aria-label", original.title);
        }
        const iconEl = header.querySelector(".workspace-tab-header-inner-icon");
        if (iconEl) {
          iconEl.empty();
          (0, import_obsidian23.setIcon)(iconEl, original.icon);
        }
        header.removeClass("assistant-contextual-group-tab");
      }
    }
    this.originalStates.delete(viewType);
  }
};

// src/sidebar/manager.ts
var SidebarManager = class {
  constructor(app, plugin) {
    this.app = app;
    this.plugin = plugin;
    this.autoHideFeature = new AutoHideFeature(app, plugin);
    this.ribbonFeature = new RibbonFeature(app, plugin);
    this.tabsFeature = new SidebarTabsFeature(app, plugin);
    this.contextualFeature = new ContextualSplitFeature(app, plugin);
  }
  async onload() {
    var _a, _b, _c;
    if ((_a = this.plugin.settings.mySideBar.autoHide) == null ? void 0 : _a.enabled)
      this.autoHideFeature.onload();
    if ((_b = this.plugin.settings.mySideBar.ribbon) == null ? void 0 : _b.enabled)
      await this.ribbonFeature.onload();
    if ((_c = this.plugin.settings.mySideBar.tabs) == null ? void 0 : _c.enabled) {
      await this.tabsFeature.onload();
      this.contextualFeature.onload();
    }
  }
  onunload() {
    this.autoHideFeature.onunload();
    this.ribbonFeature.onunload();
    this.tabsFeature.onunload();
    this.contextualFeature.onunload();
  }
};

// src/sidebar/settings-ui.ts
var import_obsidian25 = require("obsidian");

// src/sidebar/group-modal.ts
var import_obsidian24 = require("obsidian");
var GroupModal = class extends import_obsidian24.Modal {
  constructor(app, manager, onSubmit) {
    super(app);
    this.masterId = "";
    this.slaveId = "";
    this.groupName = "";
    this.groupSvg = "";
    this.manager = manager;
    this.onSubmit = onSubmit;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: t("Add New Group") });
    new import_obsidian24.Setting(contentEl).setName(t("Master View ID")).setDesc(t("The view ID of the main tab (will be replaced by the group tab)")).addText((text) => text.onChange((value) => this.masterId = value));
    new import_obsidian24.Setting(contentEl).setName(t("Slave View ID")).setDesc(t("The view ID of the split tab (hidden until group is active)")).addText((text) => text.onChange((value) => this.slaveId = value));
    new import_obsidian24.Setting(contentEl).setName(t("Group Name")).setDesc(t("Name to display on the tab")).addText((text) => text.onChange((value) => this.groupName = value));
    new import_obsidian24.Setting(contentEl).setName(t("Group Icon")).setDesc(t("SVG Code or Lucide Icon Name")).addTextArea((text) => text.setPlaceholder('<svg...> or "star"').onChange((value) => this.groupSvg = value));
    new import_obsidian24.Setting(contentEl).addButton((btn) => btn.setButtonText(t("Add Group")).setCta().onClick(async () => {
      if (await this.createGroup()) {
        this.close();
        this.onSubmit();
      }
    }));
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
  async createGroup() {
    const settings = this.manager.plugin.settings.mySideBar.tabs;
    if (!this.masterId || !this.slaveId) {
      new import_obsidian24.Notice(t("Error: Invalid ID"));
      return false;
    }
    const masterParams = settings.elements[this.masterId];
    const slaveParams = settings.elements[this.slaveId];
    if (!masterParams || !slaveParams) {
      new import_obsidian24.Notice(t("Error: Invalid ID"));
      return false;
    }
    if (masterParams.side !== slaveParams.side) {
      new import_obsidian24.Notice(t("Error: Same Side"));
      return false;
    }
    if (!settings.bindings)
      settings.bindings = [];
    if (settings.bindings.some((b) => b.masterId === this.masterId)) {
      new import_obsidian24.Notice(t("Error: Master ID already bound"));
      return false;
    }
    const newBinding = {
      masterId: this.masterId,
      slaveId: this.slaveId,
      groupName: this.groupName,
      groupSvg: this.groupSvg
    };
    settings.bindings.push(newBinding);
    settings.elements[this.slaveId].visible = false;
    settings.elements[this.masterId].visible = true;
    settings.elements[this.slaveId].order = settings.elements[this.masterId].order + 0.01;
    const all = Object.values(settings.elements).sort((a, b) => a.order - b.order);
    all.forEach((el, idx) => el.order = idx);
    await this.manager.plugin.saveSettings();
    const leaves = this.manager.contextualFeature.findLeavesByType(this.masterId);
    leaves.forEach((l) => this.manager.contextualFeature.applyVisualOverride(l, newBinding));
    await this.manager.tabsFeature.applyLayout();
    return true;
  }
};

// src/sidebar/settings-ui.ts
function renderSidebarSettings(containerEl, manager) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i;
  createToggledSubSection(
    containerEl,
    t("Auto Hide"),
    (_c = (_b = (_a = manager.plugin.settings.mySideBar) == null ? void 0 : _a.autoHide) == null ? void 0 : _b.enabled) != null ? _c : true,
    async (enabled) => {
      if (!manager.plugin.settings.mySideBar.autoHide)
        manager.plugin.settings.mySideBar.autoHide = { ...DEFAULT_MY_SIDEBAR_SETTINGS.autoHide };
      manager.plugin.settings.mySideBar.autoHide.enabled = enabled;
      await manager.plugin.saveSettings();
      if (enabled)
        manager.autoHideFeature.load();
      else
        manager.autoHideFeature.unload();
    },
    (contentEl) => {
      renderAutoHideSettings(contentEl, manager);
    }
  );
  createToggledSubSection(
    containerEl,
    t("Ribbon Buttons"),
    (_f = (_e = (_d = manager.plugin.settings.mySideBar) == null ? void 0 : _d.ribbon) == null ? void 0 : _e.enabled) != null ? _f : true,
    async (enabled) => {
      if (!manager.plugin.settings.mySideBar.ribbon)
        manager.plugin.settings.mySideBar.ribbon = { ...DEFAULT_MY_SIDEBAR_SETTINGS.ribbon };
      manager.plugin.settings.mySideBar.ribbon.enabled = enabled;
      await manager.plugin.saveSettings();
      if (enabled)
        await manager.ribbonFeature.onload();
      else
        manager.ribbonFeature.onunload();
    },
    (contentEl) => {
      renderRibbonSettings(contentEl, manager);
    }
  );
  createToggledSubSection(
    containerEl,
    t("Sidebar Tabs"),
    (_i = (_h = (_g = manager.plugin.settings.mySideBar) == null ? void 0 : _g.tabs) == null ? void 0 : _h.enabled) != null ? _i : true,
    async (enabled) => {
      if (!manager.plugin.settings.mySideBar.tabs)
        manager.plugin.settings.mySideBar.tabs = { ...DEFAULT_MY_SIDEBAR_SETTINGS.tabs };
      manager.plugin.settings.mySideBar.tabs.enabled = enabled;
      await manager.plugin.saveSettings();
      if (enabled)
        await manager.tabsFeature.onload();
    },
    (contentEl) => {
      renderSidebarTabsSettings(contentEl, manager);
    }
  );
}
function createToggledSubSection(containerEl, title, isEnabled, onToggle, renderBody) {
  const details = containerEl.createEl("details");
  details.style.marginBottom = "10px";
  details.style.border = "1px solid var(--background-modifier-border)";
  details.style.borderRadius = "5px";
  details.style.padding = "0.5em";
  const summary = details.createEl("summary");
  summary.style.cursor = "pointer";
  summary.style.display = "flex";
  summary.style.alignItems = "center";
  summary.style.justifyContent = "space-between";
  summary.style.outline = "none";
  const titleEl = summary.createEl("span");
  titleEl.style.fontWeight = "bold";
  titleEl.innerText = title;
  const toggleContainer = summary.createEl("span");
  toggleContainer.addEventListener("click", (e) => e.stopPropagation());
  new import_obsidian25.ToggleComponent(toggleContainer).setValue(isEnabled).onChange((value) => {
    onToggle(value);
  });
  const content = details.createEl("div");
  content.style.marginTop = "10px";
  content.style.paddingLeft = "5px";
  content.style.borderLeft = "2px solid var(--background-modifier-border)";
  if (isEnabled) {
    renderBody(content);
  } else {
    content.createEl("div", { text: t("Feature is disabled."), cls: "setting-item-description" });
  }
}
function renderAutoHideSettings(containerEl, manager) {
  const plugin = manager.plugin;
  const settings = plugin.settings.mySideBar.autoHide;
  new import_obsidian25.Setting(containerEl).setName(t("Left sidebar hover")).setDesc(t("Enables the expansion and collapsing of the left sidebar on hover.")).addToggle((t2) => t2.setValue(settings.leftSidebar).onChange(async (v) => {
    settings.leftSidebar = v;
    await plugin.saveSettings();
  }));
  new import_obsidian25.Setting(containerEl).setName(t("Right sidebar hover")).setDesc(t("Enables the expansion and collapsing of the right sidebar on hover. Only collapses the right panel unless you have a right ribbon.")).addToggle((t2) => t2.setValue(settings.rightSidebar).onChange(async (v) => {
    settings.rightSidebar = v;
    await plugin.saveSettings();
  }));
  new import_obsidian25.Setting(containerEl).setName(t("Sync left and right")).setDesc(t("If enabled, hovering over the right sidebar will also expand the left sidebar at the same time, and vice versa. (Left and Right sidebar must both be enabled above)")).addToggle((t2) => t2.setValue(settings.syncLeftRight).onChange(async (v) => {
    settings.syncLeftRight = v;
    await plugin.saveSettings();
  }));
  new import_obsidian25.Setting(containerEl).setName(t("Overlay mode")).setDesc(t("When enabled, sidebars will slide over the main content without affecting the layout. When disabled, sidebars will expand by pushing content.")).addToggle((t2) => t2.setValue(settings.overlayMode).onChange(async (v) => {
    settings.overlayMode = v;
    document.body.toggleClass("obsidian-assistant-overlay-mode", v);
    await plugin.saveSettings();
  }));
  new import_obsidian25.Setting(containerEl).setName(t("Behavior")).setHeading();
  new import_obsidian25.Setting(containerEl).setName(t("Left sidebar pixel trigger")).setDesc(t("Specify the number of pixels from the left edge of the editor that will trigger the left sidebar to open on hover (must be greater than 0)")).addText((text) => text.setValue(String(settings.leftSideBarPixelTrigger)).onChange(async (v) => {
    const num = parseInt(v);
    if (!isNaN(num) && num > 0) {
      settings.leftSideBarPixelTrigger = num;
      await plugin.saveSettings();
    }
  }));
  new import_obsidian25.Setting(containerEl).setName(t("Right sidebar pixel trigger")).setDesc(t("Specify the number of pixels from the right edge of the editor that will trigger the right sidebar to open on hover (must be greater than 0)")).addText((text) => text.setValue(String(settings.rightSideBarPixelTrigger)).onChange(async (v) => {
    const num = parseInt(v);
    if (!isNaN(num) && num > 0) {
      settings.rightSideBarPixelTrigger = num;
      await plugin.saveSettings();
    }
  }));
  new import_obsidian25.Setting(containerEl).setName(t("Timing")).setHeading();
  new import_obsidian25.Setting(containerEl).setName(t("Sidebar collapse delay")).setDesc(t("The delay in milliseconds before the sidebar collapses after the mouse has left. Enter '0' to disable delay.")).addText((text) => text.setValue(String(settings.sidebarDelay)).onChange(async (v) => {
    const num = parseInt(v);
    if (!isNaN(num) && num >= 0) {
      settings.sidebarDelay = num;
      await plugin.saveSettings();
    }
  }));
  new import_obsidian25.Setting(containerEl).setName(t("Sidebar expand delay")).setDesc(t("The delay in milliseconds before the sidebar expands after hovering. Default is 200ms.")).addText((text) => text.setValue(String(settings.sidebarExpandDelay)).onChange(async (v) => {
    const num = parseInt(v);
    if (!isNaN(num) && num >= 0) {
      settings.sidebarExpandDelay = num;
      await plugin.saveSettings();
    }
  }));
  new import_obsidian25.Setting(containerEl).setName(t("Expand/collapse animation speed")).setDesc(t("The speed of the sidebar expand/collapse animation in milliseconds.")).addText((text) => text.setValue(String(settings.expandCollapseSpeed)).onChange(async (v) => {
    const num = parseInt(v);
    if (!isNaN(num) && num > 0) {
      settings.expandCollapseSpeed = num;
      await plugin.saveSettings();
    }
  }));
  new import_obsidian25.Setting(containerEl).setName(t("Appearance")).setHeading();
  new import_obsidian25.Setting(containerEl).setName(t("Left sidebar maximum width")).setDesc(t("Specify the maximum width in pixels for the left sidebar when expanded")).addText((text) => text.setValue(String(settings.leftSidebarMaxWidth)).onChange(async (v) => {
    const num = parseInt(v);
    if (!isNaN(num) && num > 0) {
      settings.leftSidebarMaxWidth = num;
      await plugin.saveSettings();
    }
  }));
  new import_obsidian25.Setting(containerEl).setName(t("Right sidebar maximum width")).setDesc(t("Specify the maximum width in pixels for the right sidebar when expanded")).addText((text) => text.setValue(String(settings.rightSidebarMaxWidth)).onChange(async (v) => {
    const num = parseInt(v);
    if (!isNaN(num) && num > 0) {
      settings.rightSidebarMaxWidth = num;
      await plugin.saveSettings();
    }
  }));
}
function renderRibbonSettings(containerEl, manager) {
  containerEl.empty();
  const plugin = manager.plugin;
  const settings = plugin.settings.mySideBar.ribbon;
  manager.ribbonFeature.processRibbon().then(() => {
    new import_obsidian25.Setting(containerEl).setName(t("Startup Display Delay")).setDesc(t("Delay in milliseconds before showing ribbon icons on startup. If 'My Plugins' is enabled, this acts as a buffer time added to the max plugin load delay.")).addText((text) => text.setPlaceholder("1000").setValue(String(settings.ribbonDisplayDelay)).onChange(async (value) => {
      const num = parseInt(value);
      if (!isNaN(num) && num >= 0) {
        settings.ribbonDisplayDelay = num;
        await plugin.saveSettings();
      }
    }));
    const elements = Object.values(settings.elements).sort((a, b) => a.order - b.order);
    const info = containerEl.createEl("div", { cls: "setting-item-description" });
    info.style.marginBottom = "10px";
    info.innerText = t("Drag to reorder ribbon icons. Click eye icon to toggle visibility.");
    const rowsContainer = containerEl.createEl("div");
    rowsContainer.addClass("statusbar-organizer-rows-container");
    if (elements.length === 0) {
      rowsContainer.createEl("div", { text: t("No ribbon elements found yet.") });
      return;
    }
    elements.forEach((el) => {
      renderRibbonRow(rowsContainer, el, manager, elements);
    });
  });
}
function renderRibbonRow(container, el, manager, allElements) {
  const rowEntry = container.createEl("div");
  rowEntry.addClass("statusbar-organizer-row");
  rowEntry.style.gridTemplateColumns = "2em 1fr 2em";
  if (!el.visible)
    rowEntry.addClass("statusbar-organizer-row-hidden");
  rowEntry.setAttribute("data-ribbon-id", el.id);
  const handle = rowEntry.createEl("span");
  handle.addClass("statusbar-organizer-row-handle");
  handle.addEventListener("mousedown", (e) => handleRibbonDrag(e, rowEntry, el, manager, container, allElements));
  const nameContainer = rowEntry.createEl("span", { cls: "statusbar-organizer-row-title" });
  nameContainer.style.display = "flex";
  nameContainer.style.alignItems = "center";
  nameContainer.style.gap = "8px";
  if (el.icon) {
    const iconSpan = nameContainer.createEl("span");
    iconSpan.innerHTML = el.icon;
    const svg = iconSpan.querySelector("svg");
    if (svg) {
      svg.setAttribute("width", "16");
      svg.setAttribute("height", "16");
      svg.style.verticalAlign = "middle";
    }
  }
  nameContainer.createEl("span", { text: el.name || el.id });
  const visBtn = rowEntry.createEl("span", { cls: "statusbar-organizer-row-visibility" });
  visBtn.style.cursor = "pointer";
  (0, import_obsidian25.setIcon)(visBtn, el.visible ? "eye" : "eye-off");
  visBtn.addEventListener("click", async () => {
    await manager.ribbonFeature.toggleVisibility(el.id);
    if (manager.plugin.settings.mySideBar.ribbon.elements[el.id].visible) {
      rowEntry.removeClass("statusbar-organizer-row-hidden");
      (0, import_obsidian25.setIcon)(visBtn, "eye");
    } else {
      rowEntry.addClass("statusbar-organizer-row-hidden");
      (0, import_obsidian25.setIcon)(visBtn, "eye-off");
    }
  });
}
function handleRibbonDrag(e, row, el, manager, container, allElements) {
  e.preventDefault();
  const startY = e.clientY;
  const startIndex = Array.from(container.children).indexOf(row);
  let newIndex = startIndex;
  const onMouseMove = (moveEvent) => {
    const currentY = moveEvent.clientY;
    const siblings = Array.from(container.children);
    const rowHeight = row.offsetHeight;
    const delta = Math.round((currentY - startY) / rowHeight);
    newIndex = Math.max(0, Math.min(siblings.length - 1, startIndex + delta));
    siblings.forEach((sibling, index) => {
      if (sibling === row)
        return;
      if (index === newIndex) {
        if (startIndex < newIndex)
          sibling.after(row);
        else
          sibling.before(row);
      }
    });
  };
  const onMouseUp = async () => {
    document.removeEventListener("mousemove", onMouseMove);
    document.removeEventListener("mouseup", onMouseUp);
    if (newIndex !== startIndex) {
      allElements.splice(startIndex, 1);
      allElements.splice(newIndex, 0, el);
      allElements.forEach((item, index) => {
        manager.plugin.settings.mySideBar.ribbon.elements[item.id].order = index;
      });
      await manager.plugin.saveSettings();
      await manager.ribbonFeature.processRibbon();
    }
  };
  document.addEventListener("mousemove", onMouseMove);
  document.addEventListener("mouseup", onMouseUp);
}
function renderSidebarTabsSettings(containerEl, manager) {
  containerEl.empty();
  const settings = manager.plugin.settings.mySideBar.tabs;
  new import_obsidian25.Setting(containerEl).setName(t("Scan Current Layout")).setDesc(t("Scan and apply")).addButton((btn) => btn.setButtonText(t("Scan")).onClick(async () => {
    await manager.tabsFeature.scanAndApply();
    renderSidebarTabsSettings(containerEl, manager);
  }));
  new import_obsidian25.Setting(containerEl).setName(t("Add New Group")).setDesc(t("Create a new contextual group binding")).addButton((btn) => btn.setButtonText(t("Add Group")).onClick(() => {
    new GroupModal(manager.app, manager, () => renderSidebarTabsSettings(containerEl, manager)).open();
  }));
  const elements = Object.values(settings.elements).sort((a, b) => a.order - b.order);
  const bindings = settings.bindings || [];
  const slaveIds = bindings.map((b) => b.slaveId);
  const leftElements = elements.filter((e) => e.side === "left" && e.visible && !slaveIds.includes(e.id));
  const rightElements = elements.filter((e) => e.side === "right" && e.visible && !slaveIds.includes(e.id));
  const hiddenElements = elements.filter((e) => !e.visible && !slaveIds.includes(e.id));
  renderTabGroup(containerEl, t("Left Sidebar"), leftElements, manager);
  renderTabGroup(containerEl, t("Right Sidebar"), rightElements, manager);
  renderTabGroup(containerEl, t("Hidden"), hiddenElements, manager);
}
function renderTabGroup(container, title, groupElements, manager) {
  if (groupElements.length === 0 && title !== t("Hidden"))
    return;
  const heading = container.createEl("div", {
    cls: "setting-item setting-item-heading",
    text: title
  });
  heading.style.color = "var(--text-success)";
  if (groupElements.length === 0) {
    container.createEl("div", { text: t("No elements"), cls: "setting-item-description", style: "margin-bottom: 20px; font-style: italic;" });
    return;
  }
  const listContainer = container.createDiv();
  groupElements.forEach((el) => {
    renderTabRow(listContainer, el, manager);
  });
}
function renderTabRow(container, el, manager) {
  const row = container.createEl("div", { cls: "setting-item" });
  row.style.borderTop = "none";
  row.style.borderBottom = "1px solid var(--background-modifier-border)";
  row.style.display = "flex";
  row.style.alignItems = "center";
  row.setAttribute("data-tab-id", el.id);
  const settings = manager.plugin.settings.mySideBar.tabs;
  const bindings = settings.bindings || [];
  const binding = bindings.find((b) => b.masterId === el.id);
  const handle = row.createEl("span");
  handle.addClass("statusbar-organizer-row-handle");
  handle.style.marginRight = "8px";
  handle.style.flexShrink = "0";
  handle.style.alignSelf = "center";
  handle.addEventListener("mousedown", (e) => handleTabDrag(e, row, el, manager, container));
  const iconToUse = binding && binding.groupSvg ? binding.groupSvg : el.icon;
  if (iconToUse) {
    const iconSpan = row.createEl("span");
    iconSpan.style.display = "flex";
    iconSpan.style.alignItems = "center";
    iconSpan.style.marginRight = "8px";
    iconSpan.style.color = "var(--text-muted)";
    iconSpan.style.flexShrink = "0";
    iconSpan.style.alignSelf = "center";
    if (iconToUse.startsWith("<svg") || iconToUse.includes("xmlns")) {
      iconSpan.innerHTML = iconToUse;
      const svg = iconSpan.querySelector("svg");
      if (svg) {
        svg.setAttribute("width", "16");
        svg.setAttribute("height", "16");
      }
    } else {
      (0, import_obsidian25.setIcon)(iconSpan, iconToUse);
      const svg = iconSpan.querySelector("svg");
      if (svg) {
        svg.setAttribute("width", "16");
        svg.setAttribute("height", "16");
      }
    }
  }
  const info = row.createEl("div", { cls: "setting-item-info" });
  info.style.alignSelf = "center";
  let displayName = el.id;
  if (binding) {
    const namePart = binding.groupName ? binding.groupName : "Group";
    displayName = `${namePart} (${binding.masterId} + ${binding.slaveId})`;
  }
  info.createEl("div", { cls: "setting-item-name", text: displayName });
  const control = row.createEl("div", { cls: "setting-item-control" });
  if (binding) {
    new import_obsidian25.ButtonComponent(control).setButtonText(t("Unbind")).setWarning().onClick(async () => {
      const index = bindings.indexOf(binding);
      if (index > -1) {
        const master = settings.elements[binding.masterId];
        const slave = settings.elements[binding.slaveId];
        if (slave && master) {
          slave.visible = true;
          slave.side = master.side;
          slave.order = master.order + 0.5;
          const all = Object.values(settings.elements).sort((a, b) => a.order - b.order);
          all.forEach((item, idx) => item.order = idx);
        }
        bindings.splice(index, 1);
        settings.bindings = bindings;
        await manager.plugin.saveSettings();
        const leaves = manager.contextualFeature.findLeavesByType(binding.masterId);
        leaves.forEach((l) => manager.contextualFeature.restoreVisuals(l, binding.masterId));
        await manager.tabsFeature.applyLayout();
        renderSidebarTabsSettings(container.parentElement.parentElement, manager);
      }
    });
  } else {
    new import_obsidian25.DropdownComponent(control).addOption("left", t("Left Sidebar")).addOption("right", t("Right Sidebar")).addOption("hidden", t("Hidden")).setValue(el.visible ? el.side : "hidden").onChange(async (value) => {
      if (value === "hidden") {
        await manager.tabsFeature.updateTab(el.id, { visible: false });
      } else {
        await manager.tabsFeature.updateTab(el.id, { side: value, visible: true });
      }
      renderSidebarTabsSettings(container.parentElement.parentElement, manager);
    });
  }
}
function handleTabDrag(e, row, el, manager, container) {
  e.preventDefault();
  const startY = e.clientY;
  const startIndex = Array.from(container.children).indexOf(row);
  let newIndex = startIndex;
  const onMouseMove = (moveEvent) => {
    const currentY = moveEvent.clientY;
    const siblings = Array.from(container.children);
    const rowHeight = row.offsetHeight;
    const delta = Math.round((currentY - startY) / rowHeight);
    newIndex = Math.max(0, Math.min(siblings.length - 1, startIndex + delta));
    siblings.forEach((sibling, index) => {
      if (sibling === row)
        return;
      if (index === newIndex) {
        if (startIndex < newIndex)
          sibling.after(row);
        else
          sibling.before(row);
      }
    });
  };
  const onMouseUp = async () => {
    document.removeEventListener("mousemove", onMouseMove);
    document.removeEventListener("mouseup", onMouseUp);
    if (newIndex !== startIndex) {
      const settings = manager.plugin.settings.mySideBar.tabs;
      const siblings = Array.from(container.children);
      const orderedIds = siblings.map((s) => s.getAttribute("data-tab-id")).filter((id) => id && settings.elements[id]);
      if (orderedIds.length > 0) {
        const subsetElements = orderedIds.map((id) => settings.elements[id]);
        const availableOrders = subsetElements.map((x) => x.order).sort((a, b) => a - b);
        orderedIds.forEach((id, idx) => {
          if (id) {
            settings.elements[id].order = availableOrders[idx];
          }
        });
      }
      const bindings = settings.bindings || [];
      bindings.forEach((b) => {
        const master = settings.elements[b.masterId];
        const slave = settings.elements[b.slaveId];
        if (master && slave) {
          slave.order = master.order + 0.01;
        }
      });
      const all = Object.values(settings.elements).sort((a, b) => a.order - b.order);
      all.forEach((item, index) => item.order = index);
      await manager.plugin.saveSettings();
      await manager.tabsFeature.applyLayout();
    }
  };
  document.addEventListener("mousemove", onMouseMove);
  document.addEventListener("mouseup", onMouseUp);
}

// src/utils/auto-numbering.ts
var import_obsidian26 = require("obsidian");
var AutoNumberingController = class {
  // Default refresh interval matching source
  constructor(app, plugin, headingsManager, formulasManager) {
    this.autoUpdateTimeout = null;
    this.isLoaded = false;
    this.isDirty = false;
    this.dirtyRef = null;
    this.app = app;
    this.plugin = plugin;
    this.headingsManager = headingsManager;
    this.formulasManager = formulasManager;
  }
  onload() {
    if (this.isLoaded)
      return;
    this.registerEditorFocusEvents();
    this.dirtyRef = this.app.workspace.on("editor-change", () => {
      this.isDirty = true;
    });
    this.isLoaded = true;
  }
  onunload() {
    if (!this.isLoaded)
      return;
    this.clearAutoUpdateTimer();
    window.removeEventListener("blur", this.blurHandler);
    window.removeEventListener("focus", this.focusHandler);
    if (this.dirtyRef) {
      this.app.workspace.offref(this.dirtyRef);
      this.dirtyRef = null;
    }
    this.isLoaded = false;
  }
  registerEditorFocusEvents() {
    this.blurHandler = () => this.handleBlur();
    this.focusHandler = () => this.handleFocus();
    window.addEventListener("blur", this.blurHandler);
    window.addEventListener("focus", this.focusHandler);
  }
  handleBlur() {
    if (!this.isDirty)
      return;
    const activeView = this.app.workspace.getActiveViewOfType(import_obsidian26.MarkdownView);
    if (!activeView || !activeView.file)
      return;
    const data = this.app.metadataCache.getFileCache(activeView.file);
    if (!data)
      return;
    const headingSettings = parseHeadingsFrontMatter(data.frontmatter, this.plugin.settings.myHeadings);
    const formulaSettings = parseFormulasFrontMatter(data.frontmatter, this.plugin.settings.myFormulas);
    const headingsAuto = headingSettings.enabled && headingSettings.auto;
    const formulasAuto = formulaSettings.enabled && formulaSettings.auto;
    if (!headingsAuto && !formulasAuto)
      return;
    this.clearAutoUpdateTimer();
    const delay = this.plugin.settings.refreshInterval || 1e3;
    this.autoUpdateTimeout = window.setTimeout(() => {
      this.performAutoUpdate(activeView, headingSettings, formulaSettings);
    }, delay);
  }
  handleFocus() {
    if (this.autoUpdateTimeout) {
      this.clearAutoUpdateTimer();
    }
  }
  clearAutoUpdateTimer() {
    if (this.autoUpdateTimeout) {
      window.clearTimeout(this.autoUpdateTimeout);
      this.autoUpdateTimeout = null;
    }
  }
  performAutoUpdate(view, headingSettings, formulaSettings) {
    if (!view.editor)
      return;
    const editor = view.editor;
    this.isDirty = false;
    const headingsAuto = headingSettings.enabled && headingSettings.auto;
    const formulasAuto = formulaSettings.enabled && formulaSettings.auto;
    if (!headingsAuto && !formulasAuto)
      return;
    const cursorBefore = editor.getCursor();
    const scrollBefore = editor.getScrollInfo();
    let isChanged = false;
    try {
      if (headingsAuto) {
        if (this.headingsManager.updateNumbering(false, false)) {
          isChanged = true;
        }
      }
      if (formulasAuto) {
        if (this.formulasManager.updateNumbering(false, false)) {
          isChanged = true;
        }
      }
    } catch (e) {
      console.error("AutoNumbering: Error during update logic", e);
      this.autoUpdateTimeout = null;
      return;
    }
    if (isChanged) {
      restoreCursor(editor, cursorBefore);
      editor.scrollTo(scrollBefore.left, scrollBefore.top);
    }
    this.autoUpdateTimeout = null;
  }
};

// src/main.ts
var AssistantPlugin = class extends import_obsidian27.Plugin {
  async onload() {
    console.log(t("Loading Obsidian Assistant..."));
    console.log(t("Loading Settings..."));
    await this.loadSettings();
    this.foldersManager = new FoldersManager(this.app, this);
    this.pluginsManager = new PluginsManager(this.app, this);
    this.statusBarManager = new StatusBarManager(this.app, this);
    this.snippetsManager = new SnippetsManager(this.app, this);
    this.headingsManager = new HeadingsManager(this.app, this);
    this.formulasManager = new FormulasManager(this.app, this);
    this.sidebarManager = new SidebarManager(this.app, this);
    this.autoNumberingController = new AutoNumberingController(this.app, this, this.headingsManager, this.formulasManager);
    if (this.settings.myFolders.enabled)
      await this.foldersManager.onload();
    if (this.settings.myPlugins.enabled)
      await this.pluginsManager.onload();
    if (this.settings.myStatusBar.enabled)
      await this.statusBarManager.onload();
    if (this.settings.mySnippets.enabled)
      await this.snippetsManager.onload();
    if (this.settings.myHeadings.enabled)
      await this.headingsManager.onload();
    if (this.settings.myFormulas.enabled)
      await this.formulasManager.onload();
    if (this.settings.mySideBar.enabled)
      await this.sidebarManager.onload();
    if (this.settings.myHeadings.enabled || this.settings.myFormulas.enabled) {
      this.autoNumberingController.onload();
    }
    this.addCommand({
      id: "toggle-attachment-folders",
      name: t("Toggle visibility of hidden folders"),
      callback: () => {
        if (this.settings.myFolders.enabled)
          this.foldersManager.toggleFunctionality();
      }
    });
    this.addCommand({
      id: `open-snippets-menu`,
      name: t(`Open snippets in status bar`),
      icon: `pantone-line`,
      callback: async () => {
        if (this.settings.mySnippets.enabled)
          this.snippetsManager.openMenu();
      }
    });
    this.addCommand({
      id: `open-snippets-create`,
      name: t(`Create new CSS snippet`),
      icon: `ms-css-file`,
      callback: async () => {
        if (this.settings.mySnippets.enabled)
          this.snippetsManager.openCreateModal();
      }
    });
    this.addCommand({
      id: "configure-headings",
      name: t("Configure Headings"),
      callback: () => {
        if (this.settings.myHeadings.enabled)
          this.headingsManager.openControlModal();
      }
    });
    this.addCommand({
      id: "configure-formulas",
      name: t("Configure Formulas"),
      callback: () => {
        if (this.settings.myFormulas.enabled)
          this.formulasManager.openControlModal();
      }
    });
    this.addSettingTab(new AssistantSettingsTab(this.app, this));
  }
  onunload() {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    console.log(t("Unloading Obsidian Assistant..."));
    (_a = this.foldersManager) == null ? void 0 : _a.onunload();
    (_b = this.pluginsManager) == null ? void 0 : _b.onunload();
    (_c = this.statusBarManager) == null ? void 0 : _c.onunload();
    (_d = this.snippetsManager) == null ? void 0 : _d.onunload();
    (_e = this.headingsManager) == null ? void 0 : _e.onunload();
    (_f = this.formulasManager) == null ? void 0 : _f.onunload();
    (_g = this.sidebarManager) == null ? void 0 : _g.onunload();
    (_h = this.autoNumberingController) == null ? void 0 : _h.onunload();
  }
  async loadSettings() {
    const loadedData = await this.loadData();
    if (loadedData) {
      this.migrateSettings(loadedData);
    }
    this.settings = Object.assign({}, DEFAULT_SETTINGS, loadedData);
    if (loadedData == null ? void 0 : loadedData.myHeadings) {
      this.settings.myHeadings = Object.assign({}, DEFAULT_SETTINGS.myHeadings, loadedData.myHeadings);
      if (loadedData.myHeadings.styleToRemove) {
        this.settings.myHeadings.styleToRemove = {
          beginning: Object.assign({}, DEFAULT_SETTINGS.myHeadings.styleToRemove.beginning, loadedData.myHeadings.styleToRemove.beginning),
          surrounding: Object.assign({}, DEFAULT_SETTINGS.myHeadings.styleToRemove.surrounding, loadedData.myHeadings.styleToRemove.surrounding)
        };
      }
    }
    if (loadedData == null ? void 0 : loadedData.myFormulas) {
      this.settings.myFormulas = Object.assign({}, DEFAULT_SETTINGS.myFormulas, loadedData.myFormulas);
    }
    if (loadedData == null ? void 0 : loadedData.myFolders) {
      this.settings.myFolders = Object.assign({}, DEFAULT_SETTINGS.myFolders, loadedData.myFolders);
    }
    if (loadedData == null ? void 0 : loadedData.myPlugins) {
      this.settings.myPlugins = Object.assign({}, DEFAULT_SETTINGS.myPlugins, loadedData.myPlugins);
      if (loadedData.myPlugins.desktop) {
        this.settings.myPlugins.desktop = Object.assign({}, DEFAULT_SETTINGS.myPlugins.desktop, loadedData.myPlugins.desktop);
      }
      if (loadedData.myPlugins.mobile) {
        this.settings.myPlugins.mobile = Object.assign({}, DEFAULT_SETTINGS.myPlugins.mobile, loadedData.myPlugins.mobile);
      }
    }
    if (loadedData == null ? void 0 : loadedData.mySnippets) {
      this.settings.mySnippets = Object.assign({}, DEFAULT_SETTINGS.mySnippets, loadedData.mySnippets);
    }
    if (loadedData == null ? void 0 : loadedData.mySideBar) {
      this.settings.mySideBar = Object.assign({}, DEFAULT_SETTINGS.mySideBar, loadedData.mySideBar);
      if (loadedData.mySideBar.autoHide) {
        this.settings.mySideBar.autoHide = Object.assign({}, DEFAULT_SETTINGS.mySideBar.autoHide, loadedData.mySideBar.autoHide);
      }
      if (loadedData.mySideBar.ribbon) {
        this.settings.mySideBar.ribbon = Object.assign({}, DEFAULT_SETTINGS.mySideBar.ribbon, loadedData.mySideBar.ribbon);
      }
      if (loadedData.mySideBar.tabs) {
        this.settings.mySideBar.tabs = Object.assign({}, DEFAULT_SETTINGS.mySideBar.tabs, loadedData.mySideBar.tabs);
        if (this.settings.mySideBar.tabs.bindings) {
          this.settings.mySideBar.tabs.bindings.forEach((b) => {
            if (b.splitRatio !== void 0) {
              b.splitRatio = Math.round(b.splitRatio);
              if (b.splitRatio < 10)
                b.splitRatio = 10;
              if (b.splitRatio > 90)
                b.splitRatio = 90;
            }
          });
        }
      }
    }
    await this.saveSettings();
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  migrateSettings(data) {
    if (data.myStatusBar) {
      delete data.myStatusBar.presets;
      delete data.myStatusBar.activePreset;
      delete data.myStatusBar.activeFullscreenPreset;
      delete data.myStatusBar.separateFullscreenPreset;
      delete data.myStatusBar.presetsOrder;
    }
    delete data.statusBar;
    delete data.statusBarOrganizer;
  }
};
var AssistantSettingsTab = class extends import_obsidian27.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  refreshAutoNumberingController() {
    const anyActive = this.plugin.settings.myHeadings.enabled || this.plugin.settings.myFormulas.enabled;
    this.plugin.autoNumberingController.onunload();
    if (anyActive) {
      this.plugin.autoNumberingController.onload();
    }
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: t("Obsidian Assistant Settings") });
    containerEl.createEl("h3", { text: t("Global Settings") });
    new import_obsidian27.Setting(containerEl).setName(t("Auto-Numbering Refresh Interval")).setDesc(t("Time in milliseconds to wait before auto-numbering triggers (after losing focus)")).addText((text) => text.setPlaceholder("1000").setValue(String(this.plugin.settings.refreshInterval)).onChange(async (value) => {
      const interval = parseInt(value);
      if (!isNaN(interval) && interval > 0) {
        this.plugin.settings.refreshInterval = interval;
        await this.plugin.saveSettings();
      }
    }));
    containerEl.createEl("br");
    containerEl.createEl("h3", { text: t("Modules") });
    this.addPluginSection(
      containerEl,
      t("My Folders"),
      this.plugin.settings.myFolders.enabled,
      async (value) => {
        this.plugin.settings.myFolders.enabled = value;
        await this.plugin.saveSettings();
        if (value) {
          this.plugin.foldersManager.onload();
        } else {
          this.plugin.foldersManager.onunload();
        }
      },
      (el) => {
        renderFoldersSettings(el, this.plugin.foldersManager);
      }
    );
    this.addPluginSection(
      containerEl,
      t("My Plugins"),
      this.plugin.settings.myPlugins.enabled,
      async (value) => {
        this.plugin.settings.myPlugins.enabled = value;
        await this.plugin.saveSettings();
        if (value) {
          this.plugin.pluginsManager.onload();
        } else {
          this.plugin.pluginsManager.onunload();
        }
      },
      (el) => {
        renderPluginsSettings(el, this.plugin.pluginsManager);
      }
    );
    this.addPluginSection(
      containerEl,
      t("My Status Bar"),
      this.plugin.settings.myStatusBar.enabled,
      async (value) => {
        this.plugin.settings.myStatusBar.enabled = value;
        await this.plugin.saveSettings();
        if (value) {
          this.plugin.statusBarManager.onload();
        } else {
          this.plugin.statusBarManager.onunload();
        }
      },
      (el) => {
        renderStatusBarSettings(el, this.plugin.statusBarManager);
      }
    );
    this.addPluginSection(
      containerEl,
      t("My Snippets"),
      this.plugin.settings.mySnippets.enabled,
      async (value) => {
        this.plugin.settings.mySnippets.enabled = value;
        await this.plugin.saveSettings();
        if (value) {
          this.plugin.snippetsManager.onload();
        } else {
          this.plugin.snippetsManager.onunload();
        }
      },
      (el) => {
        renderSnippetsSettings(el, this.plugin.snippetsManager);
      }
    );
    this.addPluginSection(
      containerEl,
      t("My Headings"),
      this.plugin.settings.myHeadings.enabled,
      async (value) => {
        this.plugin.settings.myHeadings.enabled = value;
        await this.plugin.saveSettings();
        if (value) {
          await this.plugin.headingsManager.onload();
        } else {
          this.plugin.headingsManager.onunload();
        }
        this.refreshAutoNumberingController();
      },
      (el) => {
        renderHeadingsSettings(el, this.plugin.headingsManager);
      }
    );
    this.addPluginSection(
      containerEl,
      t("My Formulas"),
      this.plugin.settings.myFormulas.enabled,
      async (value) => {
        this.plugin.settings.myFormulas.enabled = value;
        await this.plugin.saveSettings();
        if (value) {
          await this.plugin.formulasManager.onload();
        } else {
          this.plugin.formulasManager.onunload();
        }
        this.refreshAutoNumberingController();
      },
      (el) => {
        renderFormulasSettings(el, this.plugin.formulasManager);
      }
    );
    this.addPluginSection(
      containerEl,
      t("My SideBar"),
      this.plugin.settings.mySideBar.enabled,
      async (value) => {
        this.plugin.settings.mySideBar.enabled = value;
        await this.plugin.saveSettings();
        if (value) {
          this.plugin.sidebarManager.onload();
        } else {
          this.plugin.sidebarManager.onunload();
        }
      },
      (el) => {
        renderSidebarSettings(el, this.plugin.sidebarManager);
      }
    );
  }
  addPluginSection(containerEl, title, isEnabled, onToggle, renderBody) {
    const details = containerEl.createEl("details");
    details.open = false;
    details.style.marginBottom = "1em";
    details.style.border = "1px solid var(--background-modifier-border)";
    details.style.borderRadius = "5px";
    const summary = details.createEl("summary");
    summary.style.display = "flex";
    summary.style.alignItems = "center";
    summary.style.justifyContent = "space-between";
    summary.style.padding = "0.5em 1em";
    summary.style.cursor = "pointer";
    summary.style.backgroundColor = "var(--background-secondary)";
    summary.style.borderTopLeftRadius = "5px";
    summary.style.borderTopRightRadius = "5px";
    const titleContainer = summary.createEl("div", { cls: "settings-section-title" });
    titleContainer.style.display = "flex";
    titleContainer.style.alignItems = "center";
    titleContainer.style.gap = "10px";
    titleContainer.createEl("strong", { text: title });
    const toggleContainer = summary.createEl("div");
    toggleContainer.onclick = (e) => e.preventDefault();
    const toggleSetting = new import_obsidian27.Setting(toggleContainer).addToggle((toggle) => toggle.setValue(isEnabled).onChange(onToggle));
    toggleSetting.settingEl.style.border = "none";
    toggleSetting.settingEl.style.padding = "0";
    toggleSetting.infoEl.remove();
    const content = details.createEl("div");
    content.style.padding = "1em";
    content.style.borderTop = "1px solid var(--background-modifier-border)";
    if (isEnabled) {
      renderBody(content);
    } else {
      content.createEl("i", { text: t("Module is disabled.") });
    }
  }
};
