/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => AssistantPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian25 = require("obsidian");

// src/settings.ts
var DEFAULT_MY_FOLDERS_SETTINGS = {
  enabled: true,
  areFoldersHidden: true,
  matchCaseInsensitive: true,
  addHiddenFoldersToObsidianIgnoreList: false,
  hideBottomStatusBarIndicatorText: false,
  enableCompatQuickExplorer: false,
  attachmentFolderNames: ["attachments"]
};
var LoadingMethod = /* @__PURE__ */ ((LoadingMethod2) => {
  LoadingMethod2["disabled"] = "disabled";
  LoadingMethod2["instant"] = "instant";
  LoadingMethod2["short"] = "short";
  LoadingMethod2["long"] = "long";
  return LoadingMethod2;
})(LoadingMethod || {});
var DEFAULT_DEVICE_SETTINGS = {
  shortDelaySeconds: 5,
  longDelaySeconds: 15,
  delayBetweenPlugins: 40,
  defaultStartupType: null,
  showDescriptions: true,
  enableDependencies: false,
  plugins: {}
};
var DEFAULT_MY_PLUGINS_SETTINGS = {
  enabled: true,
  dualConfigs: false,
  showConsoleLog: false,
  desktop: DEFAULT_DEVICE_SETTINGS
};
var DEFAULT_STATUS_BAR_SETTINGS = {
  enabled: true,
  activePreset: "Default",
  activeFullscreenPreset: "Default",
  separateFullscreenPreset: false,
  presets: { "Default": {} },
  presetsOrder: ["Default"],
  version: "0.0.1"
};
var DEFAULT_MY_SNIPPETS_SETTINGS = {
  aestheticStyle: false,
  snippetViewPosition: "left",
  openSnippetFile: true,
  stylingTemplate: "",
  snippetEnabledStatus: false,
  showStatusBarIcon: true,
  enabled: true
};
var DEFAULT_MY_HEADINGS_SETTINGS = {
  // Auto Numbering
  enabled: true,
  auto: false,
  firstLevel: 1,
  maxLevel: 6,
  headingStyles: ["1", "a", "A", "\u4E00", "\u2460", "1"],
  headingSeparators: ["", "-", ":", ".", "\u2014", "-"],
  headingStartValues: ["0", "1", "1", "1", "1", "1"],
  skipHeadings: "",
  // Heading Shifter
  limitHeadingFrom: 1,
  overrideTab: false,
  styleToRemove: {
    beginning: {
      ul: true,
      ol: true,
      userDefined: []
    },
    surrounding: {
      bold: true,
      italic: true,
      userDefined: []
    }
  },
  list: {
    childrenBehavior: "outdent to zero"
  },
  editor: {
    tabSize: 4
  }
};
var DEFAULT_MY_FORMULAS_SETTINGS = {
  enabled: true,
  auto: false,
  mode: "continuous",
  maxDepth: 4
};
var DEFAULT_SETTINGS = {
  myFolders: DEFAULT_MY_FOLDERS_SETTINGS,
  myPlugins: DEFAULT_MY_PLUGINS_SETTINGS,
  myStatusBar: DEFAULT_STATUS_BAR_SETTINGS,
  mySnippets: DEFAULT_MY_SNIPPETS_SETTINGS,
  myHeadings: DEFAULT_MY_HEADINGS_SETTINGS,
  myFormulas: DEFAULT_MY_FORMULAS_SETTINGS,
  refreshInterval: 1e3
  // Default 1 second (1000ms) as per source
};

// src/folders/manager.ts
var import_obsidian2 = require("obsidian");

// src/folders/compat.ts
function getFolderNameWithoutPrefix(folderName) {
  if (folderName.toLowerCase().startsWith("endswith::")) {
    return folderName.substring("endsWith::".length).trim();
  } else if (folderName.toLowerCase().startsWith("startswith::")) {
    return folderName.substring("startsWith::".length).trim();
  } else {
    return folderName;
  }
}
var CompatQuickExplorer = {
  getAdditionalDocumentSelectorStringForFolder: function(folderName, pluginSettings) {
    if (folderName.toLowerCase().startsWith("endswith::")) {
      return `.is-qe-folder[data-file-path$="${getFolderNameWithoutPrefix(folderName)}"${pluginSettings.matchCaseInsensitive ? " i" : ""}]`;
    } else if (folderName.toLowerCase().startsWith("startswith::")) {
      return `.is-qe-folder[data-file-path^="${getFolderNameWithoutPrefix(folderName)}"${pluginSettings.matchCaseInsensitive ? " i" : ""}], .is-qe-folder[data-file-path*="/${getFolderNameWithoutPrefix(folderName)}"${pluginSettings.matchCaseInsensitive ? " i" : ""}]`;
    } else {
      return `.is-qe-folder[data-file-path$="/${folderName.trim()}"${pluginSettings.matchCaseInsensitive ? " i" : ""}], .is-qe-folder[data-file-path="${folderName.trim()}"${pluginSettings.matchCaseInsensitive ? " i" : ""}]`;
    }
  },
  shouldMutationRecordTriggerFolderReProcessing: (record) => {
    var _a, _b;
    for (const addedNode of record.addedNodes) {
      if (!addedNode.tagName)
        continue;
      if (addedNode.classList.contains("qe-popup-menu")) {
        const firstQePopUpMenu = document.getElementsByClassName("qe-popup-menu")[0];
        if (!firstQePopUpMenu)
          return true;
        firstQePopUpMenu.style.top = "";
        firstQePopUpMenu.style.bottom = "1.7rem";
        return true;
      }
    }
    if ((_b = (_a = record.target) == null ? void 0 : _a.parentElement) == null ? void 0 : _b.classList.contains("is-qe-folder")) {
      return true;
    }
    return false;
  }
};

// src/i18n/helpers.ts
var import_obsidian = require("obsidian");

// src/i18n/locales/en.ts
var en_default = {
  // General
  "Module is disabled.": "Module is disabled.",
  "Obsidian Assistant Settings": "Obsidian Assistant Settings",
  "Global Settings": "Global Settings",
  "Auto-Numbering Refresh Interval": "Auto-Numbering Refresh Interval",
  "Time in milliseconds to wait before auto-numbering triggers (after losing focus)": "Time in milliseconds to wait before auto-numbering triggers (after losing focus)",
  "Modules": "Modules",
  // My Folders
  "My Folders": "My Folders",
  "Toggle visibility of hidden folders": "Toggle visibility of hidden folders",
  "Show hidden folders": "Show hidden folders",
  "Hide hidden folders again": "Hide hidden folders again",
  "Configured folders are hidden": "Configured folders are hidden",
  "Attachment Folder Names": "Attachment Folder Names",
  "Enter folder names to hide, one per line. Use 'endswith::' or 'startswith::' for prefix/suffix matching.": "Enter folder names to hide, one per line. Use 'endswith::' or 'startswith::' for prefix/suffix matching.",
  "Match path case-insensitive": "Match path case-insensitive",
  "Hide configured folders": "Hide configured folders",
  "Add hidden folders to Obsidian ignore list": "Add hidden folders to Obsidian ignore list",
  "Hide bottom status bar indicator text": "Hide bottom status bar indicator text",
  "Experimental & Unstable Settings": "Experimental & Unstable Settings",
  "Enable compatibility with Quick Explorer": "Enable compatibility with Quick Explorer",
  "Folders to hide": "Folders to hide",
  "The names of the folders to hide, one per line. Either exact folder-names, startsWith::FOLDERPREFIX, or endsWith::FOLDERSUFFIX": "The names of the folders to hide, one per line. Either exact folder-names, startsWith::FOLDERPREFIX, or endsWith::FOLDERSUFFIX",
  "attachments\\nendsWith::_attachments": "attachments\\nendsWith::_attachments",
  "Ignore Upper/lowercase": "Ignore Upper/lowercase",
  "If enabled, 'SOMEFOLDER', 'someFolder', or 'sOmeFoldEr' will all be treated the same and matched.": "If enabled, 'SOMEFOLDER', 'someFolder', or 'sOmeFoldEr' will all be treated the same and matched.",
  "Hide folders": "Hide folders",
  "If the configured folders should be hidden or not": "If the configured folders should be hidden or not",
  "Add Hidden Folders to Obsidian Exclusion-List": "Add Hidden Folders to Obsidian Exclusion-List",
  "Excluded files will be hidden in Search, Graph View, and Unlinked Mentions, less noticeable in Quick Switcher and link suggestions.": "Excluded files will be hidden in Search, Graph View, and Unlinked Mentions, less noticeable in Quick Switcher and link suggestions.",
  'Hide bottom status-bar "Folders are Hidden" indicator': 'Hide bottom status-bar "Folders are Hidden" indicator',
  "If enable there will be no bottom-bar indicator-text telling you if this plugin is active.": "If enable there will be no bottom-bar indicator-text telling you if this plugin is active.",
  "[EXPERIMENTAL] Compatibility: quick-explorer by pjeby": "[EXPERIMENTAL] Compatibility: quick-explorer by pjeby",
  "[WARNING: UNSTABLE] Also hide hidden folders in the https://github.com/pjeby/quick-explorer plugin. Not affiliated with quick-explorer's author.": "[WARNING: UNSTABLE] Also hide hidden folders in the https://github.com/pjeby/quick-explorer plugin. Not affiliated with quick-explorer's author.",
  // My Plugins
  "My Plugins": "My Plugins",
  "Loading Obsidian Assistant...": "Loading Obsidian Assistant...",
  "Loading Settings...": "Loading Settings...",
  "Unloading Obsidian Assistant...": "Unloading Obsidian Assistant...",
  "Starting {id} after a {type} delay": "Starting {id} after a {type} delay",
  "Failed to load plugin {id} after delay:": "Failed to load plugin {id} after delay:",
  "Dual Configurations": "Dual Configurations",
  "Separated configuration for desktop and mobile.": "Separated configuration for desktop and mobile.",
  "Show Console Log": "Show Console Log",
  "Show log in console when a plugin is loaded.": "Show log in console when a plugin is loaded.",
  "Short Delay Duration (s)": "Short Delay Duration (s)",
  "Long Delay Duration (s)": "Long Delay Duration (s)",
  "Default Startup Type": "Default Startup Type",
  "Startup type used when a plugin is not configured.": "Startup type used when a plugin is not configured.",
  "Show Descriptions": "Show Descriptions",
  "Show plugin descriptions in the list.": "Show plugin descriptions in the list.",
  "Set the delay for all plugins at once": "Set the delay for all plugins at once",
  "Select a startup type to apply to all plugins.": "Select a startup type to apply to all plugins.",
  "Search plugins...": "Search plugins...",
  "All": "All",
  "Instant": "Instant",
  "Short": "Short",
  "Long": "Long",
  "Disabled": "Disabled",
  "Separate desktop/mobile configuration": "Separate desktop/mobile configuration",
  "Enable this if you want to have different settings depending whether you're using a desktop or mobile device. All of the settings below can be configured differently on desktop and mobile. You're currently using the {device} settings.": "Enable this if you want to have different settings depending whether you're using a desktop or mobile device. All of the settings below can be configured differently on desktop and mobile. You're currently using the {device} settings.",
  "Short delay (seconds)": "Short delay (seconds)",
  "Long delay (seconds)": "Long delay (seconds)",
  "Default startup type for new plugins": "Default startup type for new plugins",
  "Nothing configured": "Nothing configured",
  "Show plugin descriptions": "Show plugin descriptions",
  "Set all plugins to be:": "Set all plugins to be:",
  "Plugins": "Plugins",
  "Filter by: ": "Filter by: ",
  "Type to filter list": "Type to filter list",
  "\u26D4 Disable plugin": "\u26D4 Disable plugin",
  "\u26A1 Instant": "\u26A1 Instant",
  "\u231A Short delay": "\u231A Short delay",
  "\u{1F4A4} Long delay": "\u{1F4A4} Long delay",
  "{id} after a {type} delay": "{id} after a {type} delay",
  // My Status Bar
  "My Status Bar": "My Status Bar",
  "Separate fullscreen and windowed mode": "Separate fullscreen and windowed mode",
  "When enabled, the plugin will remember which preset was active for fullscreen mode and which for windowed mode and switch correspondingly.": "When enabled, the plugin will remember which preset was active for fullscreen mode and which for windowed mode and switch correspondingly.",
  "Switch to preset slot {n}": "Switch to preset slot {n}",
  "Default": "Default",
  "New Preset": "New Preset",
  "Drag to reorder": "Drag to reorder",
  "Visibility": "Visibility",
  "Remove orphan": "Remove orphan",
  "This element is currently not present in the status bar.": "This element is currently not present in the status bar.",
  // My Snippets
  "My Snippets": "My Snippets",
  "Open snippets in status bar": "Open snippets in status bar",
  "Create new CSS snippet": "Create new CSS snippet",
  "Configure Snippets": "Configure Snippets",
  "Glass Style": "Glass Style",
  "Turn on frosted glass for the status bar menu.": "Turn on frosted glass for the status bar menu.",
  "Open Script after Creation": "Open Script after Creation",
  "Open the CSS file automatically after creating a new snippet.": "Open the CSS file automatically after creating a new snippet.",
  "Enable/Disable after Creation": "Enable/Disable after Creation",
  "Set the snippet to enabled or disabled by default after creation.": "Set the snippet to enabled or disabled by default after creation.",
  "Script Template": "Script Template",
  "Template for new CSS snippets.": "Template for new CSS snippets.",
  "Show Status Bar Icon": "Show Status Bar Icon",
  "Toggle the visibility of the snippets icon in the status bar.": "Toggle the visibility of the snippets icon in the status bar.",
  "Manage Snippets": "Manage Snippets",
  "Reload Snippets": "Reload Snippets",
  "Click to refresh the list of snippets.": "Click to refresh the list of snippets.",
  "Glass menu effect": "Glass menu effect",
  "Choose to change the background from the secondary background color of your theme to a glass background.": "Choose to change the background from the secondary background color of your theme to a glass background.",
  "Auto open new snippet": "Auto open new snippet",
  "Choose whether or not to open CSS snippet files immeditaley after creating them. It will open in your default app.": "Choose whether or not to open CSS snippet files immeditaley after creating them. It will open in your default app.",
  "Set new snippet status": "Set new snippet status",
  "Choose whether or not to have newly created CSS snippet files toggled on automatically upon creation.": "Choose whether or not to have newly created CSS snippet files toggled on automatically upon creation.",
  "CSS snippet template": "CSS snippet template",
  "Set default CSS styling as a template for new CSS files you choose to create.": "Set default CSS styling as a template for new CSS files you choose to create.",
  "If you like this Plugin and are considering donating to support continued development, use the buttons below!": "If you like this Plugin and are considering donating to support continued development, use the buttons below!",
  "No CSS snippets found.": "No CSS snippets found.",
  "Buy me a coffee": "Buy me a coffee",
  "Created by ": "Created by ",
  "Open snippet": "Open snippet",
  "Actions": "Actions",
  "Reload snippets": "Reload snippets",
  "Snippets reloaded": "Snippets reloaded",
  "Open snippets folder": "Open snippets folder",
  "Create a CSS Snippet": "Create a CSS Snippet",
  "CSS Snippet Title": "CSS Snippet Title",
  "Write the title for this CSS snippet file.": "Write the title for this CSS snippet file.",
  "CSS Snippet Styles": "CSS Snippet Styles",
  "Add in styling for this CSS snippet file.": "Add in styling for this CSS snippet file.",
  '"{fileName}.css" has been created!': '"{fileName}.css" has been created!',
  '"{fileName}.css" already exists.': '"{fileName}.css" already exists.',
  "Missing name for file": "Missing name for file",
  "Create Snippet": "Create Snippet",
  // MyHeadings
  "My Headings": "My Headings",
  "Number Headings": "Number Headings",
  "Remove Heading Numbering": "Remove Heading Numbering",
  "Auto Number Headings": "Auto Number Headings",
  "Automatically number headings on blur": "Automatically number headings on blur",
  "Create numbers automatically on blur": "Create numbers automatically on blur (triggers when you click away)",
  "First Level": "First Level",
  "Starting heading level for numbering": "Starting heading level for numbering",
  "Max Level": "Max Level",
  "Maximum heading level for numbering": "Maximum heading level for numbering",
  "Heading Styles": "Heading Styles",
  "Numbering style for each level (1-6)": "Numbering style for each level (1-6)",
  "Heading Separators": "Heading Separators",
  "Separator after each level (empty for H1, then 2-6)": "Separator after each level (empty for H1, then 2-6)",
  "Start Values": "Start Values",
  "Starting number for each level": "Starting number for each level",
  "Level": "Level",
  "Style": "Style",
  "Separator": "Separator",
  "Start At": "Start At",
  // MyFormulas
  "My Formulas": "My Formulas",
  "Number Formulas": "Number Formulas",
  "Remove Formula Numbering": "Remove Formula Numbering",
  "Auto Number Formulas": "Auto Number Formulas",
  "Automatically number formulas on blur": "Automatically number formulas on blur",
  "Automatically number formulas (triggers on blur if enabled)": "Automatically number formulas (triggers on blur if enabled)",
  "Numbering Mode": "Numbering Mode",
  "Continuous: 1,2,3... | Heading-based: 1.1-1, 1.1-2...": "Continuous: 1,2,3... | Heading-based: 1.1-1, 1.1-2...",
  "Continuous (1, 2, 3) or Heading-based (1.1-1, 1.1-2)": "Continuous (1, 2, 3) or Heading-based (1.1-1, 1.1-2)",
  "Continuous": "Continuous",
  "Heading-based": "Heading-based",
  "Configure Formulas": "Configure Formulas",
  "Heading-Based": "Heading-Based",
  "Max Heading Depth": "Max Heading Depth",
  "Depth of headings to include in equation number": "Depth of headings to include in equation number",
  // Heading Shifter
  "Auto Numbering": "Auto Numbering",
  "Heading Shifter": "Heading Shifter",
  "Lower limit of Heading": "Lower limit of Heading",
  "The lower Heading Size that will be decreased by the Heading Shift": "The lower Heading Size that will be decreased by the Heading Shift",
  "Enable override tab behavior": "Enable override tab behavior",
  'Tab execute "Increase Headings" and Shift-Tab execute "Decrease Headings"': 'Tab execute "Increase Headings" and Shift-Tab execute "Decrease Headings"',
  "Style to remove": "Style to remove",
  "If this style is at the position of a line, remove it": "If this style is at the position of a line, remove it",
  "Beginning": "Beginning",
  "Unordered list": "Unordered list",
  "Ordered list": "Ordered list",
  "User defined": "User defined",
  "Arbitrary string (regular expression)": "Arbitrary string (regular expression)",
  "Surrounding": "Surrounding",
  "Bold": "Bold",
  "Italic": "Italic",
  "Children behavior": "Children behavior",
  "Outdent to 0": "Outdent to 0",
  "Sync with headings": "Sync with headings",
  "Noting": "Noting",
  "Tab size": "Tab size",
  "Maximum heading level to use for formula numbering": "Maximum heading level to use for formula numbering",
  "For Heading-based mode: max depth of heading to use as prefix (e.g. 4 means use H4 at most)": "For Heading-based mode: max depth of heading to use as prefix (e.g. 4 means use H4 at most)",
  // Shifter Commands
  "Increase Headings": "Increase Headings",
  "Increase Headings (forced)": "Increase Headings (forced)",
  "Decrease Headings": "Decrease Headings",
  "Apply Heading": "Apply Heading",
  "Insert Heading at current level": "Insert Heading at current level",
  "Insert Heading at one level deeper": "Insert Heading at one level deeper",
  "Insert Heading at one level higher": "Insert Heading at one level higher",
  // Commands & Modals
  "Configure Headings": "Configure Headings",
  // 'Configure Formulas': 'Configure Formulas', // Duplicate
  "Apply Now": "Apply Now",
  "Apply numbering once without saving to frontmatter": "Apply numbering once without saving to frontmatter",
  "Save to Frontmatter": "Save to Frontmatter",
  "Save settings to frontmatter and apply": "Save settings to frontmatter and apply",
  "Remove Numbering": "Remove Numbering",
  "Numbering applied (one-time)": "Numbering applied (one-time)",
  "Formula numbering applied (one-time)": "Formula numbering applied (one-time)",
  "Settings saved to frontmatter and applied": "Settings saved to frontmatter and applied",
  "Heading numbering removed": "Heading numbering removed",
  "Formula numbering removed": "Formula numbering removed"
};

// src/i18n/locales/zh.ts
var zh_default = {
  // General
  "Module is disabled.": "\u6A21\u5757\u5DF2\u7981\u7528\u3002",
  "Obsidian Assistant Settings": "Obsidian Assistant \u8BBE\u7F6E",
  "Global Settings": "\u5168\u5C40\u8BBE\u7F6E",
  "Auto-Numbering Refresh Interval": "\u81EA\u52A8\u7F16\u53F7\u5237\u65B0\u95F4\u9694",
  "Time in milliseconds to wait before auto-numbering triggers (after losing focus)": "\u5931\u7126\u540E\u89E6\u53D1\u81EA\u52A8\u7F16\u53F7\u524D\u7684\u7B49\u5F85\u65F6\u95F4\uFF08\u6BEB\u79D2\uFF09",
  "Modules": "\u6A21\u5757",
  // My Folders
  "My Folders": "\u6211\u7684\u6587\u4EF6\u5939",
  "Toggle visibility of hidden folders": "\u5207\u6362\u9690\u85CF\u6587\u4EF6\u5939\u7684\u53EF\u89C1\u6027",
  "Show hidden folders": "\u663E\u793A\u9690\u85CF\u6587\u4EF6\u5939",
  "Hide hidden folders again": "\u518D\u6B21\u9690\u85CF\u6587\u4EF6\u5939",
  "Configured folders are hidden": "\u5DF2\u914D\u7F6E\u7684\u6587\u4EF6\u5939\u5DF2\u9690\u85CF",
  "Attachment Folder Names": "\u9644\u4EF6\u6587\u4EF6\u5939\u540D\u79F0",
  "Enter folder names to hide, one per line. Use 'endswith::' or 'startswith::' for prefix/suffix matching.": "\u8F93\u5165\u8981\u9690\u85CF\u7684\u6587\u4EF6\u5939\u540D\u79F0\uFF0C\u6BCF\u884C\u4E00\u4E2A\u3002\u4F7F\u7528 'endswith::' \u6216 'startswith::' \u8FDB\u884C\u524D\u540E\u7F00\u5339\u914D\u3002",
  "Match path case-insensitive": "\u8DEF\u5F84\u5339\u914D\u4E0D\u533A\u5206\u5927\u5C0F\u5199",
  "Hide configured folders": "\u9690\u85CF\u914D\u7F6E\u7684\u6587\u4EF6\u5939",
  "Add hidden folders to Obsidian ignore list": "\u5C06\u9690\u85CF\u6587\u4EF6\u5939\u6DFB\u52A0\u5230 Obsidian \u5FFD\u7565\u5217\u8868",
  "Hide bottom status bar indicator text": "\u9690\u85CF\u5E95\u90E8\u72B6\u6001\u680F\u6307\u793A\u6587\u5B57",
  "Experimental & Unstable Settings": "\u5B9E\u9A8C\u6027 & \u4E0D\u7A33\u5B9A\u8BBE\u7F6E",
  "Enable compatibility with Quick Explorer": "\u542F\u7528\u4E0E Quick Explorer \u7684\u517C\u5BB9\u6027",
  "Folders to hide": "\u8981\u9690\u85CF\u7684\u6587\u4EF6\u5939",
  "The names of the folders to hide, one per line. Either exact folder-names, startsWith::FOLDERPREFIX, or endsWith::FOLDERSUFFIX": "\u8981\u9690\u85CF\u7684\u6587\u4EF6\u5939\u540D\u79F0\uFF0C\u6BCF\u884C\u4E00\u4E2A\u3002\u53EF\u4EE5\u662F\u7CBE\u786E\u7684\u6587\u4EF6\u5939\u540D\u79F0\uFF0C\u6216\u8005\u4F7F\u7528 startsWith::FOLDERPREFIX\u3001endsWith::FOLDERSUFFIX \u8FDB\u884C\u5339\u914D\u3002",
  "attachments\\nendsWith::_attachments": "attachments\\nendsWith::_attachments",
  "Ignore Upper/lowercase": "\u5FFD\u7565\u5927\u5C0F\u5199",
  "If enabled, 'SOMEFOLDER', 'someFolder', or 'sOmeFoldEr' will all be treated the same and matched.": "\u542F\u7528\u540E\uFF0C'SOMEFOLDER'\u3001'someFolder' \u6216 'sOmeFoldEr' \u90FD\u5C06\u88AB\u89C6\u4E3A\u76F8\u540C\u5E76\u5339\u914D\u3002",
  "Hide folders": "\u9690\u85CF\u6587\u4EF6\u5939",
  "If the configured folders should be hidden or not": "\u662F\u5426\u9690\u85CF\u5DF2\u914D\u7F6E\u7684\u6587\u4EF6\u5939",
  "Add Hidden Folders to Obsidian Exclusion-List": "\u5C06\u9690\u85CF\u6587\u4EF6\u5939\u6DFB\u52A0\u5230 Obsidian \u6392\u9664\u5217\u8868",
  "Excluded files will be hidden in Search, Graph View, and Unlinked Mentions, less noticeable in Quick Switcher and link suggestions.": "\u6392\u9664\u7684\u6587\u4EF6\u5C06\u5728\u641C\u7D22\u3001\u5173\u7CFB\u56FE\u8C31\u548C\u53CD\u5411\u94FE\u63A5\u4E2D\u9690\u85CF\uFF0C\u5E76\u4E14\u5728\u5FEB\u901F\u5207\u6362\u548C\u94FE\u63A5\u5EFA\u8BAE\u4E2D\u4E0D\u90A3\u4E48\u663E\u773C\u3002",
  'Hide bottom status-bar "Folders are Hidden" indicator': '\u9690\u85CF\u5E95\u90E8\u72B6\u6001\u680F "\u6587\u4EF6\u5939\u5DF2\u9690\u85CF" \u6307\u793A\u5668',
  "If enable there will be no bottom-bar indicator-text telling you if this plugin is active.": "\u542F\u7528\u540E\uFF0C\u5E95\u90E8\u72B6\u6001\u680F\u5C06\u4E0D\u518D\u663E\u793A\u6B64\u63D2\u4EF6\u662F\u5426\u6D3B\u8DC3\u7684\u6307\u793A\u6587\u672C\u3002",
  "[EXPERIMENTAL] Compatibility: quick-explorer by pjeby": "[\u5B9E\u9A8C\u6027] \u517C\u5BB9\u6027\uFF1Apjeby \u5F00\u53D1\u7684 quick-explorer",
  "[WARNING: UNSTABLE] Also hide hidden folders in the https://github.com/pjeby/quick-explorer plugin. Not affiliated with quick-explorer's author.": "[\u8B66\u544A\uFF1A\u4E0D\u7A33\u5B9A] \u540C\u65F6\u9690\u85CF https://github.com/pjeby/quick-explorer \u63D2\u4EF6\u4E2D\u7684\u9690\u85CF\u6587\u4EF6\u5939\u3002\u4E0E quick-explorer \u7684\u4F5C\u8005\u65E0\u5173\u3002",
  // My Plugins
  "My Plugins": "\u6211\u7684\u63D2\u4EF6",
  "Loading Obsidian Assistant...": "\u6B63\u5728\u52A0\u8F7D Obsidian Assistant...",
  "Loading Settings...": "\u6B63\u5728\u52A0\u8F7D\u8BBE\u7F6E...",
  "Unloading Obsidian Assistant...": "\u6B63\u5728\u5378\u8F7D Obsidian Assistant...",
  "Starting {id} after a {type} delay": "\u5EF6\u8FDF {type} \u540E\u542F\u52A8 {id}",
  "Failed to load plugin {id} after delay:": "\u5EF6\u8FDF\u540E\u52A0\u8F7D\u63D2\u4EF6 {id} \u5931\u8D25\uFF1A",
  "Dual Configurations": "\u53CC\u91CD\u914D\u7F6E",
  "Separated configuration for desktop and mobile.": "\u4E3A\u684C\u9762\u7AEF\u548C\u79FB\u52A8\u7AEF\u4F7F\u7528\u72EC\u7ACB\u7684\u914D\u7F6E\u3002",
  "Show Console Log": "\u663E\u793A\u63A7\u5236\u53F0\u65E5\u5FD7",
  "Show log in console when a plugin is loaded.": "\u63D2\u4EF6\u52A0\u8F7D\u65F6\u5728\u63A7\u5236\u53F0\u663E\u793A\u65E5\u5FD7\u3002",
  "Short Delay Duration (s)": "\u77ED\u5EF6\u8FDF\u65F6\u95F4 (\u79D2)",
  "Long Delay Duration (s)": "\u957F\u5EF6\u8FDF\u65F6\u95F4 (\u79D2)",
  "Default Startup Type": "\u9ED8\u8BA4\u542F\u52A8\u7C7B\u578B",
  "Startup type used when a plugin is not configured.": "\u5F53\u63D2\u4EF6\u672A\u914D\u7F6E\u65F6\u4F7F\u7528\u7684\u542F\u52A8\u7C7B\u578B\u3002",
  "Show Descriptions": "\u663E\u793A\u8BF4\u660E",
  "Show plugin descriptions in the list.": "\u5728\u5217\u8868\u4E2D\u663E\u793A\u63D2\u4EF6\u8BF4\u660E\u3002",
  "Set the delay for all plugins at once": "\u4E00\u6B21\u6027\u8BBE\u7F6E\u6240\u6709\u63D2\u4EF6\u7684\u5EF6\u8FDF",
  "Select a startup type to apply to all plugins.": "\u9009\u62E9\u4E00\u4E2A\u542F\u52A8\u7C7B\u578B\u5E76\u5E94\u7528\u5230\u6240\u6709\u63D2\u4EF6\u3002",
  "Search plugins...": "\u641C\u7D22\u63D2\u4EF6...",
  "All": "\u5168\u90E8",
  "Instant": "\u5373\u65F6",
  "Short": "\u77ED\u5EF6\u8FDF",
  "Long": "\u957F\u5EF6\u8FDF",
  "Disabled": "\u5DF2\u7981\u7528",
  "Separate desktop/mobile configuration": "\u5206\u79BB\u684C\u9762\u7AEF/\u79FB\u52A8\u7AEF\u914D\u7F6E",
  "Enable this if you want to have different settings depending whether you're using a desktop or mobile device. All of the settings below can be configured differently on desktop and mobile. You're currently using the {device} settings.": "\u5982\u679C\u5E0C\u671B\u6839\u636E\u60A8\u4F7F\u7528\u7684\u8BBE\u5907\uFF08\u684C\u9762\u6216\u79FB\u52A8\u7AEF\uFF09\u4F7F\u7528\u4E0D\u540C\u7684\u8BBE\u7F6E\uFF0C\u8BF7\u542F\u7528\u6B64\u9879\u3002\u4EE5\u4E0B\u6240\u6709\u8BBE\u7F6E\u90FD\u53EF\u4EE5\u5728\u684C\u9762\u548C\u79FB\u52A8\u7AEF\u72EC\u7ACB\u914D\u7F6E\u3002\u60A8\u5F53\u524D\u6B63\u5728\u4F7F\u7528 {device} \u8BBE\u7F6E\u3002",
  "Short delay (seconds)": "\u77ED\u5EF6\u8FDF (\u79D2)",
  "Long delay (seconds)": "\u957F\u5EF6\u8FDF (\u79D2)",
  "Default startup type for new plugins": "\u65B0\u63D2\u4EF6\u7684\u9ED8\u8BA4\u542F\u52A8\u7C7B\u578B",
  "Nothing configured": "\u672A\u914D\u7F6E\u5185\u5BB9",
  "Show plugin descriptions": "\u663E\u793A\u63D2\u4EF6\u8BF4\u660E",
  "Set all plugins to be:": "\u5C06\u6240\u6709\u63D2\u4EF6\u8BBE\u7F6E\u4E3A\uFF1A",
  "Plugins": "\u63D2\u4EF6",
  "Filter by: ": "\u8FC7\u6EE4\u65B9\u5F0F\uFF1A",
  "Type to filter list": "\u8F93\u5165\u4EE5\u8FC7\u6EE4\u5217\u8868",
  "\u26D4 Disable plugin": "\u26D4 \u7981\u7528\u63D2\u4EF6",
  "\u26A1 Instant": "\u26A1 \u5373\u65F6",
  "\u231A Short delay": "\u231A \u77ED\u5EF6\u8FDF",
  "\u{1F4A4} Long delay": "\u{1F4A4} \u957F\u5EF6\u8FDF",
  "{id} after a {type} delay": "\u5EF6\u8FDF {type} \u540E\u542F\u52A8 {id}",
  // My Status Bar
  "My Status Bar": "\u6211\u7684\u72B6\u6001\u680F",
  "Separate fullscreen and windowed mode": "\u5206\u79BB\u5168\u5C4F\u548C\u7A97\u53E3\u6A21\u5F0F",
  "When enabled, the plugin will remember which preset was active for fullscreen mode and which for windowed mode and switch correspondingly.": "\u542F\u7528\u540E\uFF0C\u63D2\u4EF6\u5C06\u8BB0\u4F4F\u5168\u5C4F\u6A21\u5F0F\u548C\u7A97\u53E3\u6A21\u5F0F\u4E0B\u7684\u6D3B\u52A8\u9884\u8BBE\u5E76\u8FDB\u884C\u76F8\u5E94\u5207\u6362\u3002",
  "Switch to preset slot {n}": "\u5207\u6362\u81F3\u9884\u8BBE\u63D2\u69FD {n}",
  "Default": "\u9ED8\u8BA4",
  "New Preset": "\u65B0\u5EFA\u9884\u8BBE",
  "Drag to reorder": "\u62D6\u62FD\u5E76\u6392\u5E8F",
  "Visibility": "\u53EF\u89C1\u6027",
  "Remove orphan": "\u79FB\u9664\u6B8B\u7559\u9879",
  "This element is currently not present in the status bar.": "\u8BE5\u5143\u7D20\u5F53\u524D\u4E0D\u5728\u72B6\u6001\u680F\u4E2D\u3002",
  // My Snippets
  "My Snippets": "\u6211\u7684\u7247\u6BB5",
  "Open snippets in status bar": "\u5728\u72B6\u6001\u680F\u6253\u5F00\u4EE3\u7801\u7247\u6BB5",
  "Create new CSS snippet": "\u521B\u5EFA\u65B0\u7684 CSS \u4EE3\u7801\u7247\u6BB5",
  "Configure Snippets": "\u914D\u7F6E\u4EE3\u7801\u7247\u6BB5",
  "Glass Style": "\u6BDB\u73BB\u7483\u6837\u5F0F",
  "Turn on frosted glass for the status bar menu.": "\u4E3A\u72B6\u6001\u680F\u83DC\u5355\u5F00\u542F\u6BDB\u73BB\u7483\u6548\u679C\u3002",
  "Open Script after Creation": "\u521B\u5EFA\u540E\u6253\u5F00\u811A\u672C",
  "Open the CSS file automatically after creating a new snippet.": "\u521B\u5EFA\u65B0\u7247\u6BB5\u540E\u81EA\u52A8\u6253\u5F00 CSS \u6587\u4EF6\u3002",
  "Enable/Disable after Creation": "\u521B\u5EFA\u540E\u542F\u7528/\u7981\u7528",
  "Set the snippet to enabled or disabled by default after creation.": "\u8BBE\u7F6E\u7247\u6BB5\u521B\u5EFA\u540E\u9ED8\u8BA4\u542F\u7528\u6216\u7981\u7528\u3002",
  "Script Template": "\u811A\u672C\u6A21\u677F",
  "Template for new CSS snippets.": "\u65B0 CSS \u7247\u6BB5\u7684\u6A21\u677F\u3002",
  "Show Status Bar Icon": "\u663E\u793A\u72B6\u6001\u680F\u56FE\u6807",
  "Toggle the visibility of the snippets icon in the status bar.": "\u5207\u6362\u72B6\u6001\u680F\u7247\u6BB5\u56FE\u6807\u7684\u53EF\u89C1\u6027\u3002",
  "Manage Snippets": "\u7BA1\u7406\u4EE3\u7801\u7247\u6BB5",
  "Reload Snippets": "\u91CD\u8F7D\u4EE3\u7801\u7247\u6BB5",
  "Click to refresh the list of snippets.": "\u70B9\u51FB\u5237\u65B0\u4EE3\u7801\u7247\u6BB5\u5217\u8868\u3002",
  "Glass menu effect": "\u6BDB\u73BB\u7483\u83DC\u5355\u6548\u679C",
  "Choose to change the background from the secondary background color of your theme to a glass background.": "\u9009\u62E9\u5C06\u80CC\u666F\u4ECE\u4E3B\u9898\u7684\u6B21\u8981\u80CC\u666F\u989C\u8272\u66F4\u6539\u4E3A\u6BDB\u73BB\u7483\u80CC\u666F\u3002",
  "Auto open new snippet": "\u81EA\u52A8\u6253\u5F00\u65B0\u7247\u6BB5",
  "Choose whether or not to open CSS snippet files immeditaley after creating them. It will open in your default app.": "\u9009\u62E9\u5728\u521B\u5EFA CSS \u7247\u6BB5\u6587\u4EF6\u540E\u662F\u5426\u7ACB\u5373\u6253\u5F00\u5B83\u4EEC\u3002\u5B83\u5C06\u5728\u60A8\u7684\u9ED8\u8BA4\u5E94\u7528\u7A0B\u5E8F\u4E2D\u6253\u5F00\u3002",
  "Set new snippet status": "\u8BBE\u7F6E\u65B0\u7247\u6BB5\u72B6\u6001",
  "Choose whether or not to have newly created CSS snippet files toggled on automatically upon creation.": "\u9009\u62E9\u5728\u521B\u5EFA\u65F6\u662F\u5426\u81EA\u52A8\u542F\u7528\u65B0\u521B\u5EFA\u7684 CSS \u7247\u6BB5\u6587\u4EF6\u3002",
  "CSS snippet template": "CSS \u7247\u6BB5\u6A21\u677F",
  "Set default CSS styling as a template for new CSS files you choose to create.": "\u8BBE\u7F6E\u9ED8\u8BA4 CSS \u6837\u5F0F\u4F5C\u4E3A\u60A8\u9009\u62E9\u521B\u5EFA\u7684\u65B0 CSS \u6587\u4EF6\u7684\u6A21\u677F\u3002",
  "If you like this Plugin and are considering donating to support continued development, use the buttons below!": "\u5982\u679C\u60A8\u559C\u6B22\u8FD9\u4E2A\u63D2\u4EF6\u5E76\u8003\u8651\u6350\u8D60\u4EE5\u652F\u6301\u6301\u7EED\u5F00\u53D1\uFF0C\u8BF7\u4F7F\u7528\u4E0B\u9762\u7684\u6309\u94AE\uFF01",
  "No CSS snippets found.": "\u672A\u627E\u5230 CSS \u7247\u6BB5\u3002",
  "Buy me a coffee": "\u8BF7\u6211\u559D\u676F\u5496\u5561",
  "Created by ": "\u5F00\u53D1\u8005\uFF1A",
  "Open snippet": "\u6253\u5F00\u4EE3\u7801\u7247\u6BB5",
  "Actions": "\u64CD\u4F5C",
  "Reload snippets": "\u91CD\u8F7D\u4EE3\u7801\u7247\u6BB5",
  "Snippets reloaded": "\u4EE3\u7801\u7247\u6BB5\u5DF2\u91CD\u8F7D",
  "Open snippets folder": "\u6253\u5F00\u4EE3\u7801\u7247\u6BB5\u6587\u4EF6\u5939",
  "Create a CSS Snippet": "\u521B\u5EFA CSS \u4EE3\u7801\u7247\u6BB5",
  "CSS Snippet Title": "CSS \u4EE3\u7801\u7247\u6BB5\u6807\u9898",
  "Write the title for this CSS snippet file.": "\u4E3A\u8BE5 CSS \u7247\u6BB5\u6587\u4EF6\u7F16\u5199\u6807\u9898\u3002",
  "CSS Snippet Styles": "CSS \u4EE3\u7801\u7247\u6BB5\u6837\u5F0F",
  "Add in styling for this CSS snippet file.": "\u4E3A\u8BE5 CSS \u7247\u6BB5\u6587\u4EF6\u6DFB\u52A0\u6837\u5F0F\u3002",
  '"{fileName}.css" has been created!': '"{fileName}.css" \u5DF2\u521B\u5EFA\uFF01',
  '"{fileName}.css" already exists.': '"{fileName}.css" \u5DF2\u5B58\u5728\u3002',
  "Missing name for file": "\u6587\u4EF6\u540D\u7F3A\u5931",
  "Create Snippet": "\u521B\u5EFA\u7247\u6BB5",
  // MyHeadings
  "My Headings": "\u6211\u7684\u6807\u9898",
  "Number Headings": "\u6807\u9898\u7F16\u53F7",
  "Remove Heading Numbering": "\u79FB\u9664\u6807\u9898\u7F16\u53F7",
  "Auto Number Headings": "\u81EA\u52A8\u6807\u9898\u7F16\u53F7",
  "Create numbers automatically on blur": "\u81EA\u52A8\u521B\u5EFA\u7F16\u53F7\uFF08\u5728\u5931\u53BB\u7126\u70B9\u65F6\u89E6\u53D1\uFF09",
  "First Level": "\u8D77\u59CB\u7EA7\u522B",
  "Max Level": "\u6700\u5927\u7EA7\u522B",
  "Heading Styles": "\u6807\u9898\u6837\u5F0F",
  "Level": "\u7EA7\u522B",
  "Style": "\u6837\u5F0F",
  "Separator": "\u5206\u9694\u7B26",
  "Start At": "\u8D77\u59CB\u503C",
  // MyFormulas
  "My Formulas": "\u6211\u7684\u516C\u5F0F",
  "Number Formulas": "\u516C\u5F0F\u7F16\u53F7",
  "Remove Formula Numbering": "\u79FB\u9664\u516C\u5F0F\u7F16\u53F7",
  "Auto Number Formulas": "\u81EA\u52A8\u516C\u5F0F\u7F16\u53F7",
  "Automatically number formulas (triggers on blur if enabled)": "\u81EA\u52A8\u516C\u5F0F\u7F16\u53F7\uFF08\u542F\u7528\u65F6\u5728\u5931\u53BB\u7126\u70B9\u65F6\u89E6\u53D1\uFF09",
  "Numbering Mode": "\u7F16\u53F7\u6A21\u5F0F",
  "Continuous (1, 2, 3) or Heading-based (1.1-1, 1.1-2)": "\u8FDE\u7EED (1, 2, 3) \u6216 \u57FA\u4E8E\u6807\u9898 (1.1-1, 1.1-2)",
  "Continuous": "\u8FDE\u7EED",
  "Heading-based": "\u57FA\u4E8E\u6807\u9898",
  "Max Heading Depth": "\u6700\u5927\u6807\u9898\u6DF1\u5EA6",
  "For Heading-based mode: max depth of heading to use as prefix (e.g. 4 means use H4 at most)": "\u57FA\u4E8E\u6807\u9898\u6A21\u5F0F\uFF1A\u7528\u4F5C\u524D\u7F00\u7684\u6700\u5927\u6807\u9898\u6DF1\u5EA6\uFF08\u4F8B\u5982 4 \u8868\u793A\u6700\u591A\u4F7F\u7528 H4\uFF09",
  // Heading Shifter
  "Auto Numbering": "\u81EA\u52A8\u7F16\u53F7",
  "Heading Shifter": "\u6807\u9898\u79FB\u52A8 (Heading Shifter)",
  "Lower limit of Heading": "\u6807\u9898\u7EA7\u522B\u4E0B\u9650",
  "The lower Heading Size that will be decreased by the Heading Shift": "\u6807\u9898\u79FB\u52A8\u529F\u80FD\u53EF\u4EE5\u964D\u4F4E\u7684\u6700\u5C0F\u6807\u9898\u7EA7\u522B",
  "Enable override tab behavior": "\u542F\u7528\u8986\u76D6 Tab \u952E\u884C\u4E3A",
  'Tab execute "Increase Headings" and Shift-Tab execute "Decrease Headings"': "Tab \u952E\u6267\u884C\u201C\u589E\u52A0\u6807\u9898\u7EA7\u522B\u201D\uFF0CShift-Tab \u6267\u884C\u201C\u51CF\u5C11\u6807\u9898\u7EA7\u522B\u201D",
  "Style to remove": "\u8981\u79FB\u9664\u7684\u6837\u5F0F",
  "If this style is at the position of a line, remove it": "\u5982\u679C\u884C\u4E2D\u6307\u5B9A\u4F4D\u7F6E\u5B58\u5728\u6B64\u6837\u5F0F\uFF0C\u5219\u79FB\u9664\u5B83",
  "Beginning": "\u5F00\u5934",
  "Unordered list": "\u65E0\u5E8F\u5217\u8868",
  "Ordered list": "\u6709\u5E8F\u5217\u8868",
  "User defined": "\u7528\u6237\u81EA\u5B9A\u4E49",
  "Arbitrary string (regular expression)": "\u4EFB\u610F\u5B57\u7B26\u4E32 (\u6B63\u5219\u8868\u8FBE\u5F0F)",
  "Surrounding": "\u5305\u56F4",
  "Bold": "\u7C97\u4F53",
  "Italic": "\u659C\u4F53",
  "Children behavior": "\u5B50\u5143\u7D20\u884C\u4E3A",
  "Outdent to 0": "\u7F29\u8FDB\u81F3 0",
  "Sync with headings": "\u4E0E\u6807\u9898\u540C\u6B65",
  "Noting": "\u65E0\u64CD\u4F5C",
  "Tab size": "\u5236\u8868\u7B26\u5BBD\u5EA6 (Tab Size)",
  // Shifter Commands
  "Increase Headings": "\u589E\u52A0\u6807\u9898\u7EA7\u522B",
  "Increase Headings (forced)": "\u589E\u52A0\u6807\u9898\u7EA7\u522B (\u5F3A\u5236)",
  "Decrease Headings": "\u51CF\u5C11\u6807\u9898\u7EA7\u522B",
  "Apply Heading": "\u5E94\u7528\u6807\u9898\u7EA7\u522B",
  "Insert Heading at current level": "\u5728\u5F53\u524D\u7EA7\u522B\u63D2\u5165\u6807\u9898",
  "Insert Heading at one level deeper": "\u5728\u66F4\u6DF1\u4E00\u7EA7\u63D2\u5165\u6807\u9898",
  "Insert Heading at one level higher": "\u5728\u66F4\u6D45\u4E00\u7EA7\u63D2\u5165\u6807\u9898",
  // Commands & Modals
  "Configure Headings": "\u914D\u7F6E\u6807\u9898",
  "Configure Formulas": "\u914D\u7F6E\u516C\u5F0F",
  "Apply Now": "\u7ACB\u5373\u5E94\u7528",
  "Apply numbering once without saving to frontmatter": "\u4E00\u6B21\u6027\u5E94\u7528\u7F16\u53F7\uFF0C\u4E0D\u4FDD\u5B58\u5230frontmatter",
  "Save to Frontmatter": "\u4FDD\u5B58\u5230 Frontmatter",
  "Save settings to frontmatter and apply": "\u4FDD\u5B58\u8BBE\u7F6E\u5230frontmatter\u5E76\u5E94\u7528",
  "Remove Numbering": "\u79FB\u9664\u7F16\u53F7",
  "Numbering applied (one-time)": "\u7F16\u53F7\u5DF2\u5E94\u7528\uFF08\u4E00\u6B21\u6027\uFF09",
  "Formula numbering applied (one-time)": "\u516C\u5F0F\u7F16\u53F7\u5DF2\u5E94\u7528\uFF08\u4E00\u6B21\u6027\uFF09",
  "Settings saved to frontmatter and applied": "\u8BBE\u7F6E\u5DF2\u4FDD\u5B58\u5230frontmatter\u5E76\u5E94\u7528",
  "Heading numbering removed": "\u6807\u9898\u7F16\u53F7\u5DF2\u79FB\u9664",
  "Formula numbering removed": "\u516C\u5F0F\u7F16\u53F7\u5DF2\u79FB\u9664"
};

// src/i18n/helpers.ts
var localeMap = {
  en: en_default,
  zh: zh_default,
  "zh-cn": zh_default
};
var locale = localeMap[import_obsidian.moment.locale()];
function t(str) {
  if (!locale) {
    return en_default[str] || str;
  }
  return locale[str] || en_default[str] || str;
}

// src/folders/manager.ts
var FoldersManager = class {
  constructor(app, plugin) {
    this.ribbonIconButton = null;
    this.statusBarItem = null;
    this.processFolders = (0, import_obsidian2.debounce)(async (recheckPreviouslyHiddenFolders) => {
      if (!this.settings.enabled)
        return;
      if (this.settings.attachmentFolderNames.length === 0)
        return;
      if (recheckPreviouslyHiddenFolders) {
        document.querySelectorAll(".obsidian-hide-folders--hidden").forEach((folder) => {
          folder.style.height = "";
          folder.style.overflow = "";
          folder.removeClass("obsidian-hide-folders--hidden");
        });
      }
      this.settings.attachmentFolderNames.forEach((folderName) => {
        var _a, _b;
        if (getFolderNameWithoutPrefix(folderName) === "")
          return;
        const selectorString = [
          this.getQuerySelectorStringForFolderName(folderName),
          this.settings.enableCompatQuickExplorer ? (_b = (_a = CompatQuickExplorer).getAdditionalDocumentSelectorStringForFolder) == null ? void 0 : _b.call(_a, folderName, this.settings) : null
        ].filter((o) => o != null).join(", ");
        if (!selectorString)
          return;
        try {
          const folderElements = document.querySelectorAll(selectorString);
          folderElements.forEach((folder) => {
            if (!folder) {
              return;
            }
            folder.addClass("obsidian-hide-folders--hidden");
            folder.style.height = this.settings.areFoldersHidden ? "0" : "";
            folder.style.display = this.settings.areFoldersHidden ? "none" : "";
            folder.style.overflow = this.settings.areFoldersHidden ? "hidden" : "";
          });
        } catch (e) {
          console.error(`Failed to process folder ${folderName}:`, e);
        }
      });
    }, 10, false);
    this.app = app;
    this.plugin = plugin;
  }
  get settings() {
    return this.plugin.settings.myFolders;
  }
  getQuerySelectorStringForFolderName(folderName) {
    if (folderName.toLowerCase().startsWith("endswith::")) {
      return `*:has(> [data-path$="${getFolderNameWithoutPrefix(folderName)}"${this.settings.matchCaseInsensitive ? " i" : ""}])`;
    } else if (folderName.toLowerCase().startsWith("startswith::")) {
      return `*:has(> .nav-folder-title[data-path^="${getFolderNameWithoutPrefix(folderName)}"${this.settings.matchCaseInsensitive ? " i" : ""}]), *:has(> .nav-folder-title[data-path*="/${getFolderNameWithoutPrefix(folderName)}"${this.settings.matchCaseInsensitive ? " i" : ""}])`;
    } else {
      return `*:has(> [data-path$="/${folderName.trim()}"${this.settings.matchCaseInsensitive ? " i" : ""}]), *:has(> [data-path="${folderName.trim()}"${this.settings.matchCaseInsensitive ? " i" : ""}])`;
    }
  }
  async toggleFunctionality() {
    this.settings.areFoldersHidden = !this.settings.areFoldersHidden;
    if (this.ribbonIconButton) {
      this.ribbonIconButton.ariaLabel = this.settings.areFoldersHidden ? t("Show hidden folders") : t("Hide hidden folders again");
      (0, import_obsidian2.setIcon)(this.ribbonIconButton, this.settings.areFoldersHidden ? "eye" : "eye-off");
    }
    if (this.statusBarItem) {
      this.statusBarItem.innerHTML = this.settings.areFoldersHidden ? t("Configured folders are hidden") : "";
    }
    await this.processFolders();
    await this.plugin.saveSettings();
    await this.updateObsidianIgnoreList();
  }
  updateUI() {
    if (this.ribbonIconButton) {
      this.ribbonIconButton.ariaLabel = this.settings.areFoldersHidden ? t("Show hidden folders") : t("Hide hidden folders again");
      (0, import_obsidian2.setIcon)(this.ribbonIconButton, this.settings.areFoldersHidden ? "eye" : "eye-off");
    }
    if (this.statusBarItem) {
      this.statusBarItem.innerHTML = this.settings.areFoldersHidden ? t("Configured folders are hidden") : "";
    }
  }
  createIgnoreListRegExpForFolderName(rawFolderName) {
    const folderName = this.settings.matchCaseInsensitive ? getFolderNameWithoutPrefix(rawFolderName).split("").map((c) => c.toLowerCase() != c.toUpperCase() ? `[${c.toLowerCase()}${c.toUpperCase()}]` : c).join("") : getFolderNameWithoutPrefix(rawFolderName);
    if (rawFolderName.toLowerCase().startsWith("endswith::")) {
      return `/(${folderName}$)|(${folderName}/)/`;
    } else if (rawFolderName.toLowerCase().startsWith("startswith::")) {
      return `/(^${folderName})|(/${folderName})/`;
    } else {
      return `/${folderName}/`;
    }
  }
  async updateObsidianIgnoreList(processFeatureDisabling) {
    var _a;
    if (!this.settings.addHiddenFoldersToObsidianIgnoreList && !processFeatureDisabling)
      return;
    let ignoreList = (_a = this.app.vault.getConfig("userIgnoreFilters")) != null ? _a : [];
    if (this.settings.areFoldersHidden && !processFeatureDisabling) {
      this.settings.attachmentFolderNames.forEach((folderName) => {
        if (getFolderNameWithoutPrefix(folderName).trim() === "")
          return;
        if (ignoreList.contains(this.createIgnoreListRegExpForFolderName(folderName)))
          return;
        ignoreList.push(this.createIgnoreListRegExpForFolderName(folderName));
      });
    } else {
      const folderNameRegexes = this.settings.attachmentFolderNames.map((folderName) => this.createIgnoreListRegExpForFolderName(folderName));
      ignoreList = ignoreList.filter((s) => !folderNameRegexes.includes(s));
    }
    this.app.vault.setConfig("userIgnoreFilters", ignoreList);
  }
  async removeSpecificFoldersFromObsidianIgnoreList(folderNames) {
    folderNames.forEach((folderName) => {
      var _a;
      (_a = this.app.vault.config.userIgnoreFilters) == null ? void 0 : _a.remove(this.createIgnoreListRegExpForFolderName(folderName));
      this.app.vault.trigger("config-changed");
    });
  }
  createBottomStatusBarIndicatorTextItem() {
    if (this.statusBarItem)
      return;
    this.statusBarItem = this.plugin.addStatusBarItem();
    this.statusBarItem.setText(this.settings.areFoldersHidden ? t("Configured folders are hidden") : "");
  }
  async onload() {
    if (!this.settings.enabled)
      return;
    console.log("Loading MyFolders module");
    this.ribbonIconButton = this.plugin.addRibbonIcon(
      this.settings.areFoldersHidden ? "eye" : "eye-off",
      this.settings.areFoldersHidden ? t("Show hidden folders") : t("Hide hidden folders again"),
      (evt) => {
        this.toggleFunctionality();
      }
    );
    if (!this.settings.hideBottomStatusBarIndicatorText) {
      this.createBottomStatusBarIndicatorTextItem();
    }
    this.plugin.addCommand({
      id: "toggle-attachment-folders",
      name: t("Toggle visibility of hidden folders"),
      callback: () => {
        this.toggleFunctionality();
      }
    });
    this.mutationObserver = new MutationObserver((mutationRecord) => {
      const feClasses = [
        "nav-folder",
        "nav-files-container"
      ];
      const shouldTriggerProcessFolders = mutationRecord.some((record) => {
        var _a, _b;
        if (feClasses.some((c) => {
          var _a2, _b2;
          return (_b2 = (_a2 = record.target) == null ? void 0 : _a2.parentElement) == null ? void 0 : _b2.classList.contains(c);
        }))
          return true;
        if (this.settings.enableCompatQuickExplorer && ((_b = (_a = CompatQuickExplorer).shouldMutationRecordTriggerFolderReProcessing) == null ? void 0 : _b.call(_a, record)))
          return true;
        return false;
      });
      if (!shouldTriggerProcessFolders)
        return;
      this.processFolders();
    });
    this.mutationObserver.observe(window.document, { childList: true, subtree: true });
    this.plugin.registerEvent(this.app.vault.on("rename", () => {
      window.setTimeout(() => {
        this.processFolders();
      }, 10);
    }));
    this.app.workspace.onLayoutReady(() => {
      if (!this.settings.areFoldersHidden)
        return;
      window.setTimeout(() => {
        this.processFolders();
      }, 1e3);
    });
  }
  onunload() {
    var _a, _b, _c;
    (_a = this.mutationObserver) == null ? void 0 : _a.disconnect();
    (_b = this.ribbonIconButton) == null ? void 0 : _b.remove();
    (_c = this.statusBarItem) == null ? void 0 : _c.remove();
  }
};

// src/folders/settings-ui.ts
var import_obsidian3 = require("obsidian");
function renderFoldersSettings(containerEl, manager) {
  const plugin = manager.plugin;
  const settings = manager.settings;
  const experimentalSettingsContainerEl = document.createElement("details");
  const experimentalSettingsTitleEl = document.createElement("summary");
  experimentalSettingsTitleEl.innerText = t("Experimental & Unstable Settings");
  experimentalSettingsContainerEl.appendChild(experimentalSettingsTitleEl);
  new import_obsidian3.Setting(containerEl).setName(t("Folders to hide")).setDesc(t("The names of the folders to hide, one per line. Either exact folder-names, startsWith::FOLDERPREFIX, or endsWith::FOLDERSUFFIX")).addTextArea((text) => text.setPlaceholder(t("attachments\nendsWith::_attachments")).setValue(settings.attachmentFolderNames.join("\n")).onChange(async (value) => {
    const newSettingsValue = value.split("\n");
    await manager.removeSpecificFoldersFromObsidianIgnoreList(settings.attachmentFolderNames.filter((e) => !newSettingsValue.includes(e)));
    settings.attachmentFolderNames = newSettingsValue;
    await plugin.saveSettings();
    await manager.updateObsidianIgnoreList();
  }));
  new import_obsidian3.Setting(containerEl).setName(t("Ignore Upper/lowercase")).setDesc(t("If enabled, 'SOMEFOLDER', 'someFolder', or 'sOmeFoldEr' will all be treated the same and matched.")).addToggle((toggle) => toggle.setValue(settings.matchCaseInsensitive).onChange(async (value) => {
    await manager.removeSpecificFoldersFromObsidianIgnoreList(settings.attachmentFolderNames);
    settings.matchCaseInsensitive = value;
    await plugin.saveSettings();
    await manager.updateObsidianIgnoreList();
  }));
  new import_obsidian3.Setting(containerEl).setName(t("Hide folders")).setDesc(t("If the configured folders should be hidden or not")).addToggle((toggle) => toggle.setValue(settings.areFoldersHidden).onChange(async (value) => {
    settings.areFoldersHidden = value;
    await plugin.saveSettings();
    await manager.updateObsidianIgnoreList();
    manager.updateUI();
    manager.processFolders();
  }));
  new import_obsidian3.Setting(containerEl).setName(t("Add Hidden Folders to Obsidian Exclusion-List")).setDesc(t("Excluded files will be hidden in Search, Graph View, and Unlinked Mentions, less noticeable in Quick Switcher and link suggestions.")).addToggle((toggle) => toggle.setValue(settings.addHiddenFoldersToObsidianIgnoreList).onChange(async (value) => {
    settings.addHiddenFoldersToObsidianIgnoreList = value;
    await plugin.saveSettings();
    await manager.updateObsidianIgnoreList(!value);
  }));
  new import_obsidian3.Setting(containerEl).setName(t('Hide bottom status-bar "Folders are Hidden" indicator')).setDesc(t("If enable there will be no bottom-bar indicator-text telling you if this plugin is active.")).addToggle((toggle) => toggle.setValue(settings.hideBottomStatusBarIndicatorText).onChange(async (value) => {
    var _a;
    settings.hideBottomStatusBarIndicatorText = value;
    if (value) {
      (_a = manager.statusBarItem) == null ? void 0 : _a.remove();
      manager.statusBarItem = null;
    } else {
      manager.createBottomStatusBarIndicatorTextItem();
    }
    await plugin.saveSettings();
  }));
  new import_obsidian3.Setting(experimentalSettingsContainerEl).setName(t("[EXPERIMENTAL] Compatibility: quick-explorer by pjeby")).setDesc(t("[WARNING: UNSTABLE] Also hide hidden folders in the https://github.com/pjeby/quick-explorer plugin. Not affiliated with quick-explorer's author.")).addToggle((toggle) => toggle.setValue(settings.enableCompatQuickExplorer).onChange(async (value) => {
    settings.enableCompatQuickExplorer = value;
    await plugin.saveSettings();
  }));
  containerEl.appendChild(document.createElement("br"));
  containerEl.appendChild(experimentalSettingsContainerEl);
}

// src/statusbar/spooler.ts
var Spooler = class {
  constructor(plugin, callback) {
    this.plugin = plugin;
    this.mutex = false;
    this.spooler = 0;
    this.callback = callback;
    this.observer = new MutationObserver((list, _) => {
      if (!this.mutex && list.some(
        (mutation) => mutation.type == "childList" && mutation.addedNodes.length > 0
      )) {
        this.spoolFix(0);
      }
    });
    this.spoolFix(0);
  }
  /**
   * Disable automatic spooling.
   */
  disableObserver() {
    this.observer.disconnect();
  }
  /**
   * Enable automatic spooling.
   */
  enableObserver() {
    this.observer.observe(this.plugin.statusBar, { childList: true });
  }
  /**
   * Schedule status bar elements to be reordered.
   * 
   * @param timeout 
   */
  spoolFix(timeout = 1e3) {
    clearTimeout(this.spooler);
    this.spooler = window.setTimeout(() => {
      if (this.mutex) {
        this.spoolFix();
      } else {
        this.mutex = true;
        this.disableObserver();
        this.callback(this.plugin);
        this.enableObserver();
        this.mutex = false;
      }
    }, timeout);
  }
};

// src/statusbar/parser.ts
var ignoredClasses = [
  "mod-clickable",
  "status-bar-item",
  "statusbar-organizer-hidden"
];
function getStatusBarElements(statusBar) {
  const elements = [];
  const pluginElementCount = {};
  Array.from(statusBar.children).forEach((element) => {
    let id = element.getAttribute("data-statusbar-organizer-id");
    let name, index;
    if (id == null) {
      name = Array.from(element.classList).filter((x) => !ignoredClasses.contains(x)).join("-");
      index = name in pluginElementCount ? pluginElementCount[name] + 1 : 1;
      id = generateElementId(name, index);
      element.setAttribute("data-statusbar-organizer-id", id);
    } else {
      const parsed = parseElementId(id);
      name = parsed.name;
      index = parsed.index;
    }
    pluginElementCount[name] = Math.max(
      index,
      name in pluginElementCount ? pluginElementCount[name] : 0
    );
    elements.push({
      name,
      index,
      id,
      element
    });
  });
  return elements;
}
function generateElementId(name, index) {
  return `${name};${index}`;
}
function parseElementId(id) {
  const parts = id.split(";");
  const index = Number.parseInt(parts.pop());
  const name = parts.join(";");
  return {
    name,
    index
  };
}
function generatePresetId(preset) {
  return preset.replace(/-/g, "\\-").replace(/\s/g, "-");
}

// src/statusbar/util.ts
function deepCopy(obj) {
  return JSON.parse(JSON.stringify(obj));
}

// src/statusbar/rows.ts
var import_obsidian4 = require("obsidian");
var dragging;
async function initializeRows(plugin, settingsContainer) {
  settingsContainer.empty();
  dragging = false;
  const { rows, barStatus, existsStatus } = await plugin.consolidateSettingsAndElements();
  const rowsContainer = document.createElement("div");
  rowsContainer.addClass("statusbar-organizer-rows-container");
  settingsContainer.appendChild(rowsContainer);
  const nameCollisions = {};
  for (const element of rows) {
    if (element.name in nameCollisions)
      nameCollisions[element.name]++;
    else
      nameCollisions[element.name] = 0;
  }
  for (const row of rows) {
    const currentStatus = barStatus[row.id];
    const currentExists = existsStatus[row.id];
    const entry = document.createElement("div");
    entry.addClass("statusbar-organizer-row");
    if (!currentExists) {
      entry.addClass("statusbar-organizer-row-disabled");
      entry.setAttribute("aria-label", t("This element is currently not present in the status bar."));
    }
    if (!currentStatus.visible)
      entry.addClass("statusbar-organizer-row-hidden");
    entry.setAttribute("data-statusbar-organizer-id", row.id);
    row.entry = entry;
    rowsContainer.appendChild(entry);
    const handle = document.createElement("span");
    handle.addClass("statusbar-organizer-row-handle");
    handle.setAttribute("aria-label", t("Drag to reorder"));
    handle.addEventListener(
      "mousedown",
      (event) => handleMouseDown(event, plugin, barStatus, existsStatus, settingsContainer, rowsContainer, rows, row)
    );
    entry.appendChild(handle);
    const formattedName = row.name.replace(/^plugin-(obsidian-)?/, "").split("-").map((x) => x.charAt(0).toUpperCase() + x.slice(1)).join(" ") + (nameCollisions[row.name] ? ` (${row.index})` : "");
    const titleSpan = document.createElement("span");
    titleSpan.addClass("statusbar-organizer-row-title");
    titleSpan.textContent = formattedName;
    entry.appendChild(titleSpan);
    const previewSpan = document.createElement("span");
    previewSpan.addClass("statusbar-organizer-row-preview");
    if (currentExists) {
      previewSpan.innerHTML = row.element.innerHTML;
    }
    entry.appendChild(previewSpan);
    const visibilitySpan = document.createElement("span");
    visibilitySpan.addClass("statusbar-organizer-row-visibility");
    visibilitySpan.setAttribute("aria-label", currentExists ? t("Visibility") : t("Remove orphan"));
    visibilitySpan.onclick = () => {
      if (currentExists)
        toggleVisibility(plugin, barStatus, row);
      else
        removeOrphan(plugin, rowsContainer, barStatus, row);
    };
    (0, import_obsidian4.setIcon)(visibilitySpan, currentExists ? currentStatus.visible ? "eye" : "eye-off" : "trash-2");
    entry.appendChild(visibilitySpan);
  }
  return {
    rows,
    barStatus,
    rowsContainer
  };
}
async function toggleVisibility(plugin, barStatus, row) {
  var _a, _b, _c, _d;
  const status = barStatus[row.id];
  if (status.visible = !status.visible) {
    (_a = row.element) == null ? void 0 : _a.removeClass("statusbar-organizer-element-hidden");
    (_b = row.entry) == null ? void 0 : _b.removeClass("statusbar-organizer-row-hidden");
    (0, import_obsidian4.setIcon)(row.entry.children[3], "eye");
  } else {
    (_c = row.element) == null ? void 0 : _c.addClass("statusbar-organizer-element-hidden");
    (_d = row.entry) == null ? void 0 : _d.addClass("statusbar-organizer-row-hidden");
    (0, import_obsidian4.setIcon)(row.entry.children[3], "eye-off");
  }
  plugin.savePreset(barStatus);
}
async function removeOrphan(plugin, rowsContainer, barStatus, row) {
  rowsContainer.removeChild(row.entry);
  delete barStatus[row.id];
  for (const [entryIndex, entry] of Array.from(rowsContainer.children).entries())
    barStatus[entry.getAttribute("data-statusbar-organizer-id")].position = entryIndex;
  plugin.savePreset(barStatus);
}
function cloneRow(settingsContainer, barStatus, existsStatus, rowsContainer, event, row) {
  const realEntry = row.entry;
  realEntry.addClass("statusbar-organizer-row-clone");
  const fauxEntry = document.createElement("div");
  fauxEntry.addClass("statusbar-organizer-row");
  fauxEntry.addClass("statusbar-organizer-row-drag");
  if (!existsStatus[row.id])
    fauxEntry.addClass("statusbar-organizer-row-disabled");
  if (!barStatus[row.id].visible)
    fauxEntry.addClass("statusbar-organizer-row-hidden");
  settingsContainer.appendChild(fauxEntry);
  const containerX = settingsContainer.getBoundingClientRect().left;
  const containerY = settingsContainer.getBoundingClientRect().top;
  fauxEntry.style.left = realEntry.getBoundingClientRect().left - containerX + "px";
  fauxEntry.style.top = realEntry.getBoundingClientRect().top - containerY + "px";
  fauxEntry.style.width = realEntry.offsetWidth + "px";
  for (const child of Array.from(realEntry.children)) {
    const fauxSpan = document.createElement("span");
    fauxSpan.className = child.className;
    fauxSpan.innerHTML = child.innerHTML;
    fauxEntry.appendChild(fauxSpan);
  }
  let offsetX = event.clientX - fauxEntry.getBoundingClientRect().left;
  let offsetY = event.clientY - fauxEntry.getBoundingClientRect().top;
  let index = Array.from(rowsContainer.children).indexOf(realEntry);
  return {
    stationaryRow: realEntry,
    movableRow: fauxEntry,
    offsetX: offsetX + containerX,
    offsetY: offsetY + containerY,
    index
  };
}
function deleteRowClone(settingsContainer, stationaryRow, movableRow) {
  stationaryRow.removeClass("statusbar-organizer-row-clone");
  settingsContainer.removeChild(movableRow);
}
function calculateRowIndex(event, rowsContainer, movableRow, stationaryRow, offsetX, offsetY, index) {
  movableRow.style.left = event.clientX - offsetX + "px";
  movableRow.style.top = event.clientY - offsetY + "px";
  const dist = movableRow.getBoundingClientRect().top - stationaryRow.getBoundingClientRect().top;
  if (Math.abs(dist) > stationaryRow.offsetHeight * 0.75) {
    const dir = dist / Math.abs(dist);
    const newIndex = Math.max(0, Math.min(index + dir, rowsContainer.children.length - 1));
    return newIndex;
  }
  return index;
}
function handlePositionChange(barStatus, existsStatus, rowsContainer, rows, row, stationaryRow, newIndex) {
  const passedEntry = rowsContainer.children[newIndex];
  const passedId = passedEntry.getAttribute("data-statusbar-organizer-id");
  const statusBarChangeRequired = existsStatus[row.id] && existsStatus[passedId];
  if (statusBarChangeRequired && row.element) {
    const passedElement = rows.filter((x) => x.id == passedId)[0].element;
    const temp = passedElement.style.order;
    passedElement.style.order = row.element.style.order;
    row.element.style.order = temp;
  }
  rowsContainer.removeChild(stationaryRow);
  if (newIndex != rowsContainer.children.length)
    rowsContainer.insertBefore(stationaryRow, rowsContainer.children[newIndex]);
  else
    rowsContainer.appendChild(stationaryRow);
  for (const [entryIndex, entry] of Array.from(rowsContainer.children).entries())
    barStatus[entry.getAttribute("data-statusbar-organizer-id")].position = entryIndex;
}
function handleMouseDown(event, plugin, barStatus, existsStatus, settingsContainer, rowsContainer, rows, row) {
  if (dragging)
    return;
  dragging = true;
  let { stationaryRow, movableRow, offsetX, offsetY, index } = cloneRow(settingsContainer, barStatus, existsStatus, rowsContainer, event, row);
  function handleMouseMove(event2) {
    plugin.spooler.disableObserver();
    const newIndex = calculateRowIndex(event2, rowsContainer, movableRow, stationaryRow, offsetX, offsetY, index);
    if (newIndex != index) {
      handlePositionChange(barStatus, existsStatus, rowsContainer, rows, row, stationaryRow, newIndex);
      index = newIndex;
    }
    plugin.spooler.enableObserver();
  }
  window.addEventListener("mousemove", handleMouseMove);
  async function handleMouseUp() {
    deleteRowClone(settingsContainer, stationaryRow, movableRow);
    dragging = false;
    window.removeEventListener("mouseup", handleMouseUp);
    window.removeEventListener("mousemove", handleMouseMove);
    plugin.savePreset(barStatus);
  }
  window.addEventListener("mouseup", handleMouseUp);
}

// src/statusbar/fullscreen.ts
var menuListener;
var fullscreenCallback;
function monitorFullscreen(plugin) {
  if (typeof electronWindow !== "undefined") {
    fullscreenCallback = fullscreenChange(plugin);
    electronWindow.addListener("enter-full-screen", fullscreenCallback);
    electronWindow.addListener("leave-full-screen", fullscreenCallback);
    fullscreenCallback();
  }
}
function stopMonitoringFullscreen() {
  if (typeof electronWindow !== "undefined" && fullscreenCallback) {
    electronWindow.removeListener("enter-full-screen", fullscreenCallback);
    electronWindow.removeListener("leave-full-screen", fullscreenCallback);
  }
}
function fullscreenChange(plugin) {
  return async () => {
    const settings = plugin.settings;
    if (!settings.separateFullscreenPreset || !(getActivePreset(plugin) in settings.presets)) {
      if (isFullscreen())
        settings.activeFullscreenPreset = settings.activePreset;
      else
        settings.activePreset = settings.activeFullscreenPreset;
      await plugin.plugin.saveSettings();
    }
    fixOrder(plugin);
    menuListener == null ? void 0 : menuListener();
  };
}
function isFullscreen() {
  if (typeof electronWindow !== "undefined") {
    return electronWindow.isFullScreen();
  }
  return false;
}
function setFullscreenListener(callback) {
  menuListener = callback;
}

// src/statusbar/hotkeys.ts
function commandCallback(plugin, index) {
  return (checking) => {
    if (!plugin.settings.enabled)
      return false;
    const presets = plugin.settings.presetsOrder;
    if (presets.length <= index)
      return false;
    if (!checking) {
      setActivePreset(plugin, presets[index]);
      fixOrder(plugin);
    }
    return true;
  };
}
function registerHotkeys(plugin) {
  for (let i = 0; i < 10; i++) {
    plugin.plugin.addCommand({
      id: `statusbar-organizer-preset-${i}`,
      name: t(`Switch to preset slot {n}`).replace("{n}", (i + 1).toString()),
      checkCallback: commandCallback(plugin, i)
    });
  }
}

// src/statusbar/presets.ts
var import_obsidian5 = require("obsidian");
async function initializePresets(plugin, presetsContainer, settingsContainer) {
  presetsContainer.empty();
  if (plugin.settings.presetsOrder.length == 0) {
    plugin.settings.presetsOrder.push(t("Default"));
    plugin.settings.presets[t("Default")] = {};
    setActivePreset(plugin, t("Default"));
    await plugin.plugin.saveSettings();
  }
  if (!(getActivePreset(plugin) in plugin.settings.presets)) {
    setActivePreset(plugin, plugin.settings.presetsOrder[0]);
    await plugin.plugin.saveSettings();
  }
  for (let presetName of plugin.settings.presetsOrder) {
    const presetEntry = document.createElement("div");
    presetEntry.addClass("statusbar-organizer-preset");
    presetEntry.id = getPresetId(presetName);
    if (presetName == getActivePreset(plugin))
      presetEntry.addClass("statusbar-organizer-preset-active");
    presetsContainer.appendChild(presetEntry);
    const nameField = document.createElement("input");
    nameField.addClass("statusbar-organizer-preset-name");
    nameField.value = presetName;
    nameField.setAttribute("size", nameField.value.length.toString());
    nameField.maxLength = 25;
    presetEntry.appendChild(nameField);
    const renameButton = document.createElement("span");
    renameButton.addClass("statusbar-organizer-preset-delete");
    (0, import_obsidian5.setIcon)(renameButton, "pencil");
    renameButton.addEventListener("click", async (event) => {
      event.stopPropagation();
      select();
      nameField.focus();
    });
    const rename = async () => {
      nameField.blur();
      presetName = await renamePreset(plugin, presetEntry, nameField, presetName);
    };
    nameField.addEventListener("change", async () => rename());
    nameField.addEventListener("input", () => {
      nameField.setAttribute("size", Math.max(nameField.value.length, 1).toString());
    });
    presetEntry.appendChild(renameButton);
    const deleteButton = document.createElement("span");
    deleteButton.addClass("statusbar-organizer-preset-delete");
    (0, import_obsidian5.setIcon)(deleteButton, "x");
    deleteButton.addEventListener("click", async (event) => {
      event.stopPropagation();
      await deletePreset(plugin, presetsContainer, settingsContainer, presetName);
    });
    presetEntry.appendChild(deleteButton);
    const select = async () => {
      await selectPreset(plugin, presetEntry, presetName, settingsContainer);
    };
    presetEntry.addEventListener("click", async () => select());
  }
  const newPresetEntry = document.createElement("div");
  newPresetEntry.addClass("statusbar-organizer-preset");
  (0, import_obsidian5.setIcon)(newPresetEntry, "plus");
  newPresetEntry.addEventListener("click", () => addPreset(plugin, presetsContainer, settingsContainer));
  presetsContainer.appendChild(newPresetEntry);
  registerHotkeys(plugin, plugin.settings.presetsOrder);
}
async function addPreset(plugin, presetsContainer, settingsContainer) {
  const presetName = disambiguate(t("New Preset"), plugin.settings.presetsOrder);
  plugin.settings.presets[presetName] = deepCopy(plugin.settings.presets[getActivePreset(plugin)]);
  plugin.settings.presetsOrder.push(presetName);
  setActivePreset(plugin, presetName);
  await plugin.plugin.saveSettings();
  await initializePresets(plugin, presetsContainer, settingsContainer);
}
async function deletePreset(plugin, presetsContainer, settingsContainer, presetName) {
  if (getActivePreset(plugin) == presetName) {
    const currentIndex = plugin.settings.presetsOrder.indexOf(presetName);
    if (currentIndex > 0)
      setActivePreset(plugin, plugin.settings.presetsOrder[currentIndex - 1]);
    else if (currentIndex < plugin.settings.presetsOrder.length - 1)
      setActivePreset(plugin, plugin.settings.presetsOrder[currentIndex + 1]);
    else
      setActivePreset(plugin, t("Default"));
  }
  delete plugin.settings.presets[presetName];
  plugin.settings.presetsOrder = plugin.settings.presetsOrder.filter((x) => x != presetName);
  await plugin.plugin.saveSettings();
  await initializePresets(plugin, presetsContainer, settingsContainer);
  await initializeRows(plugin, settingsContainer);
}
async function renamePreset(plugin, presetEntry, nameField, presetName) {
  let newName = nameField.value.substring(0, 25).trim();
  const otherPresets = plugin.settings.presetsOrder.filter((x) => x != presetName);
  newName = newName == "" ? disambiguate(t("New Preset"), otherPresets) : disambiguate(newName, otherPresets, 2, true);
  nameField.value = newName;
  nameField.setAttribute("size", newName.length.toString());
  if (newName == presetName)
    return presetName;
  presetEntry.id = getPresetId(newName);
  plugin.settings.presets[newName] = plugin.settings.presets[presetName];
  delete plugin.settings.presets[presetName];
  plugin.settings.presetsOrder = plugin.settings.presetsOrder.map((x) => x == presetName ? newName : x);
  setActivePreset(plugin, newName);
  await plugin.plugin.saveSettings();
  return newName;
}
async function selectPreset(plugin, presetEntry, presetName, settingsContainer) {
  var _a;
  (_a = document.getElementById(getPresetId(getActivePreset(plugin)))) == null ? void 0 : _a.removeClass("statusbar-organizer-preset-active");
  presetEntry.addClass("statusbar-organizer-preset-active");
  await setActivePreset(plugin, presetName);
  await initializeRows(plugin, settingsContainer);
}
async function setActivePreset(plugin, presetName) {
  if (isFullscreen()) {
    plugin.settings.activeFullscreenPreset = presetName;
  } else {
    plugin.settings.activePreset = presetName;
  }
  await plugin.plugin.saveSettings();
}
function getActivePreset(plugin) {
  if (isFullscreen()) {
    return plugin.settings.activeFullscreenPreset;
  } else {
    return plugin.settings.activePreset;
  }
}
function disambiguate(presetName, presets, start = 1, allowNoNumber = false) {
  if (allowNoNumber && !presets.includes(presetName))
    return presetName;
  while (presets.includes(`${presetName} ${start}`))
    start++;
  return `${presetName} ${start}`;
}
function getPresetId(presetName) {
  return `statusbar-organizer-preset-${generatePresetId(presetName)}`;
}

// src/statusbar/organizer.ts
function fixOrder(plugin) {
  if (!plugin.statusBar)
    return;
  const elements = getStatusBarElements(plugin.statusBar);
  const activePresetName = getActivePreset(plugin);
  const status = plugin.settings.presets[activePresetName];
  if (!status)
    return;
  const known = [];
  const orphans = [];
  for (const element of elements) {
    if (element.id in status) {
      const myStatus = status[element.id];
      known.push([element, myStatus.position]);
      if (myStatus.visible)
        element.element.removeClass("statusbar-organizer-element-hidden");
      else
        element.element.addClass("statusbar-organizer-element-hidden");
    } else {
      orphans.push(element.element);
    }
  }
  const orderedElements = known.sort((a, b) => a[1] - b[1]).map((x) => x[0].element);
  const allElements = orderedElements.concat(orphans);
  for (const [i, element] of allElements.entries()) {
    if (element)
      element.style.order = (i + 1).toString();
  }
}

// src/statusbar/manager.ts
var StatusBarManager = class {
  constructor(app, plugin) {
    this.app = app;
    this.plugin = plugin;
    this.settings = this.plugin.settings.myStatusBar;
  }
  async onload() {
    this.statusBar = document.querySelector(".status-bar");
    if (!this.statusBar) {
      this.app.workspace.onLayoutReady(() => {
        this.statusBar = document.querySelector(".status-bar");
        if (this.statusBar)
          this.initializeManager();
      });
      return;
    }
    this.initializeManager();
  }
  initializeManager() {
    if (!this.statusBar)
      return;
    this.spooler = new Spooler(this, fixOrder);
    monitorFullscreen(this);
    fixOrder(this);
    registerHotkeys(this);
    this.spooler.enableObserver();
  }
  onunload() {
    if (this.spooler)
      this.spooler.disableObserver();
    stopMonitoringFullscreen();
  }
  saveSettings() {
    return this.plugin.saveSettings();
  }
  async savePreset(currentBarStatus) {
    this.settings.presets[getActivePreset(this)] = deepCopy(currentBarStatus);
    await this.saveSettings();
  }
  /**
   * Merge information about status bar elements based on
   * the saved settings and the state of the actual status bar.
   */
  async consolidateSettingsAndElements() {
    const loadedElementStatus = this.settings.presets[getActivePreset(this)] || {};
    if (!this.statusBar) {
      return { rows: [], barStatus: {}, existsStatus: {} };
    }
    const unorderedStatusBarElements = getStatusBarElements(this.statusBar);
    const defaultElementStatus = {};
    for (const [index, statusBarElement] of unorderedStatusBarElements.entries()) {
      defaultElementStatus[statusBarElement.id] = {
        position: index,
        visible: true
      };
    }
    const barStatus = {};
    const existsStatus = {};
    for (const [index, status] of Object.entries(loadedElementStatus)) {
      barStatus[index] = status;
      existsStatus[index] = index in defaultElementStatus;
    }
    let insertPosition = Object.keys(barStatus).length + 1;
    for (const element of unorderedStatusBarElements) {
      if (element.id in barStatus)
        continue;
      const status = defaultElementStatus[element.id];
      status.position = insertPosition++;
      barStatus[element.id] = status;
      existsStatus[element.id] = true;
    }
    const disabledStatusBarElements = Object.keys(loadedElementStatus).filter((x) => !existsStatus[x]).map((x) => {
      const parsed = parseElementId(x);
      return {
        name: parsed.name,
        index: parsed.index,
        id: x
      };
    });
    const rows = unorderedStatusBarElements.concat(disabledStatusBarElements).map((x) => [x, barStatus[x.id].position]).sort((a, b) => a[1] - b[1]).map((x) => x[0]);
    await this.savePreset(barStatus);
    this.spooler.spoolFix(0);
    return {
      rows,
      barStatus,
      existsStatus
    };
  }
};

// src/statusbar/settings-ui.ts
var import_obsidian6 = require("obsidian");
function renderStatusBarSettings(containerEl, manager) {
  const plugin = manager;
  showSettings(plugin, containerEl);
}
async function showSettings(plugin, topContainer) {
  topContainer.empty();
  const dummyInput = document.createElement("input");
  dummyInput.setAttribute("autofocus", "autofocus");
  dummyInput.setAttribute("type", "hidden");
  topContainer.appendChild(dummyInput);
  const presetsContainer = document.createElement("div");
  presetsContainer.addClass("statusbar-organizer-presets-container");
  topContainer.appendChild(presetsContainer);
  const settingsContainer = document.createElement("div");
  settingsContainer.addClass("statusbar-organizer-rows-container-wrapper");
  topContainer.appendChild(settingsContainer);
  await initializePresets(plugin, presetsContainer, settingsContainer);
  await initializeRows(plugin, settingsContainer);
  new import_obsidian6.Setting(topContainer).setName(t("Separate fullscreen and windowed mode")).setDesc(t("When enabled, the plugin will remember which preset was active for fullscreen mode and which for windowed mode and switch correspondingly. This is useful for example when you want to display more information in fullscreen mode, like a clock.")).addToggle(
    (toggle) => toggle.setValue(plugin.settings.separateFullscreenPreset).onChange(async (value) => {
      plugin.settings.separateFullscreenPreset = value;
      plugin.plugin.saveSettings();
    })
  );
  setFullscreenListener(async () => {
    await initializePresets(plugin, presetsContainer, settingsContainer);
    await initializeRows(plugin, settingsContainer);
  });
}

// src/plugins/manager.ts
var import_obsidian7 = require("obsidian");
var PluginsManager = class {
  constructor(app, plugin) {
    this.manifests = [];
    this.pendingTimeouts = [];
    this.device = "desktop/global";
    this.app = app;
    this.plugin = plugin;
  }
  get settings() {
    return this.plugin.settings.myPlugins;
  }
  get deviceSettings() {
    if (this.settings.dualConfigs && import_obsidian7.Platform.isMobile) {
      return this.settings.mobile || this.settings.desktop;
    }
    return this.settings.desktop;
  }
  async onload() {
    if (!this.settings.enabled)
      return;
    if (this.settings.dualConfigs && import_obsidian7.Platform.isMobile) {
      if (!this.settings.mobile) {
        this.settings.mobile = JSON.parse(JSON.stringify(this.settings.desktop));
        await this.plugin.saveSettings();
      }
      this.device = "mobile";
    } else {
      this.device = "desktop/global";
    }
    this.updateManifests();
    await this.setInitialPluginsConfiguration();
    this.manifests.forEach((plugin) => this.setPluginStartup(plugin.id));
  }
  onunload() {
    this.pendingTimeouts.forEach((timeout) => clearTimeout(timeout));
  }
  async setPluginStartup(pluginId) {
    var _a, _b;
    const obsidian = this.app.plugins;
    const startupType = this.getPluginStartup(pluginId);
    const isActiveOnStartup = obsidian.enabledPlugins.has(pluginId);
    const isRunning = (_b = (_a = obsidian.plugins) == null ? void 0 : _a[pluginId]) == null ? void 0 : _b._loaded;
    switch (startupType) {
      case "disabled" /* disabled */:
        await obsidian.disablePluginAndSave(pluginId);
        break;
      case "instant" /* instant */:
        if (!isActiveOnStartup && !isRunning)
          await obsidian.enablePluginAndSave(pluginId);
        break;
      case "short" /* short */:
      case "long" /* long */:
        if (isActiveOnStartup) {
          await obsidian.disablePluginAndSave(pluginId);
          await obsidian.enablePlugin(pluginId);
        } else if (!isRunning) {
          const seconds = startupType === "short" /* short */ ? this.deviceSettings.shortDelaySeconds : this.deviceSettings.longDelaySeconds;
          const stagger = isNaN(this.deviceSettings.delayBetweenPlugins) ? 40 : this.deviceSettings.delayBetweenPlugins;
          const delay = this.manifests.findIndex((x) => x.id === pluginId) * stagger;
          const timeout = setTimeout(async () => {
            var _a2, _b2;
            try {
              if (!((_b2 = (_a2 = obsidian.plugins) == null ? void 0 : _a2[pluginId]) == null ? void 0 : _b2._loaded)) {
                if (this.settings.showConsoleLog) {
                  console.log(t("Starting {id} after a {type} delay").replace("{id}", pluginId).replace("{type}", startupType));
                }
                await obsidian.enablePlugin(pluginId);
              }
            } catch (e) {
              console.error(t("Failed to load plugin {id} after delay:").replace("{id}", pluginId), e);
            }
          }, seconds * 1e3 + delay);
          this.pendingTimeouts.push(timeout);
        }
        break;
    }
  }
  getPluginStartup(pluginId) {
    var _a, _b;
    return ((_b = (_a = this.deviceSettings.plugins) == null ? void 0 : _a[pluginId]) == null ? void 0 : _b.startupType) || this.deviceSettings.defaultStartupType || // @ts-ignore
    (this.app.plugins.enabledPlugins.has(pluginId) ? "instant" /* instant */ : "disabled" /* disabled */);
  }
  async setInitialPluginsConfiguration() {
    var _a, _b;
    for (const plugin of this.manifests) {
      if (!((_b = (_a = this.deviceSettings.plugins) == null ? void 0 : _a[plugin.id]) == null ? void 0 : _b.startupType)) {
        await this.updatePluginSettings(plugin.id, this.getPluginStartup(plugin.id));
      }
    }
  }
  async updatePluginSettings(pluginId, startupType) {
    this.deviceSettings.plugins[pluginId] = { startupType };
    await this.plugin.saveSettings();
  }
  updateManifests() {
    this.manifests = Object.values(this.app.plugins.manifests).filter((plugin) => plugin.id !== this.plugin.manifest.id && !(import_obsidian7.Platform.isMobile && plugin.isDesktopOnly)).sort((a, b) => a.name.localeCompare(b.name));
  }
};

// src/plugins/settings-ui.ts
var import_obsidian8 = require("obsidian");
function renderPluginsSettings(containerEl, manager) {
  const view = new PluginsSettingsView(containerEl, manager);
  view.display();
}
var PluginsSettingsView = class {
  constructor(containerEl, manager) {
    this.dropdowns = [];
    this.containerEl = containerEl;
    this.manager = manager;
  }
  get settings() {
    return this.manager.settings;
  }
  async display() {
    const { containerEl } = this;
    if (!this.settings.enabled)
      return;
    new import_obsidian8.Setting(containerEl).setName(t("Separate desktop/mobile configuration")).setDesc(t("Enable this if you want to have different settings depending whether you're using a desktop or mobile device. All of the settings below can be configured differently on desktop and mobile. You're currently using the {device} settings.").replace("{device}", this.manager.device)).addToggle((toggle) => {
      toggle.setValue(this.settings.dualConfigs).onChange(async (value) => {
        this.settings.dualConfigs = value;
        await this.manager.plugin.saveSettings();
        await this.manager.onload();
      });
    });
    Object.entries({
      shortDelaySeconds: t("Short delay (seconds)"),
      longDelaySeconds: t("Long delay (seconds)")
    }).forEach(([key, name]) => {
      new import_obsidian8.Setting(containerEl).setName(name).addText((text) => text.setValue(this.manager.deviceSettings[key].toString()).onChange(async (value) => {
        this.manager.deviceSettings[key] = parseFloat(parseFloat(value).toFixed(3));
        await this.manager.plugin.saveSettings();
      }));
    });
    new import_obsidian8.Setting(containerEl).setName(t("Default startup type for new plugins")).addDropdown((dropdown) => {
      dropdown.addOption("", t("Nothing configured"));
      this.addDelayOptions(dropdown);
      dropdown.setValue(this.manager.deviceSettings.defaultStartupType || "").onChange(async (value) => {
        this.manager.deviceSettings.defaultStartupType = value || null;
        await this.manager.plugin.saveSettings();
      });
    });
    new import_obsidian8.Setting(containerEl).setName(t("Show plugin descriptions")).addToggle((toggle) => {
      toggle.setValue(this.manager.deviceSettings.showDescriptions).onChange(async (value) => {
        this.manager.deviceSettings.showDescriptions = value;
        await this.manager.plugin.saveSettings();
        this.buildPluginList();
      });
    });
    new import_obsidian8.Setting(containerEl).setName(t("Set the delay for all plugins at once")).addDropdown((dropdown) => {
      dropdown.addOption("", t("Set all plugins to be:"));
      this.addDelayOptions(dropdown);
      dropdown.onChange(async (value) => {
        this.manager.manifests.forEach((plugin) => {
          this.manager.deviceSettings.plugins[plugin.id] = { startupType: value };
        });
        this.dropdowns.forEach((d) => d.setValue(value));
        dropdown.setValue("");
        await this.manager.plugin.saveSettings();
      });
    });
    const filterSetting = new import_obsidian8.Setting(containerEl).setName(t("Plugins")).setHeading().setDesc(t("Filter by: "));
    this.addFilterButton(filterSetting.descEl, t("All"));
    Object.keys(LoadingMethod).forEach((key) => this.addFilterButton(filterSetting.descEl, t(LoadingMethod[key]) || key, key));
    new import_obsidian8.Setting(containerEl).addText((text) => text.setPlaceholder(t("Type to filter list")).onChange((value) => {
      this.filterString = value;
      this.buildPluginList();
    }));
    this.pluginListContainer = containerEl.createEl("div");
    this.buildPluginList();
  }
  buildPluginList() {
    this.pluginListContainer.empty();
    this.manager.updateManifests();
    this.manager.manifests.forEach((plugin) => {
      const currentValue = this.manager.getPluginStartup(plugin.id);
      if (this.filterMethod && currentValue !== this.filterMethod)
        return;
      if (this.filterString && !plugin.name.toLowerCase().includes(this.filterString.toLowerCase()))
        return;
      new import_obsidian8.Setting(this.pluginListContainer).setName(plugin.name).addDropdown((dropdown) => {
        this.dropdowns.push(dropdown);
        this.addDelayOptions(dropdown);
        dropdown.setValue(currentValue).onChange(async (value) => {
          await this.manager.updatePluginSettings(plugin.id, value);
          this.manager.setPluginStartup(plugin.id);
        });
      }).then((setting) => {
        if (this.manager.deviceSettings.showDescriptions) {
          setting.setDesc(plugin.description);
        }
      });
    });
  }
  addDelayOptions(el) {
    const loadingMethodsDisplay = {
      disabled: t("\u26D4 Disable plugin"),
      instant: t("\u26A1 Instant"),
      short: t("\u231A Short delay"),
      long: t("\u{1F4A4} Long delay")
    };
    Object.keys(loadingMethodsDisplay).forEach((key) => {
      el.addOption(key, loadingMethodsDisplay[key]);
    });
  }
  addFilterButton(el, text, value) {
    const link = el.createEl("button", { text });
    link.addClass("lazy-plugin-filter");
    link.style.marginRight = "5px";
    link.onclick = () => {
      this.filterMethod = value;
      this.buildPluginList();
    };
  }
};

// src/snippets/manager.ts
var import_obsidian12 = require("obsidian");

// src/snippets/icons/customIcons.ts
var import_obsidian9 = require("obsidian");
var icons = {
  "art-fill": `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke-width="0" stroke-linecap="round" stroke-linejoin="round"><path d="M20 14c-.092.064-2 2.083-2 3.5c0 1.494.949 2.448 2 2.5c.906.044 2-.891 2-2.5c0-1.5-1.908-3.436-2-3.5zM9.586 20c.378.378.88.586 1.414.586s1.036-.208 1.414-.586l7-7l-.707-.707L11 4.586L8.707 2.293L7.293 3.707L9.586 6L4 11.586c-.378.378-.586.88-.586 1.414s.208 1.036.586 1.414L9.586 20zM11 7.414L16.586 13H5.414L11 7.414z" fill="currentColor"/></svg>`,
  "art-brush": `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke-width="0" stroke-linecap="round" stroke-linejoin="round"><path d="M18 2H7c-1.103 0-2 .897-2 2v3c0 1.103.897 2 2 2h11c1.103 0 2-.897 2-2V4c0-1.103-.897-2-2-2zM7 7V4h11l.002 3H7z" fill="currentColor"/><path d="M13 15v-2c0-1.103-.897-2-2-2H4V5c-1.103 0-2 .897-2 2v4c0 1.103.897 2 2 2h7v2a1 1 0 0 0-1 1v5a1 1 0 0 0 1 1h2a1 1 0 0 0 1-1v-5a1 1 0 0 0-1-1z" fill="currentColor"/></svg>`,
  "ms-create-file": `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke-width="0" stroke-linecap="round" stroke-linejoin="round"><g class="icon-tabler" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20 4l-2 14.5l-6 2l-6-2L4 4z"/><path d="M8.5 8h7L11 12h4l-.5 3.5l-2.5.75l-2.5-.75l-.1-.5"/></g></svg>`,
  "pantone-line": `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke-width="0" stroke-linecap="round" stroke-linejoin="round"><path d="M5.764 8l-.295-.73a1 1 0 0 1 .553-1.302l9.272-3.746a1 1 0 0 1 1.301.552l5.62 13.908a1 1 0 0 1-.553 1.302L12.39 21.73a1 1 0 0 1-1.302-.553L11 20.96V21H7a1 1 0 0 1-1-1v-.27l-3.35-1.353a1 1 0 0 1-.552-1.302L5.764 8zM8 19h2.209L8 13.533V19zm-2-6.244l-1.673 4.141L6 17.608v-4.852zm1.698-5.309l4.87 12.054l7.418-2.997l-4.87-12.053l-7.418 2.996zm2.978 2.033a1 1 0 1 1-.749-1.855a1 1 0 0 1 .75 1.855z" fill="currentColor"/></svg>`,
  "ms-code": `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke-width="0" stroke-linecap="round" stroke-linejoin="round"><g fill="none"><path d="M20 21H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2zM4 7v12h16V7H4zm10.707 9.707l-1.413-1.413L15.586 13l-2.293-2.293l1.414-1.414L18.414 13l-3.706 3.706l-.001.001zm-5.414 0L5.586 13l3.707-3.707l1.414 1.414L8.414 13l2.292 2.293l-1.413 1.413v.001z" fill="currentColor"/></g></svg>`,
  "ms-reload": `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><path d="M6 4h15a1 1 0 0 1 1 1v7h-2V6H6v3L1 5l5-4v3zm12 16H3a1 1 0 0 1-1-1v-7h2v6h14v-3l5 4l-5 4v-3z" fill="white"/></svg>`,
  "ms-folder": `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><path fill="white" d="M20 5h-8.586L9.707 3.293A.997.997 0 0 0 9 3H4c-1.103 0-2 .897-2 2v14c0 1.103.897 2 2 2h16c1.103 0 2-.897 2-2V7c0-1.103-.897-2-2-2zM4 19V7h16l.002 12H4z"></path></svg>`,
  "ms-snippet": `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><path d="M7.375 16.781l1.25-1.562L4.601 12l4.024-3.219l-1.25-1.562l-5 4a1 1 0 0 0 0 1.562l5 4zm9.25-9.562l-1.25 1.562L19.399 12l-4.024 3.219l1.25 1.562l5-4a1 1 0 0 0 0-1.562l-5-4zm-1.649-4.003l-4 18l-1.953-.434l4-18z" fill="white"/></svg>`,
  "ms-add": `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke="white" stroke-width="0" stroke-linecap="round" stroke-linejoin="round"><path d="M13 7h-2v4H7v2h4v4h2v-4h4v-2h-4z" fill="white"/><path d="M12 2C6.486 2 2 6.486 2 12s4.486 10 10 10s10-4.486 10-10S17.514 2 12 2zm0 18c-4.411 0-8-3.589-8-8s3.589-8 8-8s8 3.589 8 8s-3.589 8-8 8z" fill="white"/></svg>`,
  "ms-save": `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke="white" stroke-width="0" stroke-linecap="round" stroke-linejoin="round"><path d="M5 21h14a2 2 0 0 0 2-2V8a1 1 0 0 0-.29-.71l-4-4A1 1 0 0 0 16 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2zm10-2H9v-5h6zM13 7h-2V5h2zM5 5h2v4h8V5h.59L19 8.41V19h-2v-5a2 2 0 0 0-2-2H9a2 2 0 0 0-2 2v5H5z" fill="white"/></svg>`,
  "ms-delete": `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke="white" stroke-width="0" stroke-linecap="round" stroke-linejoin="round"><path d="M5 20a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V8h2V6h-4V4a2 2 0 0 0-2-2H9a2 2 0 0 0-2 2v2H3v2h2zM9 4h6v2H9zM8 8h9v12H7V8z" fill="white"/><path d="M9 10h2v8H9zm4 0h2v8h-2z" fill="white"/></svg>`,
  "ms-css-file": `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke-width="0" stroke-linecap="round" stroke-linejoin="round"><path d="M 6 2 C 4.895 2 4 2.895 4 4 L 4 9 L 3 9 C 1.895 9 1 9.895 1 11 L 1 16 C 1 17.105 1.895 18 3 18 L 4 18 L 4 20 C 4 21.105 4.895 22 6 22 L 18 22 C 19.105 22 20 21.105 20 20 L 20 7.828125 C 20 7.298125 19.789062 6.7890625 19.414062 6.4140625 L 15.585938 2.5859375 C 15.210937 2.2109375 14.701875 2 14.171875 2 L 6 2 z M 6 4 L 14 4 L 14 7 C 14 7.552 14.448 8 15 8 L 18 8 L 18 20 L 6 20 L 6 18 L 15 18 C 16.105 18 17 17.105 17 16 L 17 11 C 17 9.895 16.105 9 15 9 L 6 9 L 6 4 z M 5 11 C 6.105 11 7 11.895 7 13 L 6 13 C 6 12.449 5.551 12 5 12 C 4.449 12 4 12.449 4 13 L 4 14 C 4 14.551 4.449 15 5 15 C 5.551 15 6 14.551 6 14 L 7 14 C 7 15.105 6.105 16 5 16 C 3.895 16 3 15.105 3 14 L 3 13 C 3 11.895 3.895 11 5 11 z M 9.6445312 11.001953 C 11.067531 11.042953 11.154297 12.284859 11.154297 12.505859 L 10.1875 12.505859 C 10.1875 12.402859 10.204906 11.806641 9.6289062 11.806641 C 9.4539062 11.806641 9.0598438 11.884187 9.0898438 12.367188 C 9.1188437 12.808188 9.7035469 13.018406 9.8105469 13.066406 C 10.034547 13.148406 11.141391 13.642391 11.150391 14.650391 C 11.152391 14.864391 11.097062 15.985 9.6640625 16 C 8.1050625 16.017 8 14.675438 8 14.398438 L 8.9746094 14.398438 C 8.9746094 14.545438 8.9870625 15.256172 9.6640625 15.201172 C 10.071063 15.167172 10.159828 14.87425 10.173828 14.65625 C 10.195828 14.29025 9.8465625 14.070578 9.4765625 13.892578 C 8.9565625 13.642578 8.1341406 13.335328 8.1191406 12.361328 C 8.1061406 11.484328 8.7505312 10.976953 9.6445312 11.001953 z M 13.490234 11.001953 C 14.913234 11.042953 15 12.284859 15 12.505859 L 14.03125 12.505859 C 14.03125 12.402859 14.048656 11.806641 13.472656 11.806641 C 13.297656 11.806641 12.905547 11.884187 12.935547 12.367188 C 12.964547 12.808188 13.547297 13.018406 13.654297 13.066406 C 13.878297 13.148406 14.987094 13.642391 14.996094 14.650391 C 14.998094 14.864391 14.942766 15.985 13.509766 16 C 11.950766 16.017 11.845703 14.675437 11.845703 14.398438 L 12.820312 14.398438 C 12.820312 14.545438 12.832766 15.256172 13.509766 15.201172 C 13.916766 15.167172 14.005531 14.87425 14.019531 14.65625 C 14.041531 14.29025 13.692266 14.070578 13.322266 13.892578 C 12.802266 13.642578 11.979844 13.335328 11.964844 12.361328 C 11.951844 11.484328 12.596234 10.976953 13.490234 11.001953 z" fill="currentColor"/></svg>`
};
function addIcons() {
  Object.keys(icons).forEach((key) => {
    (0, import_obsidian9.addIcon)(key, icons[key]);
  });
}

// src/snippets/ui/snippetsMenu.ts
var import_obsidian11 = require("obsidian");

// src/snippets/util/setAttributes.ts
function setAttributes(element, attributes) {
  for (let key in attributes) {
    element.setAttribute(key, attributes[key]);
  }
}

// src/snippets/modal/createSnippetModal.ts
var import_obsidian10 = require("obsidian");
var CreateSnippetModal = class extends import_obsidian10.Modal {
  constructor(app, manager) {
    super(app);
    this.app = app;
    this.manager = manager;
    this.onOpen = () => this.display(true);
  }
  async display(focus) {
    const { contentEl } = this;
    const customCss = this.app.customCss;
    contentEl.empty();
    contentEl.setAttribute("style", "margin-top: 0px");
    const title = document.createElement("h1");
    title.setText(t("Create a CSS Snippet"));
    contentEl.appendChild(title);
    const fileTitleSetting = new import_obsidian10.Setting(contentEl);
    const fileTitleValue = new import_obsidian10.TextComponent(fileTitleSetting.controlEl);
    fileTitleSetting.setName(t("CSS Snippet Title")).setDesc(t("Write the title for this CSS snippet file."));
    const cssStylesSetting = new import_obsidian10.Setting(contentEl);
    cssStylesSetting.settingEl.setAttribute(
      "style",
      "display: grid; grid-template-columns: 1fr;"
    );
    const cssStylesValue = new import_obsidian10.TextAreaComponent(cssStylesSetting.controlEl);
    setAttributes(cssStylesValue.inputEl, {
      style: "margin-top: 12px; width: 100%;  height: 32vh;",
      class: "ms-css-editor"
    });
    cssStylesSetting.setName(t("CSS Snippet Styles")).setDesc(t("Add in styling for this CSS snippet file."));
    cssStylesValue.setValue(this.manager.settings.stylingTemplate);
    const doAdd = async () => {
      let fileName = fileTitleValue.getValue();
      let fileContents = cssStylesValue.getValue();
      let snippetPath = customCss.getSnippetPath(fileName);
      if (fileName) {
        if (!customCss.snippets.includes(fileName)) {
          await this.app.vault.create(
            `${customCss.getSnippetsFolder()}/${fileName}.css`,
            fileContents
          );
          console.log("%c" + t('"{fileName}.css" has been created!').replace("{fileName}", fileName), "color: Violet");
          if (this.manager.settings.snippetEnabledStatus)
            customCss.setCssEnabledStatus(fileName, true);
          if (this.manager.settings.openSnippetFile)
            this.app.openWithDefaultApp(snippetPath);
          customCss.requestLoadSnippets();
          this.close();
        } else
          new import_obsidian10.Notice(t('"{fileName}.css" already exists.').replace("{fileName}", fileName));
      } else
        new import_obsidian10.Notice(t("Missing name for file"));
    };
    const saveButton = new import_obsidian10.ButtonComponent(contentEl).setButtonText(t("Create Snippet")).onClick(doAdd);
    saveButton.buttonEl.addClass("wg-button");
    fileTitleValue.inputEl.focus();
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/snippets/ui/snippetsMenu.ts
function snippetsMenu(app, manager, settings) {
  const windowX = window.innerWidth;
  const windowY = window.innerHeight;
  const menuExists = document.querySelector(".menu.MySnippets-statusbar-menu");
  if (!menuExists) {
    const menu = new import_obsidian11.Menu();
    const menuDom = menu.dom;
    menuDom.addClass("MySnippets-statusbar-menu");
    if (settings.aestheticStyle) {
      menuDom.setAttribute(
        "style",
        "background-color: transparent; backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px);"
      );
    }
    const customCss = app.customCss;
    const currentSnippets = customCss.snippets;
    const snippetsFolder = customCss.getSnippetsFolder();
    currentSnippets.forEach((snippet) => {
      const snippetPath = customCss.getSnippetPath(snippet);
      menu.addItem((snippetElement) => {
        snippetElement.setTitle(snippet);
        const snippetElementDom = snippetElement.dom;
        const toggleComponent = new import_obsidian11.ToggleComponent(snippetElementDom);
        const buttonComponent = new import_obsidian11.ButtonComponent(snippetElementDom);
        function changeSnippetStatus() {
          const isEnabled = customCss.enabledSnippets.has(snippet);
          customCss.setCssEnabledStatus(snippet, !isEnabled);
        }
        toggleComponent.setValue(customCss.enabledSnippets.has(snippet)).onChange(changeSnippetStatus);
        buttonComponent.setIcon("ms-snippet").setClass("MS-OpenSnippet").setTooltip(t(`Open snippet`)).onClick((e) => {
          app.openWithDefaultApp(snippetPath);
        });
        snippetElement.onClick((e) => {
          e.preventDefault();
          e.stopImmediatePropagation();
        });
      });
    });
    menu.addSeparator();
    menu.addItem((actions) => {
      const enhancedActions = actions;
      enhancedActions.setIcon(null);
      enhancedActions.setTitle(t("Actions"));
      const actionsDom = enhancedActions.dom;
      setAttributes(enhancedActions.titleEl, { style: "font-weight: 700" });
      const reloadButton = new import_obsidian11.ButtonComponent(actionsDom);
      const folderButton = new import_obsidian11.ButtonComponent(actionsDom);
      const addButton = new import_obsidian11.ButtonComponent(actionsDom);
      setAttributes(reloadButton.buttonEl, { style: "margin-right: 3px" });
      setAttributes(addButton.buttonEl, { style: "margin-left: 3px" });
      reloadButton.setIcon("ms-reload").setClass("MySnippetsButton").setClass("MS-Reload").setTooltip(t("Reload snippets")).onClick((e) => {
        customCss.requestLoadSnippets();
        new import_obsidian11.Notice(t("Snippets reloaded"));
      });
      folderButton.setIcon("ms-folder").setClass("MySnippetsButton").setClass("MS-Folder").setTooltip(t("Open snippets folder")).onClick((e) => {
        app.openWithDefaultApp(snippetsFolder);
      });
      addButton.setIcon("ms-add").setClass("MySnippetsButton").setClass("MS-Folder").setTooltip(t("Create new snippet")).onClick((e) => {
        new CreateSnippetModal(app, manager).open();
      });
    });
    menu.showAtPosition({
      x: windowX - 15,
      y: windowY - 37
    });
  }
}

// src/snippets/manager.ts
var SnippetsManager = class {
  constructor(app, plugin) {
    this.app = app;
    this.plugin = plugin;
    this.settings = this.plugin.settings.mySnippets;
  }
  async onload() {
    console.log("Loading MySnippets module...");
    addIcons();
    if (this.app.workspace.layoutReady) {
      this.setupSnippetsStatusBarIcon();
    } else {
      this.app.workspace.onLayoutReady(() => {
        setTimeout(() => {
          this.setupSnippetsStatusBarIcon();
        });
      });
    }
    this.plugin.addCommand({
      id: `open-snippets-menu`,
      name: t(`Open snippets in status bar`),
      icon: `pantone-line`,
      callback: async () => {
        if (this.settings.enabled)
          snippetsMenu(this.app, this, this.settings);
      }
    });
    this.plugin.addCommand({
      id: `open-snippets-create`,
      name: t(`Create new CSS snippet`),
      icon: `ms-css-file`,
      callback: async () => {
        if (this.settings.enabled)
          new CreateSnippetModal(this.app, this).open();
      }
    });
  }
  onunload() {
    console.log("Unloading MySnippets module...");
    if (this.statusBarIcon) {
      this.statusBarIcon.remove();
      this.statusBarIcon = void 0;
    }
  }
  setupSnippetsStatusBarIcon() {
    if (!this.settings.showStatusBarIcon) {
      if (this.statusBarIcon) {
        this.statusBarIcon.remove();
        this.statusBarIcon = void 0;
      }
      return;
    }
    if (this.statusBarIcon)
      return;
    this.statusBarIcon = this.plugin.addStatusBarItem();
    this.statusBarIcon.addClass("MiniSettings-statusbar-button");
    this.statusBarIcon.addClass("mod-clickable");
    setAttributes(this.statusBarIcon, {
      "aria-label": "Configure Snippets",
      "aria-label-position": "top"
    });
    (0, import_obsidian12.setIcon)(this.statusBarIcon, "pantone-line");
    this.statusBarIcon.addEventListener("click", () => {
      snippetsMenu(this.app, this, this.settings);
    });
  }
  updateStatusBar() {
    this.setupSnippetsStatusBarIcon();
  }
  saveSettings() {
    return this.plugin.saveSettings();
  }
};

// src/snippets/settings-ui.ts
var import_obsidian13 = require("obsidian");
function renderSnippetsSettings(containerEl, manager) {
  const plugin = manager.plugin;
  const settings = manager.settings;
  new import_obsidian13.Setting(containerEl).setName(t("Show Status Bar Icon")).setDesc(t("Toggle the visibility of the snippets icon in the status bar.")).addToggle((toggle) => {
    toggle.setValue(settings.showStatusBarIcon).onChange(async (value) => {
      settings.showStatusBarIcon = value;
      await manager.saveSettings();
      manager.updateStatusBar();
    });
  });
  const snippetsSection = containerEl.createEl("details");
  const snippetsSummary = containerEl.createEl("summary");
  snippetsSummary.innerText = t("Manage Snippets");
  snippetsSection.appendChild(snippetsSummary);
  const snippetsContainer = snippetsSection.createDiv();
  snippetsContainer.addClass("ms-manage-snippets-container");
  renderSnippetsList(snippetsContainer, manager);
  containerEl.appendChild(snippetsSection);
  new import_obsidian13.Setting(containerEl).setName(t("Glass menu effect")).setDesc(
    t("Choose to change the background from the secondary background color of your theme to a glass background.")
  ).addToggle((toggle) => {
    toggle.setValue(settings.aestheticStyle).onChange(async (value) => {
      settings.aestheticStyle = value;
      await manager.saveSettings();
    });
  });
  new import_obsidian13.Setting(containerEl).setName(t("Auto open new snippet")).setDesc(
    t("Choose whether or not to open CSS snippet files immeditaley after creating them. It will open in your default app.")
  ).addToggle((toggle) => {
    toggle.setValue(settings.openSnippetFile).onChange(async (value) => {
      settings.openSnippetFile = value;
      await manager.saveSettings();
    });
  });
  new import_obsidian13.Setting(containerEl).setName(t("Set new snippet status")).setDesc(
    t("Choose whether or not to have newly created CSS snippet files toggled on automatically upon creation.")
  ).addToggle((toggle) => {
    toggle.setValue(settings.snippetEnabledStatus).onChange(async (value) => {
      settings.snippetEnabledStatus = value;
      await manager.saveSettings();
    });
  });
  const stylingTemplateSetting = new import_obsidian13.Setting(containerEl);
  stylingTemplateSetting.settingEl.setAttribute(
    "style",
    "display: grid; grid-template-columns: 1fr;"
  );
  stylingTemplateSetting.setName(t("CSS snippet template")).setDesc(
    t("Set default CSS styling as a template for new CSS files you choose to create.")
  );
  const stylingTemplateContent = new import_obsidian13.TextAreaComponent(
    stylingTemplateSetting.controlEl
  );
  setAttributes(stylingTemplateContent.inputEl, {
    style: "margin-top: 12px; width: 100%;  height: 32vh;",
    class: "ms-css-editor"
  });
  stylingTemplateContent.setValue(settings.stylingTemplate).onChange(async (value) => {
    settings.stylingTemplate = value;
    await manager.saveSettings();
  });
}
function renderSnippetsList(containerEl, manager) {
  containerEl.empty();
  const app = manager.app;
  const customCss = app.customCss;
  const currentSnippets = customCss.snippets;
  if (currentSnippets.length === 0) {
    containerEl.createEl("p", { text: t("No CSS snippets found.") });
    return;
  }
  currentSnippets.forEach((snippet) => {
    new import_obsidian13.Setting(containerEl).setName(snippet).addToggle((toggle) => {
      toggle.setValue(customCss.enabledSnippets.has(snippet)).onChange((value) => {
        customCss.setCssEnabledStatus(snippet, value);
      });
    });
  });
  const buttonContainer = containerEl.createDiv();
  buttonContainer.addClass("ms-reload-container");
  new import_obsidian13.Setting(buttonContainer).addButton((button) => button.setButtonText(t("Reload Snippets")).onClick(() => {
    customCss.requestLoadSnippets();
    renderSnippetsList(containerEl, manager);
  }));
}

// src/headings/manager.ts
var import_obsidian19 = require("obsidian");

// src/utils/numbering-tokens.ts
var chineseNumbers = ["\u96F6", "\u4E00", "\u4E8C", "\u4E09", "\u56DB", "\u4E94", "\u516D", "\u4E03", "\u516B", "\u4E5D", "\u5341"];
var circledNumbers = ["\u24EA", "\u2460", "\u2461", "\u2462", "\u2463", "\u2464", "\u2465", "\u2466", "\u2467", "\u2468", "\u2469", "\u246A", "\u246B", "\u246C", "\u246D", "\u246E", "\u246F", "\u2470", "\u2471", "\u2472", "\u2473"];
function firstNumberingTokenInStyle(style, startValue) {
  const startNum = parseInt(startValue);
  const isNumericStart = !isNaN(startNum);
  switch (style) {
    case "1":
      return { style: "1", value: startNum };
    case "A":
      if (isNumericStart) {
        if (startNum === 0)
          return { style: "A", value: "&" };
        if (startNum > 0)
          return { style: "A", value: String.fromCharCode("A".charCodeAt(0) + startNum - 1) };
        return { style: "A", value: "A" };
      }
      return { style: "A", value: startValue || "A" };
    case "a":
      if (isNumericStart) {
        if (startNum === 0)
          return { style: "a", value: "&" };
        if (startNum > 0)
          return { style: "a", value: String.fromCharCode("a".charCodeAt(0) + startNum - 1) };
        return { style: "a", value: "a" };
      }
      return { style: "a", value: startValue || "a" };
    case "\u4E00":
      if (isNumericStart) {
        if (startNum >= 0 && startNum < chineseNumbers.length) {
          return { style: "\u4E00", value: chineseNumbers[startNum] };
        }
        if (startNum >= chineseNumbers.length) {
          return { style: "\u4E00", value: String(startNum) };
        }
      }
      return { style: "\u4E00", value: startValue || "\u4E00" };
    case "\u2460":
      if (isNumericStart) {
        if (startNum >= 0 && startNum < circledNumbers.length) {
          return { style: "\u2460", value: circledNumbers[startNum] };
        }
        if (startNum >= circledNumbers.length) {
          return { style: "\u2460", value: String(startNum) };
        }
      }
      return { style: "\u2460", value: startValue || "\u2460" };
  }
  return { style: "1", value: 1 };
}
function nextNumberingToken(t2) {
  switch (t2.style) {
    case "1":
      return { style: "1", value: t2.value + 1 };
    case "A":
      if (t2.value === "&")
        return { style: "A", value: "A" };
      if (t2.value === "Z")
        return { style: "A", value: "A" };
      return { style: "A", value: String.fromCharCode(t2.value.charCodeAt(0) + 1) };
    case "a":
      if (t2.value === "&")
        return { style: "a", value: "a" };
      if (t2.value === "z")
        return { style: "a", value: "a" };
      return { style: "a", value: String.fromCharCode(t2.value.charCodeAt(0) + 1) };
    case "\u4E00":
      const cnIndex = chineseNumbers.indexOf(t2.value);
      if (cnIndex > -1 && cnIndex < chineseNumbers.length - 1) {
        return { style: "\u4E00", value: chineseNumbers[cnIndex + 1] };
      }
      if (cnIndex === chineseNumbers.length - 1)
        return { style: "\u4E00", value: "11" };
      const cnNum = parseInt(t2.value);
      if (!isNaN(cnNum))
        return { style: "\u4E00", value: String(cnNum + 1) };
      return { style: "\u4E00", value: "\u4E00" };
    case "\u2460":
      const cIndex = circledNumbers.indexOf(t2.value);
      if (cIndex > -1 && cIndex < circledNumbers.length - 1) {
        return { style: "\u2460", value: circledNumbers[cIndex + 1] };
      }
      if (cIndex === circledNumbers.length - 1)
        return { style: "\u2460", value: "21" };
      const cNum = parseInt(t2.value);
      if (!isNaN(cNum))
        return { style: "\u2460", value: String(cNum + 1) };
      return { style: "\u2460", value: "\u2460" };
  }
  return { style: "1", value: t2.value + 1 };
}
function printableNumberingToken(t2) {
  if (t2.style === "1")
    return t2.value.toString();
  return t2.value;
}
function makeNumberingString(numberingStack, separators) {
  let numberingString = "";
  for (let i = 0; i < numberingStack.length; i++) {
    if (i === 0) {
      numberingString += " ";
    } else {
      numberingString += separators[i] || "";
    }
    numberingString += printableNumberingToken(numberingStack[i]);
  }
  return numberingString;
}

// src/utils/text-processing.ts
function getRegexForHeaderString(flags) {
  return /^\s{0,3}#+( )?([0-9a-zA-Z\u4e00-\u9fa5\u2460-\u2473&]+[.:\-]+( )?)*([0-9a-zA-Z\u4e00-\u9fa5\u2460-\u2473&]+)?( )?[.:\-]?( )+/g;
}
function findRangeInHeaderString(lineText, lineNumber) {
  const regex = getRegexForHeaderString();
  if (!lineText)
    return void 0;
  const matches = lineText.match(regex);
  if (matches && matches.length !== 1) {
    return void 0;
  }
  const match = matches ? matches[0] : "";
  return {
    from: { line: lineNumber, ch: 0 },
    to: { line: lineNumber, ch: match.length }
  };
}
function findHeadingPrefixRange(editor, heading) {
  const lineNumber = heading.position.start.line;
  const lineText = editor.getLine(lineNumber);
  return findRangeInHeaderString(lineText, lineNumber);
}
function makeHeadingHashString(editor, heading) {
  const regex = /^\s{0,4}#+/g;
  const headingLineString = editor.getLine(heading.position.start.line);
  if (!headingLineString)
    return void 0;
  const matches = headingLineString.match(regex);
  if (!matches || matches.length !== 1)
    return void 0;
  return matches[0].trimLeft();
}
function replaceRangeEconomically(editor, changes, range, text) {
  const previousText = editor.getRange(range.from, range.to);
  if (previousText !== text) {
    changes.push({
      from: range.from,
      to: range.to,
      text
    });
  }
}
function restoreCursor(editor, cursor) {
  const lineCount = editor.lineCount();
  if (cursor.line < lineCount) {
    const lineLength = editor.getLine(cursor.line).length;
    if (cursor.ch <= lineLength) {
      editor.setCursor(cursor);
    } else {
      editor.setCursor(cursor.line, lineLength);
    }
  }
}
function getCodeBlockRanges(data) {
  if (!data || !data.sections)
    return [];
  return data.sections.filter((section) => section.type === "code").map((section) => ({
    start: section.position.start.line,
    end: section.position.end.line
  }));
}
function isLineIgnored(lineNum, lineText, codeRanges) {
  for (const range of codeRanges) {
    if (lineNum >= range.start && lineNum <= range.end)
      return true;
  }
  if (/^\s*\|/.test(lineText))
    return true;
  return false;
}

// src/utils/frontmatter.ts
var import_obsidian14 = require("obsidian");
function parseHeadingsFrontMatter(fm, defaultSettings) {
  const settings = Object.assign({}, defaultSettings);
  if (!fm)
    return settings;
  const entry = (0, import_obsidian14.parseFrontMatterEntry)(fm, "number headings");
  if (entry) {
    const parts = String(entry).split(",").map((p) => p.trim()).filter((p) => p.length > 0);
    const rangeRegex = /^\d-\d$/;
    const stylesRegex = /^[0-9a-zA-Z\u4e00-\u9fa5\u2460-\u2473&]{6}$/;
    const startValuesRegex = /^\d{6}$/;
    const separatorsRegex = /^[-:.]{5}$/;
    let rangeFound = false;
    let stylesFound = false;
    let separatorsFound = false;
    let startValuesFound = false;
    for (const part of parts) {
      if (part === "auto")
        settings.auto = true;
      else if (part === "off")
        settings.enabled = false;
      else if (part.startsWith("first-level")) {
        const n = parseInt(part.substring("first-level".length + 1));
        if (!isNaN(n) && n >= 1 && n <= 6)
          settings.firstLevel = n;
      } else if (part.startsWith("max")) {
        const n = parseInt(part.substring("max".length + 1));
        if (!isNaN(n) && n >= 1 && n <= 6)
          settings.maxLevel = n;
      } else if (!rangeFound && rangeRegex.test(part)) {
        const [min, max] = part.split("-").map(Number);
        if (!isNaN(min) && !isNaN(max)) {
          settings.firstLevel = min;
          settings.maxLevel = max;
          rangeFound = true;
        }
      } else if (!stylesFound && stylesRegex.test(part)) {
        settings.headingStyles = part.split("");
        stylesFound = true;
      } else if (!startValuesFound && startValuesRegex.test(part)) {
        settings.headingStartValues = part.split("");
        startValuesFound = true;
      } else if (!separatorsFound && separatorsRegex.test(part)) {
        const seps = part.split("");
        settings.headingSeparators = ["", seps[0], seps[1], seps[2], seps[3], seps[4]];
        separatorsFound = true;
      } else if (part.startsWith("skip")) {
      }
    }
  }
  return settings;
}
function serializeHeadingsFrontMatter(settings) {
  if (!settings.enabled)
    return "off";
  const parts = [];
  if (settings.auto)
    parts.push("auto");
  if (settings.firstLevel !== 1 || settings.maxLevel !== 6) {
    parts.push(`${settings.firstLevel}-${settings.maxLevel}`);
  } else {
    parts.push("1-6");
  }
  if (settings.headingStyles && settings.headingStyles.length >= 6) {
    parts.push(settings.headingStyles.join(""));
  } else {
    parts.push("1aA\u4E00\u24601");
  }
  if (settings.headingSeparators && settings.headingSeparators.length >= 6) {
    parts.push(settings.headingSeparators.slice(1, 6).join(""));
  } else {
    parts.push(DEFAULT_MY_HEADINGS_SETTINGS.headingSeparators.slice(1, 6).join(""));
  }
  if (settings.headingStartValues && settings.headingStartValues.length >= 6) {
    parts.push(settings.headingStartValues.join(""));
  } else {
    parts.push("011111");
  }
  return parts.join(", ");
}
function parseFormulasFrontMatter(fm, defaultSettings) {
  const settings = Object.assign({}, defaultSettings);
  if (!fm)
    return settings;
  const entry = (0, import_obsidian14.parseFrontMatterEntry)(fm, "number formulas");
  if (entry) {
    const parts = String(entry).split(",").map((p) => p.trim());
    for (const part of parts) {
      if (part === "auto")
        settings.auto = true;
      else if (part === "off")
        settings.enabled = false;
      else if (part === "continuous")
        settings.mode = "continuous";
      else if (part.startsWith("heading-based")) {
        settings.mode = "heading-based";
        const match = part.match(/heading-based\((\d+)\)/);
        if (match && match[1]) {
          const depth = parseInt(match[1]);
          if (!isNaN(depth) && depth >= 1 && depth <= 6) {
            settings.maxDepth = depth;
          }
        }
      }
    }
  }
  return settings;
}
function serializeFormulasFrontMatter(settings) {
  if (!settings.enabled)
    return "off";
  const parts = [];
  if (settings.auto)
    parts.push("auto");
  if (settings.mode === "heading-based") {
    const depth = settings.maxDepth || 4;
    parts.push(`heading-based(${depth})`);
  } else {
    parts.push("continuous");
  }
  return parts.join(", ");
}
async function saveSettingsToFrontMatter(app, file, headingsSettings, formulasSettings) {
  await app.fileManager.processFrontMatter(file, (fm) => {
    if (headingsSettings) {
      fm["number headings"] = serializeHeadingsFrontMatter(headingsSettings);
    }
    if (formulasSettings) {
      fm["number formulas"] = serializeFormulasFrontMatter(formulasSettings);
    }
  });
}

// src/headings/modal.ts
var import_obsidian15 = require("obsidian");
var HeadingsControlModal = class extends import_obsidian15.Modal {
  constructor(app, plugin, file) {
    super(app);
    this.plugin = plugin;
    this.file = file;
    const cache = app.metadataCache.getFileCache(file);
    const fm = cache ? cache.frontmatter : void 0;
    this.settings = JSON.parse(JSON.stringify(parseHeadingsFrontMatter(fm, this.plugin.settings.myHeadings)));
  }
  onOpen() {
    var _a, _b, _c;
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: t("Configure Headings") });
    new import_obsidian15.Setting(contentEl).setName(t("Auto Number Headings")).setDesc(t("Automatically number headings on blur")).addToggle((toggle) => toggle.setValue(this.settings.auto).onChange((v) => this.settings.auto = v));
    new import_obsidian15.Setting(contentEl).setName(t("First Level")).setDesc(t("Starting heading level for numbering")).addSlider((slider) => slider.setLimits(1, 6, 1).setValue(this.settings.firstLevel).setDynamicTooltip().onChange((v) => this.settings.firstLevel = v));
    new import_obsidian15.Setting(contentEl).setName(t("Max Level")).setDesc(t("Maximum heading level for numbering")).addSlider((slider) => slider.setLimits(1, 6, 1).setValue(this.settings.maxLevel).setDynamicTooltip().onChange((v) => this.settings.maxLevel = v));
    const stylesSetting = new import_obsidian15.Setting(contentEl).setName(t("Heading Styles")).setDesc(t("Numbering style for each level (1-6)")).setClass("heading-styles-setting");
    const stylesContainer = createDiv({ cls: "heading-styles-container" });
    stylesSetting.settingEl.appendChild(stylesContainer);
    const styleOptions = ["1", "a", "A", "\u4E00", "\u2460"];
    for (let i = 0; i < 6; i++) {
      const wrapper = stylesContainer.createDiv({ cls: "style-item" });
      wrapper.createEl("label", { text: `H${i + 1}: ` });
      const select = wrapper.createEl("select");
      styleOptions.forEach((option) => {
        select.createEl("option", { text: option, value: option });
      });
      select.value = ((_a = this.settings.headingStyles) == null ? void 0 : _a[i]) || DEFAULT_HEADING_STYLES[i];
      select.onchange = () => {
        if (!this.settings.headingStyles)
          this.settings.headingStyles = [...DEFAULT_HEADING_STYLES];
        this.settings.headingStyles[i] = select.value;
      };
    }
    const separatorsSetting = new import_obsidian15.Setting(contentEl).setName(t("Heading Separators")).setDesc(t("Separator after each level (empty for H1, then 2-6)")).setClass("heading-separators-setting");
    const separatorsContainer = createDiv({ cls: "heading-separators-container" });
    separatorsSetting.settingEl.appendChild(separatorsContainer);
    for (let i = 1; i < 6; i++) {
      const wrapper = separatorsContainer.createDiv({ cls: "separator-item" });
      wrapper.createEl("label", { text: `H${i + 1}: ` });
      const input = wrapper.createEl("input", { type: "text" });
      input.value = ((_b = this.settings.headingSeparators) == null ? void 0 : _b[i]) || DEFAULT_HEADING_SEPARATORS[i];
      input.maxLength = 1;
      input.style.width = "2em";
      input.oninput = () => {
        if (!this.settings.headingSeparators)
          this.settings.headingSeparators = [...DEFAULT_HEADING_SEPARATORS];
        this.settings.headingSeparators[i] = input.value || "";
      };
    }
    const startValuesSetting = new import_obsidian15.Setting(contentEl).setName(t("Start Values")).setDesc(t("Starting number for each level")).setClass("heading-start-values-setting");
    const startValuesContainer = createDiv({ cls: "heading-start-values-container" });
    startValuesSetting.settingEl.appendChild(startValuesContainer);
    for (let i = 0; i < 6; i++) {
      const wrapper = startValuesContainer.createDiv({ cls: "start-value-item" });
      wrapper.createEl("label", { text: `H${i + 1}: ` });
      const input = wrapper.createEl("input", { type: "text" });
      input.value = ((_c = this.settings.headingStartValues) == null ? void 0 : _c[i]) || DEFAULT_HEADING_START_VALUES[i];
      input.maxLength = 1;
      input.style.width = "2em";
      input.oninput = () => {
        if (!this.settings.headingStartValues)
          this.settings.headingStartValues = [...DEFAULT_HEADING_START_VALUES];
        this.settings.headingStartValues[i] = input.value || "1";
      };
    }
    const buttonContainer = contentEl.createDiv({ cls: "modal-button-container" });
    new import_obsidian15.Setting(buttonContainer).addButton((btn) => btn.setButtonText(t("Apply Now")).setTooltip(t("Apply numbering once without saving to frontmatter")).onClick(() => {
      this.applyNumbering();
      this.close();
    })).addButton((btn) => btn.setButtonText(t("Save to Frontmatter")).setTooltip(t("Save settings to frontmatter and apply")).setCta().onClick(async () => {
      await this.saveAndApply();
      this.close();
    })).addButton((btn) => btn.setButtonText(t("Remove Numbering")).setWarning().onClick(() => {
      this.plugin.headingsManager.removeNumbering();
      new import_obsidian15.Notice(t("Heading numbering removed"));
      this.close();
    }));
  }
  applyNumbering() {
    const info = this.plugin.headingsManager.getActiveViewInfo();
    if (!info)
      return;
    const { data, editor } = info;
    const originalSettings = this.plugin.settings.myHeadings;
    this.plugin.settings.myHeadings = this.settings;
    this.plugin.headingsManager.updateNumbering(true, true);
    this.plugin.settings.myHeadings = originalSettings;
    new import_obsidian15.Notice(t("Numbering applied (one-time)"));
  }
  async saveAndApply() {
    await saveSettingsToFrontMatter(this.app, this.file, this.settings);
    await new Promise((resolve) => setTimeout(resolve, 100));
    this.plugin.headingsManager.updateNumbering(true, true);
    new import_obsidian15.Notice(t("Settings saved to frontmatter and applied"));
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/headings/shifter/manager.ts
var import_obsidian18 = require("obsidian");
var import_state = require("@codemirror/state");
var import_view = require("@codemirror/view");

// src/headings/shifter/features/shift.ts
var import_obsidian16 = require("obsidian");

// src/headings/shifter/utils/constants.ts
var TABSIZE = 4;

// src/headings/shifter/utils/range.ts
var setMin = (prev, cur) => {
  if (prev === void 0 || prev !== void 0 && cur < prev) {
    return cur;
  }
  return prev;
};
var setMax = (prev, cur) => {
  if (prev === void 0 || prev !== void 0 && cur > prev) {
    return cur;
  }
  return prev;
};
var createRange = (start, num) => Array.from(Array(num), (v, k) => k + start);

// src/headings/shifter/utils/markdown.ts
var checkHeading = (content) => {
  const match = content.match(/^(#+) /);
  if (!match || !match[1])
    return 0;
  return match[1].length;
};
var checkFence = (content) => {
  const backticks = content.match(/^(`{3,})/);
  if (backticks == null ? void 0 : backticks[1])
    return { fenceType: "`", fenceNum: backticks[1].length };
  const tildes = content.match(/^(~{3,})/);
  if (tildes == null ? void 0 : tildes[1])
    return { fenceType: "~", fenceNum: tildes[1].length };
  return null;
};
var getFenceStatus = (prev, current) => {
  if (!current)
    return prev;
  if (!prev)
    return current;
  if (current.fenceType === prev.fenceType && current.fenceNum >= prev.fenceNum) {
    return null;
  }
  return prev;
};
var getHeadingLines = (editor, from, to, options) => {
  const headingLines = [];
  let minHeading;
  let maxHeading;
  let fence = null;
  for (let line = Math.min(from, to); line <= Math.max(from, to); line++) {
    fence = getFenceStatus(fence, checkFence(editor.getLine(line)));
    if (fence)
      continue;
    const heading = checkHeading(editor.getLine(line));
    if ((options == null ? void 0 : options.includesNoHeadingsLine) || heading > 0) {
      headingLines.push(line);
      minHeading = setMin(minHeading, heading);
      maxHeading = setMax(maxHeading, heading);
    }
  }
  return { headingLines, minHeading, maxHeading };
};
var getPreviousHeading = (editor, from) => {
  let fence = null;
  const start = from > 0 ? from - 1 : 0;
  for (let line = start; line >= 0; line--) {
    fence = getFenceStatus(fence, checkFence(editor.getLine(line)));
    if (fence)
      continue;
    if (checkHeading(editor.getLine(line)) > 0) {
      return line;
    }
  }
  return void 0;
};
var replaceFunc = (str, regExp) => {
  try {
    const replaced = str.replace(regExp, "$1");
    if (replaced !== str) {
      return replaced;
    }
  } catch (error) {
    console.error(error);
  }
  return void 0;
};
var removeUsingRegexpStrings = (str, regExpStrings) => {
  var _a, _b;
  let removed = str;
  for (const regExpStr of (_a = regExpStrings.beginning) != null ? _a : []) {
    const regExp = new RegExp(`^\\s*${regExpStr}(.*)`);
    const result = replaceFunc(removed, regExp);
    if (result !== void 0) {
      removed = result;
      break;
    }
  }
  for (const regExpStr of (_b = regExpStrings.surrounding) != null ? _b : []) {
    const regExp = new RegExp(`${regExpStr}(.*)${regExpStr}`);
    const result = replaceFunc(removed, regExp);
    if (result !== void 0) {
      removed = result;
      break;
    }
  }
  return removed;
};
var countIndentLevel = (line, tabSize = TABSIZE) => {
  var _a;
  const leadingContent = (_a = line.match(/^(\s*)/)) == null ? void 0 : _a[0];
  if (!leadingContent)
    return 0;
  const tabCount = (leadingContent.match(/\t/g) || []).length;
  const spaceCount = (leadingContent.match(/ /g) || []).length;
  return tabCount + Math.floor(spaceCount / tabSize);
};
var getListChildrenLines = (editor, {
  parentLineNumber,
  tabSize
}) => {
  const lineNumbers = [];
  const startLine = editor.getLine(parentLineNumber);
  const prevParentIndentLevel = countIndentLevel(startLine, tabSize);
  for (let lineN = parentLineNumber + 1; lineN < editor.lineCount(); lineN++) {
    const line = editor.getLine(lineN);
    const indentLevel = countIndentLevel(line, tabSize);
    const isBulleted = /^\s*[-*]\s+/.test(line);
    const isNumbered = /^\s*\d+\.\s+/.test(line);
    if (!isBulleted && !isNumbered)
      break;
    if (indentLevel <= prevParentIndentLevel)
      break;
    lineNumbers.push(lineN);
  }
  return lineNumbers;
};

// src/headings/shifter/utils/editorChange.ts
var composeLineChanges = (editor, lineNumbers, changeCallback, settings) => {
  const editorChange = [];
  for (const line of lineNumbers) {
    const shifted = changeCallback(editor.getLine(line), settings);
    editorChange.push({
      text: shifted,
      from: { line, ch: 0 },
      to: {
        line,
        ch: editor.getLine(line).length
      }
    });
  }
  return editorChange;
};
var createListIndentChanges = (editor, {
  parentLineNumber,
  parentIndentLevel,
  tabSize = TABSIZE
}) => {
  const parentLine = editor.getLine(parentLineNumber);
  const prevParentIndentLevel = countIndentLevel(parentLine, tabSize);
  const childrenNumbers = getListChildrenLines(editor, {
    parentLineNumber,
    tabSize
  });
  const indentDelta = parentIndentLevel - prevParentIndentLevel;
  const changes = [];
  childrenNumbers.forEach((lineNumber) => {
    var _a, _b, _c, _d;
    const line = editor.getLine(lineNumber);
    const newIndentLevel = Math.max(
      countIndentLevel(line, tabSize) + indentDelta,
      0
    );
    const match = line.match(
      /^(?<whitespace>\s*)(?<bullet>[-*]\s*|(?<numbered>\d+\.\s*))(?<heading>#+\s*)?(?<content>.*)$/
    );
    const tabsMarkers = "	".repeat(newIndentLevel);
    const bulletMarkers = ((_a = match == null ? void 0 : match.groups) == null ? void 0 : _a.bullet) || "";
    const numberedMarkers = ((_b = match == null ? void 0 : match.groups) == null ? void 0 : _b.numbered) || "";
    const listMarker = bulletMarkers || numberedMarkers;
    const headingMarkers = ((_c = match == null ? void 0 : match.groups) == null ? void 0 : _c.heading) ? "#".repeat(Math.min(newIndentLevel + 1, 6)) + " " : "";
    const content = ((_d = match == null ? void 0 : match.groups) == null ? void 0 : _d.content) || "";
    const newLine = `${tabsMarkers}${listMarker}${headingMarkers}${content}`;
    changes.push({
      text: newLine,
      from: { line: lineNumber, ch: 0 },
      to: { line: lineNumber, ch: line.length }
    });
  });
  return changes;
};

// src/headings/shifter/utils/regExp.ts
var RegExpExample = {
  beginning: {
    ol: String.raw`\d+\. `,
    ul: String.raw`(?:\-|\*) `
  },
  surrounding: {
    // Only one match
    italic: String.raw`(?:(?<!\*)\*(?!\*)|(?<!_)_(?!_))`,
    // Same
    // bold: String.raw`(?:\*\*|__)`,
    bold: String.raw`(?:(?<!\*)\*\*(?!\*)|(?<!_)__(?!_))`
  }
};

// src/headings/shifter/features/apply.ts
var applyHeading = (chunk, headingSize, settings) => {
  var _a;
  const extractRegExp = (settingObj, regExpObj) => {
    return Object.entries(settingObj != null ? settingObj : {}).flatMap(([k, v]) => {
      var _a2;
      if (Array.isArray(v)) {
        return v;
      }
      if (k in regExpObj && v === true) {
        return [(_a2 = regExpObj[k]) != null ? _a2 : []];
      }
      return [];
    });
  };
  const bulletRegExp = /\s*(- \[.+\]|-|\*|[0-9]+)\s+/;
  const headingRegExp = /#+\s+/;
  const isBullet = ((_a = settings == null ? void 0 : settings.list) == null ? void 0 : _a.childrenBehavior) === "sync with headings" && bulletRegExp.test(chunk);
  let removed = chunk;
  if (!checkHeading(chunk)) {
    removed = (settings == null ? void 0 : settings.styleToRemove) ? removeUsingRegexpStrings(chunk, {
      beginning: extractRegExp(
        {
          ...settings.styleToRemove.beginning,
          ul: !isBullet && settings.styleToRemove.beginning.ul
        },
        RegExpExample.beginning
      ),
      surrounding: extractRegExp(
        settings.styleToRemove.surrounding,
        RegExpExample.surrounding
      )
    }) : chunk;
  }
  const leadingMarkersRegExp = isBullet ? new RegExp(
    `^(?:${bulletRegExp.source}${headingRegExp.source}|${bulletRegExp.source})`
  ) : new RegExp(`^${headingRegExp.source}`);
  let capturedBullet = "-";
  const principleText = removed.replace(leadingMarkersRegExp, (match, p1) => {
    if (isBullet && p1) {
      capturedBullet = p1;
      const m = match.match(bulletRegExp);
      if (m && m[1])
        capturedBullet = m[1];
    }
    return "";
  });
  const bulletMarkers = `${"	".repeat(Math.max(headingSize - 1, 0))}${capturedBullet} `;
  const headingMarkers = "#".repeat(Math.max(headingSize, 0)) + (headingSize > 0 ? " " : "");
  const leadingMarkers = isBullet ? `${bulletMarkers}${headingMarkers}` : headingMarkers;
  return leadingMarkers + principleText;
};
var createListIndentChangesByListBehavior = (editor, {
  listBehavior,
  tabSize = TABSIZE,
  parentIndentLevel,
  parentLineNumber
}) => {
  if (listBehavior !== "outdent to zero" && listBehavior !== "sync with headings") {
    return [];
  }
  const parentIndentLevelByBehavior = listBehavior === "sync with headings" ? (
    // follow parent
    Math.max(0, parentIndentLevel)
  ) : (
    // Force the next line of parent to be 0
    -countIndentLevel(editor.getLine(parentLineNumber + 1), tabSize) + countIndentLevel(editor.getLine(parentLineNumber), tabSize)
  );
  const indentChanges = createListIndentChanges(editor, {
    parentLineNumber,
    parentIndentLevel: parentIndentLevelByBehavior,
    tabSize
  });
  return indentChanges;
};
var ApplyHeading = class {
  constructor(settings, headingSize) {
    this.editorCallback = (editor) => {
      var _a;
      const lines = createRange(
        editor.getCursor("from").line,
        editor.getCursor("to").line - editor.getCursor("from").line + 1
      );
      const isOneLine = editor.getCursor("from").line === editor.getCursor("to").line;
      const lastHeaderLineNumber = (_a = lines[lines.length - 1]) != null ? _a : 0;
      const headingsChanges = composeLineChanges(
        editor,
        lines,
        (chunk) => applyHeading(chunk, this.headingSize, this.settings)
      );
      const indentChanges = createListIndentChangesByListBehavior(editor, {
        parentIndentLevel: this.headingSize - 1,
        tabSize: this.settings.editor.tabSize,
        listBehavior: this.settings.list.childrenBehavior,
        parentLineNumber: lastHeaderLineNumber
      });
      editor.transaction({
        changes: [...headingsChanges, ...indentChanges]
      });
      if (isOneLine) {
        editor.setCursor(editor.getCursor("anchor").line);
      }
      return true;
    };
    this.createCommand = () => {
      return {
        id: `apply-heading-${this.headingSize}`,
        name: `${t("Apply Heading")} ${this.headingSize}`,
        icon: `headingShifter_heading${this.headingSize}`,
        editorCallback: this.editorCallback
      };
    };
    this.settings = settings;
    this.headingSize = headingSize;
  }
};

// src/headings/shifter/features/shift.ts
var shiftHeading = (chunk, dir, settings) => {
  const heading = checkHeading(chunk);
  return applyHeading(chunk, heading + dir, settings);
};
var increaseHeading = (chunk, settings) => {
  return shiftHeading(chunk, 1, settings);
};
var decreaseHeading = (chunk, settings) => {
  return shiftHeading(chunk, -1, settings);
};
var IncreaseHeading = class {
  constructor(settings, includesNoHeadingsLine) {
    this.editorCallback = (editor) => {
      const { headingLines, maxHeading } = getHeadingLines(
        editor,
        editor.getCursor("from").line,
        editor.getCursor("to").line,
        {
          includesNoHeadingsLine: this.includesNoHeadingsLine
        }
      );
      if (maxHeading !== void 0 && maxHeading >= 6) {
        new import_obsidian16.Notice("Cannot Increase (contains more than Heading 6)");
        return true;
      }
      const isOneLine = editor.getCursor("from").line === editor.getCursor("to").line;
      const editorChange = composeLineChanges(
        editor,
        headingLines,
        increaseHeading,
        this.settings
      );
      editor.transaction({
        changes: editorChange
      });
      if (isOneLine) {
        editor.setCursor(editor.getCursor("anchor").line);
      }
      return editorChange.length ? true : false;
    };
    this.createCommand = () => {
      return {
        id: `increase-heading${this.includesNoHeadingsLine ? "-forced" : ""}`,
        name: this.includesNoHeadingsLine ? t("Increase Headings (forced)") : t("Increase Headings"),
        icon: "headingShifter_increaseIcon",
        // Should check if icon exists or use default
        editorCallback: this.editorCallback
      };
    };
    this.check = (editor) => {
      const { maxHeading } = getHeadingLines(
        editor,
        editor.getCursor("from").line,
        editor.getCursor("to").line
      );
      if (maxHeading === void 0)
        return false;
      return this.settings.overrideTab;
    };
    this.settings = settings;
    this.includesNoHeadingsLine = includesNoHeadingsLine;
  }
};
var DecreaseHeading = class {
  constructor(settings) {
    this.editorCallback = (editor) => {
      const { headingLines, minHeading } = getHeadingLines(
        editor,
        editor.getCursor("from").line,
        editor.getCursor("to").line
      );
      if (minHeading !== void 0 && minHeading <= Number(this.settings.limitHeadingFrom)) {
        new import_obsidian16.Notice(
          `Cannot Decrease (contains less than Heading${Number(
            this.settings.limitHeadingFrom
          )})`
        );
        return true;
      }
      const isOneLine = editor.getCursor("from").line === editor.getCursor("to").line;
      const editorChange = composeLineChanges(
        editor,
        headingLines,
        decreaseHeading,
        this.settings
      );
      editor.transaction({
        changes: editorChange
      });
      if (isOneLine) {
        editor.setCursor(editor.getCursor("anchor").line);
      }
      return editorChange.length ? true : false;
    };
    this.createCommand = () => {
      return {
        id: "decrease-heading",
        name: t("Decrease Headings"),
        icon: "headingShifter_decreaseIcon",
        editorCallback: this.editorCallback
      };
    };
    this.check = (editor) => {
      const { maxHeading } = getHeadingLines(
        editor,
        editor.getCursor("from").line,
        editor.getCursor("to").line
      );
      if (maxHeading === void 0)
        return false;
      return this.settings.overrideTab;
    };
    this.settings = settings;
  }
};

// src/headings/shifter/features/insert.ts
var import_obsidian17 = require("obsidian");
var InsertHeadingAtCurrentLevel = class {
  constructor(settings) {
    this.editorCallback = (editor) => {
      const cursorLine = editor.getCursor("from").line;
      const lastHeadingLine = getPreviousHeading(editor, cursorLine);
      const headingLevel = lastHeadingLine !== void 0 ? checkHeading(editor.getLine(lastHeadingLine)) : 0;
      const targetHeadingLevel = headingLevel;
      const headingChanges = composeLineChanges(
        editor,
        [cursorLine],
        (chunk) => applyHeading(chunk, targetHeadingLevel, this.settings)
      );
      const indentChanges = createListIndentChangesByListBehavior(editor, {
        parentIndentLevel: targetHeadingLevel - 1,
        tabSize: this.settings.editor.tabSize,
        listBehavior: this.settings.list.childrenBehavior,
        parentLineNumber: cursorLine
      });
      editor.transaction({
        changes: [...headingChanges, ...indentChanges]
      });
      editor.setCursor(editor.getCursor().line);
      return true;
    };
    this.createCommand = () => {
      return {
        id: `insert-heading-current`,
        name: t("Insert Heading at current level"),
        icon: `headingShifter_heading`,
        editorCallback: this.editorCallback
      };
    };
    this.settings = settings;
  }
};
var InsertHeadingAtDeeperLevel = class {
  constructor(settings) {
    this.editorCallback = (editor) => {
      const cursorLine = editor.getCursor("from").line;
      const lastHeadingLine = getPreviousHeading(editor, cursorLine);
      const headingLevel = lastHeadingLine ? checkHeading(editor.getLine(lastHeadingLine)) : 0;
      if (headingLevel + 1 > 6) {
        new import_obsidian17.Notice("Cannot Increase (contains more than Heading 6)");
        return true;
      }
      const targetHeadingLevel = headingLevel + 1;
      const headingChanges = composeLineChanges(
        editor,
        [cursorLine],
        (chunk) => applyHeading(chunk, targetHeadingLevel, this.settings)
      );
      const indentChanges = createListIndentChangesByListBehavior(editor, {
        parentIndentLevel: targetHeadingLevel - 1,
        tabSize: this.settings.editor.tabSize,
        listBehavior: this.settings.list.childrenBehavior,
        parentLineNumber: cursorLine
      });
      editor.transaction({
        changes: [...headingChanges, ...indentChanges]
      });
      editor.setCursor(editor.getCursor().line);
      return true;
    };
    this.createCommand = () => {
      return {
        id: `insert-heading-deeper`,
        name: t("Insert Heading at one level deeper"),
        icon: `headingShifter_heading`,
        editorCallback: this.editorCallback
      };
    };
    this.settings = settings;
  }
};
var InsertHeadingAtHigherLevel = class {
  constructor(settings) {
    this.editorCallback = (editor) => {
      const cursorLine = editor.getCursor("from").line;
      const lastHeadingLine = getPreviousHeading(editor, cursorLine);
      const headingLevel = lastHeadingLine ? checkHeading(editor.getLine(lastHeadingLine)) : 0;
      const targetHeadingLevel = headingLevel - 1;
      const headingChanges = composeLineChanges(
        editor,
        [cursorLine],
        (chunk) => applyHeading(chunk, targetHeadingLevel, this.settings)
      );
      const indentChanges = createListIndentChangesByListBehavior(editor, {
        parentIndentLevel: targetHeadingLevel,
        tabSize: this.settings.editor.tabSize,
        listBehavior: this.settings.list.childrenBehavior,
        parentLineNumber: cursorLine
      });
      editor.transaction({
        changes: [...headingChanges, ...indentChanges]
      });
      editor.setCursor(editor.getCursor().line);
      return true;
    };
    this.createCommand = () => {
      return {
        id: `insert-heading-higher`,
        name: t("Insert Heading at one level higher"),
        icon: `headingShifter_heading`,
        editorCallback: this.editorCallback
      };
    };
    this.settings = settings;
  }
};

// src/headings/shifter/manager.ts
var HEADINGS = [0, 1, 2, 3, 4, 5, 6];
var ShifterManager = class {
  constructor(app, plugin) {
    this.app = app;
    this.plugin = plugin;
  }
  onload() {
    this.addCommands();
  }
  addCommands() {
    const settings = this.plugin.settings.myHeadings;
    const increaseHeading2 = new IncreaseHeading(settings, false);
    const increaseHeadingForced = new IncreaseHeading(settings, true);
    const decreaseHeading2 = new DecreaseHeading(settings);
    const insertHeadingAtCurrentLabel = new InsertHeadingAtCurrentLevel(settings);
    const insertHeadingAtDeeperLevel = new InsertHeadingAtDeeperLevel(settings);
    const insertHeadingAtHigherLevel = new InsertHeadingAtHigherLevel(settings);
    HEADINGS.forEach((heading) => {
      const applyHeadingCmd = new ApplyHeading(settings, heading);
      this.plugin.addCommand({
        ...applyHeadingCmd.createCommand(),
        id: `heading-shifter-${applyHeadingCmd.createCommand().id}`
        // Prefix to avoid conflict? Or use as derived.
        // The createCommand in classes returned generic IDs e.g. 'increase-heading'.
        // obsidian-assistant will prefix with 'obsidian-assistant:'.
        // I should probably ensure unique IDs within my plugin if I have other heading commands.
        // But previously I removed 'number-headings' command.
        // Let's keep IDs simple: 'increase-heading' -> 'obsidian-assistant:increase-heading'.
      });
    });
    this.plugin.addCommand(increaseHeading2.createCommand());
    this.plugin.addCommand(increaseHeadingForced.createCommand());
    this.plugin.addCommand(decreaseHeading2.createCommand());
    this.plugin.addCommand(insertHeadingAtCurrentLabel.createCommand());
    this.plugin.addCommand(insertHeadingAtDeeperLevel.createCommand());
    this.plugin.addCommand(insertHeadingAtHigherLevel.createCommand());
    this.plugin.registerEditorExtension(
      import_state.Prec.highest(
        import_view.keymap.of([
          {
            key: "Tab",
            run: this.createKeyMapRunCallback({
              check: increaseHeading2.check,
              run: increaseHeading2.editorCallback
            })
          }
        ])
      )
    );
    this.plugin.registerEditorExtension(
      import_state.Prec.highest(
        import_view.keymap.of([
          {
            key: "s-Tab",
            run: this.createKeyMapRunCallback({
              check: decreaseHeading2.check,
              run: decreaseHeading2.editorCallback
            })
          }
        ])
      )
    );
  }
  // Helper from ObsidianService
  getEditorFromState(state) {
    return state.field(import_obsidian18.editorInfoField).editor;
  }
  createKeyMapRunCallback(config) {
    const check = config.check || (() => true);
    const { run } = config;
    return (view) => {
      const editor = this.getEditorFromState(view.state);
      if (!editor) {
        return false;
      }
      if (!check(editor)) {
        return false;
      }
      return run(editor);
    };
  }
};

// src/headings/manager.ts
var DEFAULT_HEADING_STYLES = ["1", "a", "A", "\u4E00", "\u2460", "1"];
var DEFAULT_HEADING_SEPARATORS = ["", "-", ":", ".", "\u2014", "-"];
var DEFAULT_HEADING_START_VALUES = ["0", "1", "1", "1", "1", "1"];
var HeadingsManager = class {
  constructor(app, plugin) {
    this.app = app;
    this.plugin = plugin;
    this.shifterManager = new ShifterManager(app, plugin);
  }
  async onload() {
    this.shifterManager.onload();
    this.plugin.addCommand({
      id: "configure-headings",
      name: t("Configure Headings"),
      callback: () => {
        const activeView = this.app.workspace.getActiveViewOfType(import_obsidian19.MarkdownView);
        if (activeView && activeView.file) {
          new HeadingsControlModal(this.app, this.plugin, activeView.file).open();
        }
      }
    });
  }
  onunload() {
  }
  getActiveViewInfo() {
    const activeView = this.app.workspace.getActiveViewOfType(import_obsidian19.MarkdownView);
    if (activeView && activeView.file) {
      const data = this.app.metadataCache.getFileCache(activeView.file);
      const editor = activeView.editor;
      if (data && editor) {
        return { activeView, data, editor };
      }
    }
    return void 0;
  }
  getEffectiveSettings(fm) {
    return parseHeadingsFrontMatter(fm, this.plugin.settings.myHeadings);
  }
  // Returns true if changes were made
  updateNumbering(force = false, performRestore = true) {
    var _a;
    const info = this.getActiveViewInfo();
    if (!info)
      return false;
    const { data, editor } = info;
    const settings = this.getEffectiveSettings(data.frontmatter);
    if (!settings.enabled && !force)
      return false;
    const cursorBefore = editor.getCursor();
    const scrollBefore = editor.getScrollInfo();
    const headings = (_a = data.headings) != null ? _a : [];
    const codeRanges = getCodeBlockRanges(data);
    const headingStyles = settings.headingStyles || DEFAULT_HEADING_STYLES;
    const headingSeparators = settings.headingSeparators || DEFAULT_HEADING_SEPARATORS;
    const headingStartValues = settings.headingStartValues || DEFAULT_HEADING_START_VALUES;
    let previousLevel = settings.firstLevel - 1;
    let numberingStack = [];
    const changes = [];
    for (const heading of headings) {
      const level = heading.level;
      const lineNum = heading.position.start.line;
      const lineText = editor.getLine(lineNum);
      if (isLineIgnored(lineNum, lineText, codeRanges))
        continue;
      if (settings.firstLevel > level) {
        previousLevel = settings.firstLevel - 1;
        numberingStack = [];
        continue;
      }
      if (settings.skipHeadings && settings.skipHeadings.length > 0) {
        if (heading.heading.endsWith(settings.skipHeadings))
          continue;
      }
      if (level === previousLevel) {
        const x = numberingStack.pop();
        if (x)
          numberingStack.push(nextNumberingToken(x));
      } else if (level < previousLevel) {
        for (let i = previousLevel; i > level; i--)
          numberingStack.pop();
        const x = numberingStack.pop();
        if (x)
          numberingStack.push(nextNumberingToken(x));
      } else if (level > previousLevel) {
        for (let i = previousLevel; i < level; i++) {
          const styleIndex = Math.min(i, headingStyles.length - 1);
          const startVal = headingStartValues[styleIndex] !== void 0 ? headingStartValues[styleIndex] : "1";
          numberingStack.push(firstNumberingTokenInStyle(headingStyles[styleIndex], startVal));
        }
      }
      previousLevel = level;
      if (level > settings.maxLevel)
        continue;
      const prefixRange = findHeadingPrefixRange(editor, heading);
      if (!prefixRange)
        continue;
      const headingHashString = makeHeadingHashString(editor, heading);
      if (!headingHashString)
        continue;
      const prefixString = makeNumberingString(numberingStack, headingSeparators);
      const separator = headingSeparators[0] || "";
      replaceRangeEconomically(editor, changes, prefixRange, headingHashString + prefixString + separator + " ");
    }
    if (changes.length > 0) {
      editor.transaction({ changes });
      if (performRestore) {
        restoreCursor(editor, cursorBefore);
        editor.scrollTo(scrollBefore.left, scrollBefore.top);
      }
      return true;
    }
    return false;
  }
  removeNumbering() {
    var _a;
    const info = this.getActiveViewInfo();
    if (!info)
      return;
    const { data, editor } = info;
    const changes = [];
    const headings = (_a = data.headings) != null ? _a : [];
    for (const heading of headings) {
      const prefixRange = findHeadingPrefixRange(editor, heading);
      if (!prefixRange)
        continue;
      const headingHashString = makeHeadingHashString(editor, heading);
      if (!headingHashString)
        continue;
      replaceRangeEconomically(editor, changes, prefixRange, headingHashString + " ");
    }
    if (changes.length > 0) {
      editor.transaction({ changes });
    }
  }
};

// src/headings/settings-ui.ts
var import_obsidian20 = require("obsidian");
function renderHeadingsSettings(containerEl, manager) {
  const settings = manager.plugin.settings.myHeadings;
  const autoNumberingDetails = containerEl.createEl("details");
  autoNumberingDetails.open = true;
  const autoNumberingSummary = autoNumberingDetails.createEl("summary");
  autoNumberingSummary.setText(t("Auto Numbering"));
  autoNumberingSummary.style.fontSize = "1.2em";
  autoNumberingSummary.style.fontWeight = "bold";
  autoNumberingSummary.style.cursor = "pointer";
  autoNumberingSummary.style.marginBottom = "10px";
  const autoNumberingContent = autoNumberingDetails.createEl("div");
  autoNumberingContent.style.paddingLeft = "10px";
  autoNumberingContent.style.borderLeft = "2px solid var(--background-modifier-border)";
  new import_obsidian20.Setting(autoNumberingContent).setName(t("Auto Number Headings")).setDesc(t("Create numbers automatically on blur")).addToggle((toggle) => toggle.setValue(settings.auto).onChange(async (value) => {
    settings.auto = value;
    await manager.plugin.saveSettings();
  }));
  new import_obsidian20.Setting(autoNumberingContent).setName(t("First Level")).addSlider((slider) => slider.setLimits(1, 6, 1).setValue(settings.firstLevel).setDynamicTooltip().onChange(async (value) => {
    settings.firstLevel = value;
    await manager.plugin.saveSettings();
  }));
  new import_obsidian20.Setting(autoNumberingContent).setName(t("Max Level")).addSlider((slider) => slider.setLimits(1, 6, 1).setValue(settings.maxLevel).setDynamicTooltip().onChange(async (value) => {
    settings.maxLevel = value;
    await manager.plugin.saveSettings();
  }));
  autoNumberingContent.createEl("h3", { text: t("Heading Styles") });
  const stylesContainer = autoNumberingContent.createEl("div");
  stylesContainer.style.display = "grid";
  stylesContainer.style.gridTemplateColumns = "0.5fr 1fr 1fr 1fr";
  stylesContainer.style.gap = "10px";
  stylesContainer.style.marginBottom = "20px";
  stylesContainer.createEl("div", { text: t("Level"), style: "font-weight: bold;" });
  stylesContainer.createEl("div", { text: t("Style"), style: "font-weight: bold;" });
  stylesContainer.createEl("div", { text: t("Separator"), style: "font-weight: bold;" });
  stylesContainer.createEl("div", { text: t("Start At"), style: "font-weight: bold;" });
  const styleOptions = { "1": "1, 2, 3", "a": "a, b, c", "A": "A, B, C", "I": "I, II, III", "\u4E00": "\u4E00, \u4E8C, \u4E09", "\u2460": "\u2460, \u2461, \u2462" };
  const separatorOptions = { "": "None", ".": ".", "-": "-", ":": ":", "\u2014": "\u2014" };
  for (let i = 0; i < 6; i++) {
    stylesContainer.createEl("div", { text: `H${i + 1}`, style: "align-self: center;" });
    const styleSelect = stylesContainer.createEl("select");
    Object.entries(styleOptions).forEach(([key, label]) => {
      styleSelect.createEl("option", { value: key, text: label });
    });
    styleSelect.value = settings.headingStyles[i];
    styleSelect.onchange = async () => {
      settings.headingStyles[i] = styleSelect.value;
      await manager.plugin.saveSettings();
    };
    const sepSelect = stylesContainer.createEl("select");
    Object.entries(separatorOptions).forEach(([key, label]) => {
      sepSelect.createEl("option", { value: key, text: label });
    });
    sepSelect.value = settings.headingSeparators[i];
    sepSelect.onchange = async () => {
      settings.headingSeparators[i] = sepSelect.value;
      await manager.plugin.saveSettings();
    };
    const startInput = stylesContainer.createEl("input", { type: "text" });
    startInput.style.width = "100%";
    startInput.value = settings.headingStartValues[i];
    startInput.onchange = async () => {
      settings.headingStartValues[i] = startInput.value;
      await manager.plugin.saveSettings();
    };
  }
  containerEl.createEl("br");
  const shifterDetails = containerEl.createEl("details");
  shifterDetails.open = false;
  const shifterSummary = shifterDetails.createEl("summary");
  shifterSummary.setText(t("Heading Shifter"));
  shifterSummary.style.fontSize = "1.2em";
  shifterSummary.style.fontWeight = "bold";
  shifterSummary.style.cursor = "pointer";
  shifterSummary.style.marginBottom = "10px";
  const shifterContent = shifterDetails.createEl("div");
  shifterContent.style.paddingLeft = "10px";
  shifterContent.style.borderLeft = "2px solid var(--background-modifier-border)";
  new import_obsidian20.Setting(shifterContent).setName(t("Lower limit of Heading")).setDesc(t("The lower Heading Size that will be decreased by the Heading Shift")).addDropdown((dropdown) => {
    const headingOptions = {};
    [0, 1, 2, 3, 4, 5, 6].forEach((h) => headingOptions[String(h)] = String(h));
    dropdown.addOptions(headingOptions).setValue(String(settings.limitHeadingFrom)).onChange(async (value) => {
      settings.limitHeadingFrom = Number(value);
      await manager.plugin.saveSettings();
    });
  });
  new import_obsidian20.Setting(shifterContent).setName(t("Enable override tab behavior")).setDesc(t('Tab execute "Increase Headings" and Shift-Tab execute "Decrease Headings"')).addToggle(
    (toggle) => toggle.setValue(settings.overrideTab).onChange(async (value) => {
      settings.overrideTab = value;
      await manager.plugin.saveSettings();
    })
  );
  shifterContent.createEl("h3", { text: t("Style to remove") });
  shifterContent.createEl("p", { text: t("If this style is at the position of a line, remove it") });
  shifterContent.createEl("b", { text: t("Beginning") });
  new import_obsidian20.Setting(shifterContent).setName(t("Unordered list")).setDesc("-").addToggle(
    (toggle) => {
      var _a, _b;
      return toggle.setValue((_b = (_a = settings.styleToRemove) == null ? void 0 : _a.beginning) == null ? void 0 : _b.ul).onChange(async (value) => {
        settings.styleToRemove.beginning.ul = value;
        await manager.plugin.saveSettings();
      });
    }
  );
  new import_obsidian20.Setting(shifterContent).setName(t("Ordered list")).setDesc("1., 2. ,3. ,...").addToggle(
    (toggle) => {
      var _a, _b;
      return toggle.setValue((_b = (_a = settings.styleToRemove) == null ? void 0 : _a.beginning) == null ? void 0 : _b.ol).onChange(async (value) => {
        settings.styleToRemove.beginning.ol = value;
        await manager.plugin.saveSettings();
      });
    }
  );
  new import_obsidian20.Setting(shifterContent).setName(t("User defined")).setDesc(t("Arbitrary string (regular expression)")).addTextArea((str) => {
    var _a, _b;
    str.setValue((_b = (_a = settings.styleToRemove.beginning) == null ? void 0 : _a.userDefined) == null ? void 0 : _b.join("\n")).onChange(async (str2) => {
      settings.styleToRemove.beginning.userDefined = str2.split("\n");
      await manager.plugin.saveSettings();
    });
  });
  shifterContent.createEl("b", { text: t("Surrounding") });
  new import_obsidian20.Setting(shifterContent).setName(t("Bold")).setDesc("**|__").addToggle(
    (toggle) => {
      var _a, _b;
      return toggle.setValue((_b = (_a = settings.styleToRemove) == null ? void 0 : _a.surrounding) == null ? void 0 : _b.bold).onChange(async (value) => {
        settings.styleToRemove.surrounding.bold = value;
        await manager.plugin.saveSettings();
      });
    }
  );
  new import_obsidian20.Setting(shifterContent).setName(t("Italic")).setDesc("*|_").addToggle(
    (toggle) => {
      var _a, _b;
      return toggle.setValue((_b = (_a = settings.styleToRemove) == null ? void 0 : _a.surrounding) == null ? void 0 : _b.italic).onChange(async (value) => {
        settings.styleToRemove.surrounding.italic = value;
        await manager.plugin.saveSettings();
      });
    }
  );
  new import_obsidian20.Setting(shifterContent).setName(t("User defined")).setDesc(t("Arbitrary string (regular expression)")).addTextArea((str) => {
    var _a, _b, _c;
    str.setValue((_c = (_b = (_a = settings.styleToRemove) == null ? void 0 : _a.surrounding) == null ? void 0 : _b.userDefined) == null ? void 0 : _c.join("\n")).onChange(async (str2) => {
      settings.styleToRemove.surrounding.userDefined = str2.split("\n");
      await manager.plugin.saveSettings();
    });
  });
  shifterContent.createEl("h3", { text: t("List") });
  new import_obsidian20.Setting(shifterContent).setName(t("Children behavior")).addDropdown((dropdown) => {
    dropdown.addOption("outdent to zero", t("Outdent to 0")).addOption("sync with headings", t("Sync with headings")).addOption("noting", t("Noting")).setValue(settings.list.childrenBehavior).onChange((v) => {
      settings.list.childrenBehavior = v;
      manager.plugin.saveSettings();
    });
  });
  shifterContent.createEl("h3", { text: t("Editor") });
  new import_obsidian20.Setting(shifterContent).setName(t("Tab size")).addSlider((cb) => {
    cb.setDynamicTooltip().setLimits(2, 8, 2).setValue(settings.editor.tabSize).onChange((v) => {
      settings.editor.tabSize = v;
      manager.plugin.saveSettings();
    });
  });
}

// src/formulas/manager.ts
var import_obsidian22 = require("obsidian");

// src/formulas/modal.ts
var import_obsidian21 = require("obsidian");
var FormulasControlModal = class extends import_obsidian21.Modal {
  constructor(app, plugin, file) {
    super(app);
    this.plugin = plugin;
    this.file = file;
    const cache = app.metadataCache.getFileCache(file);
    const fm = cache ? cache.frontmatter : void 0;
    this.settings = JSON.parse(JSON.stringify(parseFormulasFrontMatter(fm, this.plugin.settings.myFormulas)));
  }
  onOpen() {
    this.display();
  }
  display() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: t("Configure Formulas") });
    new import_obsidian21.Setting(contentEl).setName(t("Auto Number Formulas")).setDesc(t("Automatically number formulas on blur")).addToggle((toggle) => toggle.setValue(this.settings.auto).onChange((v) => this.settings.auto = v));
    new import_obsidian21.Setting(contentEl).setName(t("Numbering Mode")).setDesc(t("Continuous: 1,2,3... | Heading-based: 1.1-1, 1.1-2...")).addDropdown((dropdown) => dropdown.addOption("continuous", t("Continuous")).addOption("heading-based", t("Heading-based")).setValue(this.settings.mode).onChange((v) => {
      this.settings.mode = v;
      this.display();
    }));
    if (this.settings.mode === "heading-based") {
      new import_obsidian21.Setting(contentEl).setName(t("Max Heading Depth")).setDesc(t("Maximum heading level to use for formula numbering")).addSlider((slider) => slider.setLimits(1, 6, 1).setValue(this.settings.maxDepth).setDynamicTooltip().onChange((v) => this.settings.maxDepth = v));
    }
    const buttonContainer = contentEl.createDiv({ cls: "modal-button-container" });
    new import_obsidian21.Setting(buttonContainer).addButton((btn) => btn.setButtonText(t("Apply Now")).setTooltip(t("Apply numbering once without saving to frontmatter")).onClick(() => {
      this.applyNumbering();
      this.close();
    })).addButton((btn) => btn.setButtonText(t("Save to Frontmatter")).setTooltip(t("Save settings to frontmatter and apply")).setCta().onClick(async () => {
      await this.saveAndApply();
      this.close();
    })).addButton((btn) => btn.setButtonText(t("Remove Numbering")).setWarning().onClick(() => {
      this.plugin.formulasManager.removeNumbering();
      new import_obsidian21.Notice(t("Formula numbering removed"));
      this.close();
    }));
  }
  applyNumbering() {
    const info = this.plugin.formulasManager.getActiveViewInfo();
    if (!info)
      return;
    const originalSettings = this.plugin.settings.myFormulas;
    this.plugin.settings.myFormulas = this.settings;
    this.plugin.formulasManager.updateNumbering(true, true);
    this.plugin.settings.myFormulas = originalSettings;
    new import_obsidian21.Notice(t("Formula numbering applied (one-time)"));
  }
  async saveAndApply() {
    await saveSettingsToFrontMatter(this.app, this.file, void 0, this.settings);
    await new Promise((resolve) => setTimeout(resolve, 100));
    this.plugin.formulasManager.updateNumbering(true, true);
    new import_obsidian21.Notice(t("Settings saved to frontmatter and applied"));
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/formulas/manager.ts
var FormulasManager = class {
  constructor(app, plugin) {
    this.app = app;
    this.plugin = plugin;
  }
  async onload() {
    this.plugin.addCommand({
      id: "configure-formulas",
      name: t("Configure Formulas"),
      callback: () => {
        const activeView = this.app.workspace.getActiveViewOfType(import_obsidian22.MarkdownView);
        if (activeView && activeView.file) {
          new FormulasControlModal(this.app, this.plugin, activeView.file).open();
        }
      }
    });
  }
  onunload() {
  }
  getActiveViewInfo() {
    const activeView = this.app.workspace.getActiveViewOfType(import_obsidian22.MarkdownView);
    if (activeView && activeView.file) {
      const data = this.app.metadataCache.getFileCache(activeView.file);
      const editor = activeView.editor;
      if (data && editor) {
        return { activeView, data, editor };
      }
    }
    return void 0;
  }
  getEffectiveSettings(fm) {
    return parseFormulasFrontMatter(fm, this.plugin.settings.myFormulas);
  }
  updateNumbering(force = false, performRestore = true) {
    const info = this.getActiveViewInfo();
    if (!info)
      return false;
    const { data, editor } = info;
    const settings = this.getEffectiveSettings(data.frontmatter);
    if (!settings.enabled && !force)
      return false;
    const cursorBefore = editor.getCursor();
    const scrollBefore = editor.getScrollInfo();
    const lineCount = editor.lineCount();
    const codeRanges = getCodeBlockRanges(data);
    const changes = [];
    let equationCounter = 1;
    const headingFormulaCounters = {};
    const dollarPositions = [];
    for (let i = 0; i < lineCount; i++) {
      const line = editor.getLine(i);
      if (isLineIgnored(i, line, codeRanges))
        continue;
      let pos = -1;
      while ((pos = line.indexOf("$$", pos + 1)) !== -1) {
        dollarPositions.push({ line: i, ch: pos });
      }
    }
    for (let i = 0; i < dollarPositions.length - 1; i += 2) {
      const start = dollarPositions[i];
      const end = dollarPositions[i + 1];
      if (start.line > end.line || start.line === end.line && start.ch >= end.ch)
        continue;
      let formulaContent = "";
      if (start.line === end.line) {
        const line = editor.getLine(start.line);
        formulaContent = line.substring(start.ch, end.ch + 2);
      } else {
        const startLine = editor.getLine(start.line);
        formulaContent += startLine.substring(start.ch) + "\n";
        for (let lineNum = start.line + 1; lineNum < end.line; lineNum++) {
          formulaContent += editor.getLine(lineNum) + "\n";
        }
        const endLine = editor.getLine(end.line);
        formulaContent += endLine.substring(0, end.ch + 2);
      }
      const tagRegex = /\\tag\{([^}]+)\}/;
      const hasTag = formulaContent.match(tagRegex);
      let equationNumber = "";
      if (settings.mode === "heading-based") {
        let currentHeadingNumber = "";
        const headings = data.headings || [];
        const maxDepth = settings.maxDepth || 4;
        let searchIndex = -1;
        for (let j = headings.length - 1; j >= 0; j--) {
          if (headings[j].position.start.line <= start.line) {
            searchIndex = j;
            break;
          }
        }
        let targetHeading = null;
        if (searchIndex !== -1) {
          for (let k = searchIndex; k >= 0; k--) {
            if (headings[k].level <= maxDepth) {
              targetHeading = headings[k];
              break;
            }
          }
        }
        if (targetHeading) {
          const headingLine = editor.getLine(targetHeading.position.start.line);
          const numberExtractRegex = /^\s{0,4}#+\s*([0-9a-zA-Z\u4e00-\u9fa5\u2460-\u2473&].*?)(\s|$)/;
          const match = headingLine.match(numberExtractRegex);
          if (match && match[1]) {
            currentHeadingNumber = match[1].trim();
            if ([".", ":", "\u2014", "-"].some((c) => currentHeadingNumber.endsWith(c))) {
              currentHeadingNumber = currentHeadingNumber.slice(0, -1);
            }
          }
        }
        if (currentHeadingNumber) {
          if (!headingFormulaCounters[currentHeadingNumber])
            headingFormulaCounters[currentHeadingNumber] = 1;
          equationNumber = `${currentHeadingNumber}-${headingFormulaCounters[currentHeadingNumber]}`;
          headingFormulaCounters[currentHeadingNumber]++;
        } else {
          equationNumber = `${equationCounter}`;
          equationCounter++;
        }
      } else {
        equationNumber = `${equationCounter}`;
        equationCounter++;
      }
      if (!hasTag) {
        const endLine = editor.getLine(end.line);
        const beforeDollars = endLine.substring(0, end.ch);
        const afterDollars = endLine.substring(end.ch);
        const newLine = beforeDollars + ` \\tag{${equationNumber}}` + afterDollars;
        changes.push({
          from: { line: end.line, ch: 0 },
          to: { line: end.line, ch: endLine.length },
          text: newLine
        });
      } else {
        const updatedContent = formulaContent.replace(tagRegex, `\\tag{${equationNumber}}`);
        if (updatedContent !== formulaContent) {
          if (start.line === end.line) {
            const line = editor.getLine(start.line);
            changes.push({
              from: { line: start.line, ch: 0 },
              to: { line: start.line, ch: line.length },
              text: line.substring(0, start.ch) + updatedContent + line.substring(end.ch + 2)
            });
          } else {
            changes.push({
              from: { line: start.line, ch: start.ch },
              to: { line: end.line, ch: end.ch + 2 },
              text: updatedContent
            });
          }
        }
      }
    }
    if (changes.length > 0) {
      editor.transaction({ changes });
      if (performRestore) {
        restoreCursor(editor, cursorBefore);
        editor.scrollTo(scrollBefore.left, scrollBefore.top);
      }
      return true;
    }
    return false;
  }
  removeNumbering() {
    const info = this.getActiveViewInfo();
    if (!info)
      return;
    const { editor } = info;
    const changes = [];
    const lineCount = editor.lineCount();
    const tagRegex = /\s*\\tag\{[^}]*\}/;
    const dollarPositions = [];
    for (let i = 0; i < lineCount; i++) {
      const line = editor.getLine(i);
      let pos = -1;
      while ((pos = line.indexOf("$$", pos + 1)) !== -1) {
        dollarPositions.push({ line: i, ch: pos });
      }
    }
    for (let i = 0; i < dollarPositions.length - 1; i += 2) {
      const start = dollarPositions[i];
      const end = dollarPositions[i + 1];
      if (start.line === end.line) {
        const line = editor.getLine(start.line);
        const content = line.substring(start.ch + 2, end.ch);
        if (tagRegex.test(content)) {
          const newContent = content.replace(tagRegex, "");
          changes.push({
            from: { line: start.line, ch: start.ch + 2 },
            to: { line: end.line, ch: end.ch },
            text: newContent
          });
        }
      } else {
        for (let j = start.line; j <= end.line; j++) {
          const line = editor.getLine(j);
          let s = 0, e = line.length;
          if (j === start.line)
            s = start.ch + 2;
          if (j === end.line)
            e = end.ch;
          const c = line.substring(s, e);
          if (tagRegex.test(c)) {
            const n = c.replace(tagRegex, "");
            changes.push({
              from: { line: j, ch: s },
              to: { line: j, ch: e },
              text: n
            });
          }
        }
      }
    }
    if (changes.length > 0) {
      editor.transaction({ changes });
    }
  }
};

// src/formulas/settings-ui.ts
var import_obsidian23 = require("obsidian");
function renderFormulasSettings(containerEl, manager) {
  const settings = manager.plugin.settings.myFormulas;
  new import_obsidian23.Setting(containerEl).setName(t("Auto Number Formulas")).setDesc(t("Automatically number formulas (triggers on blur if enabled)")).addToggle((toggle) => toggle.setValue(settings.auto).onChange(async (value) => {
    settings.auto = value;
    await manager.plugin.saveSettings();
  }));
  new import_obsidian23.Setting(containerEl).setName(t("Numbering Mode")).setDesc(t("Continuous (1, 2, 3) or Heading-based (1.1-1, 1.1-2)")).addDropdown((dropdown) => dropdown.addOption("continuous", t("Continuous")).addOption("heading-based", t("Heading-based")).setValue(settings.mode).onChange(async (value) => {
    settings.mode = value;
    await manager.plugin.saveSettings();
    const nextSetting = containerEl.lastElementChild;
  }));
  const depthSetting = new import_obsidian23.Setting(containerEl).setName(t("Max Heading Depth")).setDesc(t("For Heading-based mode: max depth of heading to use as prefix (e.g. 4 means use H4 at most)")).addSlider((slider) => slider.setLimits(1, 6, 1).setValue(settings.maxDepth).setDynamicTooltip().onChange(async (value) => {
    settings.maxDepth = value;
    await manager.plugin.saveSettings();
  }));
  const updateVisibility = () => {
    if (settings.mode === "heading-based") {
      depthSetting.settingEl.style.display = "";
    } else {
      depthSetting.settingEl.style.display = "none";
    }
  };
  updateVisibility();
  const modeSetting = containerEl.children[containerEl.children.length - 2];
}

// src/utils/auto-numbering.ts
var import_obsidian24 = require("obsidian");
var AutoNumberingController = class {
  constructor(app, plugin, headingsManager, formulasManager) {
    this.autoUpdateTimeout = null;
    // Default refresh interval matching source
    this.REFRESH_INTERVAL = 5e3;
    this.app = app;
    this.plugin = plugin;
    this.headingsManager = headingsManager;
    this.formulasManager = formulasManager;
  }
  onload() {
    this.registerEditorFocusEvents();
  }
  onunload() {
    this.clearAutoUpdateTimer();
  }
  registerEditorFocusEvents() {
    this.plugin.registerDomEvent(window, "blur", () => this.handleBlur());
    this.plugin.registerDomEvent(window, "focus", () => this.handleFocus());
  }
  handleBlur() {
    const activeView = this.app.workspace.getActiveViewOfType(import_obsidian24.MarkdownView);
    if (!activeView || !activeView.file)
      return;
    const data = this.app.metadataCache.getFileCache(activeView.file);
    if (!data)
      return;
    const headingSettings = parseHeadingsFrontMatter(data.frontmatter, this.plugin.settings.myHeadings);
    const formulaSettings = parseFormulasFrontMatter(data.frontmatter, this.plugin.settings.myFormulas);
    const headingsAuto = headingSettings.enabled && headingSettings.auto;
    const formulasAuto = formulaSettings.enabled && formulaSettings.auto;
    if (!headingsAuto && !formulasAuto)
      return;
    this.clearAutoUpdateTimer();
    const delay = this.plugin.settings.refreshInterval || 1e3;
    this.autoUpdateTimeout = window.setTimeout(() => {
      this.performAutoUpdate(activeView, headingSettings, formulaSettings);
    }, delay);
  }
  handleFocus() {
    if (this.autoUpdateTimeout) {
      this.clearAutoUpdateTimer();
    }
  }
  clearAutoUpdateTimer() {
    if (this.autoUpdateTimeout) {
      window.clearTimeout(this.autoUpdateTimeout);
      this.autoUpdateTimeout = null;
    }
  }
  performAutoUpdate(view, headingSettings, formulaSettings) {
    if (!view.editor)
      return;
    const editor = view.editor;
    const headingsAuto = headingSettings.enabled && headingSettings.auto;
    const formulasAuto = formulaSettings.enabled && formulaSettings.auto;
    if (!headingsAuto && !formulasAuto)
      return;
    const cursorBefore = editor.getCursor();
    const scrollBefore = editor.getScrollInfo();
    let isChanged = false;
    try {
      if (headingsAuto) {
        if (this.headingsManager.updateNumbering(false, false)) {
          isChanged = true;
        }
      }
      if (formulasAuto) {
        if (this.formulasManager.updateNumbering(false, false)) {
          isChanged = true;
        }
      }
    } catch (e) {
      console.error("AutoNumbering: Error during update logic", e);
      this.autoUpdateTimeout = null;
      return;
    }
    if (isChanged) {
      restoreCursor(editor, cursorBefore);
      editor.scrollTo(scrollBefore.left, scrollBefore.top);
    }
    this.autoUpdateTimeout = null;
  }
};

// src/main.ts
var AssistantPlugin = class extends import_obsidian25.Plugin {
  async onload() {
    console.log(t("Loading Obsidian Assistant..."));
    console.log(t("Loading Settings..."));
    await this.loadSettings();
    this.foldersManager = new FoldersManager(this.app, this);
    this.pluginsManager = new PluginsManager(this.app, this);
    this.statusBarManager = new StatusBarManager(this.app, this);
    this.snippetsManager = new SnippetsManager(this.app, this);
    this.headingsManager = new HeadingsManager(this.app, this);
    this.formulasManager = new FormulasManager(this.app, this);
    this.autoNumberingController = new AutoNumberingController(this.app, this, this.headingsManager, this.formulasManager);
    if (this.settings.myFolders.enabled)
      await this.foldersManager.onload();
    if (this.settings.myPlugins.enabled)
      await this.pluginsManager.onload();
    if (this.settings.myStatusBar.enabled)
      await this.statusBarManager.onload();
    if (this.settings.mySnippets.enabled)
      await this.snippetsManager.onload();
    if (this.settings.myHeadings.enabled)
      await this.headingsManager.onload();
    if (this.settings.myFormulas.enabled)
      await this.formulasManager.onload();
    if (this.settings.myHeadings.enabled || this.settings.myFormulas.enabled) {
      this.autoNumberingController.onload();
    }
    this.addSettingTab(new AssistantSettingsTab(this.app, this));
  }
  onunload() {
    var _a, _b, _c, _d, _e, _f, _g;
    console.log(t("Unloading Obsidian Assistant..."));
    (_a = this.foldersManager) == null ? void 0 : _a.onunload();
    (_b = this.pluginsManager) == null ? void 0 : _b.onunload();
    (_c = this.statusBarManager) == null ? void 0 : _c.onunload();
    (_d = this.snippetsManager) == null ? void 0 : _d.onunload();
    (_e = this.headingsManager) == null ? void 0 : _e.onunload();
    (_f = this.formulasManager) == null ? void 0 : _f.onunload();
    (_g = this.autoNumberingController) == null ? void 0 : _g.onunload();
  }
  async loadSettings() {
    const loadedData = await this.loadData();
    this.settings = Object.assign({}, DEFAULT_SETTINGS, loadedData);
    if (loadedData == null ? void 0 : loadedData.myHeadings) {
      this.settings.myHeadings = Object.assign({}, DEFAULT_SETTINGS.myHeadings, loadedData.myHeadings);
    }
    if (loadedData == null ? void 0 : loadedData.myFormulas) {
      this.settings.myFormulas = Object.assign({}, DEFAULT_SETTINGS.myFormulas, loadedData.myFormulas);
    }
    if (loadedData == null ? void 0 : loadedData.mySnippets) {
      this.settings.mySnippets = Object.assign({}, DEFAULT_SETTINGS.mySnippets, loadedData.mySnippets);
    }
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
var AssistantSettingsTab = class extends import_obsidian25.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: t("Obsidian Assistant Settings") });
    containerEl.createEl("h3", { text: t("Global Settings") });
    new import_obsidian25.Setting(containerEl).setName(t("Auto-Numbering Refresh Interval")).setDesc(t("Time in milliseconds to wait before auto-numbering triggers (after losing focus)")).addText((text) => text.setPlaceholder("1000").setValue(String(this.plugin.settings.refreshInterval)).onChange(async (value) => {
      const interval = parseInt(value);
      if (!isNaN(interval) && interval > 0) {
        this.plugin.settings.refreshInterval = interval;
        await this.plugin.saveSettings();
      }
    }));
    containerEl.createEl("br");
    containerEl.createEl("h3", { text: t("Modules") });
    this.addPluginSection(
      containerEl,
      t("My Folders"),
      this.plugin.settings.myFolders.enabled,
      async (value) => {
        this.plugin.settings.myFolders.enabled = value;
        await this.plugin.saveSettings();
        if (value) {
          this.plugin.foldersManager.onload();
        } else {
          this.plugin.foldersManager.onunload();
        }
      },
      (el) => {
        renderFoldersSettings(el, this.plugin.foldersManager);
      }
    );
    this.addPluginSection(
      containerEl,
      t("My Plugins"),
      this.plugin.settings.myPlugins.enabled,
      async (value) => {
        this.plugin.settings.myPlugins.enabled = value;
        await this.plugin.saveSettings();
        if (value) {
          this.plugin.pluginsManager.onload();
        } else {
          this.plugin.pluginsManager.onunload();
        }
      },
      (el) => {
        renderPluginsSettings(el, this.plugin.pluginsManager);
      }
    );
    this.addPluginSection(
      containerEl,
      t("My Status Bar"),
      this.plugin.settings.myStatusBar.enabled,
      async (value) => {
        this.plugin.settings.myStatusBar.enabled = value;
        await this.plugin.saveSettings();
        if (value) {
          this.plugin.statusBarManager.onload();
        } else {
          this.plugin.statusBarManager.onunload();
        }
      },
      (el) => {
        renderStatusBarSettings(el, this.plugin.statusBarManager);
      }
    );
    this.addPluginSection(
      containerEl,
      t("My Snippets"),
      this.plugin.settings.mySnippets.enabled,
      async (value) => {
        this.plugin.settings.mySnippets.enabled = value;
        await this.plugin.saveSettings();
        if (value) {
          this.plugin.snippetsManager.onload();
        } else {
          this.plugin.snippetsManager.onunload();
        }
      },
      (el) => {
        renderSnippetsSettings(el, this.plugin.snippetsManager);
      }
    );
    this.addPluginSection(
      containerEl,
      t("My Headings"),
      this.plugin.settings.myHeadings.enabled,
      async (value) => {
        this.plugin.settings.myHeadings.enabled = value;
        await this.plugin.saveSettings();
        if (value) {
          await this.plugin.headingsManager.onload();
        } else {
          this.plugin.headingsManager.onunload();
        }
        const anyActive = value || this.plugin.settings.myFormulas.enabled;
        if (anyActive) {
          this.plugin.autoNumberingController.onunload();
          this.plugin.autoNumberingController.onload();
        } else {
          this.plugin.autoNumberingController.onunload();
        }
      },
      (el) => {
        renderHeadingsSettings(el, this.plugin.headingsManager);
      }
    );
    this.addPluginSection(
      containerEl,
      t("My Formulas"),
      this.plugin.settings.myFormulas.enabled,
      async (value) => {
        this.plugin.settings.myFormulas.enabled = value;
        await this.plugin.saveSettings();
        if (value) {
          await this.plugin.formulasManager.onload();
        } else {
          this.plugin.formulasManager.onunload();
        }
        const anyActive = this.plugin.settings.myHeadings.enabled || value;
        if (anyActive) {
          this.plugin.autoNumberingController.onunload();
          this.plugin.autoNumberingController.onload();
        } else {
          this.plugin.autoNumberingController.onunload();
        }
      },
      (el) => {
        renderFormulasSettings(el, this.plugin.formulasManager);
      }
    );
  }
  addPluginSection(containerEl, title, isEnabled, onToggle, renderBody) {
    const details = containerEl.createEl("details");
    details.open = false;
    details.style.marginBottom = "1em";
    details.style.border = "1px solid var(--background-modifier-border)";
    details.style.borderRadius = "5px";
    const summary = details.createEl("summary");
    summary.style.display = "flex";
    summary.style.alignItems = "center";
    summary.style.justifyContent = "space-between";
    summary.style.padding = "0.5em 1em";
    summary.style.cursor = "pointer";
    summary.style.backgroundColor = "var(--background-secondary)";
    summary.style.borderTopLeftRadius = "5px";
    summary.style.borderTopRightRadius = "5px";
    const titleContainer = summary.createEl("div", { cls: "settings-section-title" });
    titleContainer.style.display = "flex";
    titleContainer.style.alignItems = "center";
    titleContainer.style.gap = "10px";
    titleContainer.createEl("strong", { text: title });
    const toggleContainer = summary.createEl("div");
    toggleContainer.onclick = (e) => e.preventDefault();
    const toggleSetting = new import_obsidian25.Setting(toggleContainer).addToggle((toggle) => toggle.setValue(isEnabled).onChange(onToggle));
    toggleSetting.settingEl.style.border = "none";
    toggleSetting.settingEl.style.padding = "0";
    toggleSetting.infoEl.remove();
    const content = details.createEl("div");
    content.style.padding = "1em";
    content.style.borderTop = "1px solid var(--background-modifier-border)";
    if (isEnabled) {
      renderBody(content);
    } else {
      content.createEl("i", { text: t("Module is disabled.") });
    }
  }
};
